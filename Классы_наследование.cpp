/* В C++ для расширения и изменения классов имеется более удобный метод, чем 
правка кода. Этот способ — наследование классов — позволяет порождать новые классы 
от старых, называемых базовыми классами. Производный класс наследует все свойства, 
включая методы, старого класса. Унаследовать состояние обычно легче, чем построить 
его с нуля. Точно так же порождение класса с помощью наследования обычно проще 
разработки нового. Ниже перечислено, что позволяет делать наследование:
• Добавлять новые возможности в существующий класс. Например, в 
существующий базовый класс массива можно добавить арифметические операции.
• Добавлять данные, которые представляет класс. Например, взяв за основу 
базовый класс строки, можно породить класс, в котором добавлен член данных,
представляющий цвет, и который будет использоваться при выводе строки на экран.
• Изменять поведение методов класса. Например, от класса Passenger, который
представляет услуги, предоставляемые пассажиру авиалинии, можно породить
класс First Class Passenger с более высоким уровнем обслуживания.
 Для создания производного класса не нужен доступ к исходному коду. Если Вы 
приобрели библиотеку классов, которая содержит только заголовочные файлы и
скомпилированный код для методов класса, Вы все равно сможете порождать новые
классы от библиотечных классов. Вы можете передавать собственные классы
другим пользователям, не раскрывая деталей реализации, но предоставляя им 
возможность добавления свойств к этим классам.
	Простой базовый класс.
 В конструкторе задействован список инициализаторов членов: */
TableTennisPlayer::TableTennisPlayer (const string & fn, const string & ln, bool ht) : 
	firstname(fn), lastname(ln), hasTable(ht) {}
// Инициализацию можно выполнить и так:
TableTennisPlayer::TableTennisPlayer (const string & fn, const string & ln, bool ht)
{
	firstname = fn;
	lastname = ln;
	hasTable = ht;
} /* Правда, при таком подходе сначала вызывается конструктор string по умолчанию
для firstname, а затем выполняется операция присваивания для string, которая 
заносит в firstname значение fn. Синтаксис списка инициализаторов членов 
экономит один шаг: он просто инициализирует член firstname значением fn с помощью
конструктора копирования string. */
TableTennisPlayer player1("Chuck", "Blizzard", true);
TableTennisPlayer player2("Tara",  "Boomdea", false);
/* Формальные параметры конструктора объявлены как const string &.
Типы не совпадают, но у класса string, почти как у класса String из главы 12, 
имеется конструктор с параметром const char *, который автоматически вызывается
для создания объекта string, инициализированного строкой в стиле С. 
	Порождение класса. */
// RatedPlayer порожден от базового класса TableTennisPlayer
class RatedPlayer : public TableTennisPlayer {...};
/* Здесь двоеточие указывает на то, что класс RatedPlayer основан на классе
TableTennisPlayer. public TableTennisPlayer является общедоступным базовым классом —
это называется открытым порождением. Объект производного класса содержит в себе 
объект базового класса. При открытом порождении открытые члены базового класса 
становятся открытыми членами производного класса. Закрытые порции базового класса 
становятся частью производного класса, однако доступ к ним возможен только через 
открытые и защищенные методы базового класса. Если объявить объект RatedPlayer, 
он будет обладать следующими особыми характеристиками:
• Объект производного типа хранит данные-члены базового типа. (Производный
класс наследует реализацию базового класса.)
• Объект производного типа может использовать методы базового типа.
(Производный класс наследует интерфейс базового класса.)
 Таким образом, объект RatedPlayer может хранить имя и фамилию каждого игрока, 
а также сведения о том, имеет ли игрок стол. Также объект RatedPlayer может 
использовать методы Name(), HasTable() и ResetTable() из класса TableTennisPlayer
 Необходимо добавить к этим унаследованным свойствам:
• Производному классу нужны собственные конструкторы.
• Производный класс может при необходимости добавлять дополнительные 
данные-члены и методы.
 В нашем случае классу требуется еще один член данных ratings для хранения 
рейтинга и метод для выборки и очистки рейтинга: */
class RatedPlayer : public TableTennisPlayer
{
private:
	unsigned int rating;	// добавленный член данных для хранения рейтинга
public:
	// собственные конструкторы:
	RatedPlayer(unsigned int r = 0, const string & fn = "none", 
				const string & ln = "none", bool ht = false);
	RatedPlayer(unsigned int r, const TableTennisPlayer & tp);
	// добавленные методы:
	unsigned int Rating() const { return rating; }	// для выборки
	void ResetRating(unsigned int r) {rating = r; } // для очистки
};
/* Первый конструктор RatedPlayer использует отдельные формальные параметры для 
каждого члена, а второй конструктор — параметр TableTennisPlayer, связывающий три 
элемента (firstname, lastname и hasTable) в единое целое.
	Варианты доступа.
 Производный класс не имеет непосредственного доступа к закрытым членам базового 
класса, и он вынужден обращаться к ним с помощью методов базового класса. 
Конструкторы RatedPlayer не могут непосредственно устанавливать значения 
унаследованных членов (firstname, lastname и hasTable). Поэтому, чтобы получить 
доступ к закрытым членам базового класса, они должны использовать открытые методы 
базового класса. В частности, конструкторы производного класса должны использовать 
конструкторы базового класса. Когда программа создает объект производного класса, 
сначала конструируется объект базового класса. Это означает, что объект базового 
класса должен быть создан до того, как программа войдет в тело конструктора 
производного класса. Для этого в C++ применяются списки инициализаторов членов: */
RatedPlayer::RatedPlayer(unsigned int r, const string & fn, 
	const string & ln, bool ht) : TableTennisPlayer (fn, ln, ht)
{
	rating = r;
}
//Выражение
: TableTennisPlayer(fn, ln, ht) /* является списком инициализаторов членов.
Это исполняемый код, и он вызывает конструктор TableTennisPlayer. Например: */
RatedPlayer rplayer1(1140, "Mallory", "Duck", true);
/* Конструктор RatedPlayer присваивает формальным параметрам fn, ln и ht 
фактические аргументы "Mallory", "Duck" и true. Потом он передает эти параметры
как фактические аргументы конструктору TableTennisPlayer. Этот конструктор,
в свою очередь, создает вложенный объект TableTennisPlayer и сохраняет в нем
данные "Mallory", "Duck" и true. Затем программа входит в тело конструктора
RatedPlayer, завершает создание объекта RatedPlayer и присваивает члену rating
значение параметра r — т.е. 1140.
 Если опустить вызов конструктора базового класса, программа воспользуется 
конструктором базового класса по умолчанию.
Следовательно, предыдущий код аналогичен следующему: */
RatedPlayer::RatedPlayer(unsigned int r, const string & fn,
	const string & ln, bool ht) // : TableTennisPlayer ()
{
	rating = r;
}
/* Кроме случаев, когда точно нужно использовать конструктор по умолчанию, 
следует предусмотреть явный вызов соответствующего конструктора базового класса.
Теперь рассмотрим код для второго конструктора: */
RatedPlayer::RatedPlayer(unsigned int r, const TableTennisPlayer & tp)
	: TableTennisPlayer(tp)
{
	rating = r;
}
// Информация TableTennisPlayer также передается конструктору TableTennisPlayer:
TableTennisPlayer(tp)
/* Поскольку tp имеет тип const TableTennisPlayer &, вызывается конструктор копирования 
базового класса. Поскольку конструктор копирования в базовом классе не определен, 
компилятор генерирует его автоматически. В данном случае годится неявный конструктор, 
который выполняет почленное копирование, т.к. класс не использует непосредственно 
динамическое выделение памяти. (Члены string используют динамическое выделение памяти, 
однако при почленном копировании таких членов применяется конструктор копирования
класса string.)
 При необходимости для членов производного класса можно также использовать список 
инициализаторов. В этом случае в списке вместо имени класса используется имя члена: */
// Альтернативный вариант
RatedPlayer::RatedPlayer(unsigned int r, const TableTennisPlayer & tp)
	: TableTennisPlayer(tp), rating (r) {}
/* Основные моменты, о конструкторах для производных классов:
• Сначала создается объект базового класса. Конструктор производного
класса всегда вызывает конструктор базового класса. 
• Конструктор производного класса должен передавать информацию базового
класса конструктору базового класса через список инициализаторов членов,
чтобы указать, какой конструктор базового класса следует использовать. В 
противном случае вызывается конструктор базового класса по умолчанию.
• Конструктор производного класса должен инициализировать данные-члены, 
добавленные в производном классе.
 Если не предусмотрены явные деструкторы, используются неявные. Уничтожение 
объектов происходит в порядке, обратном порядку их создания. То есть, сначала 
выполняется тело деструктора производного класса, а затем автоматически 
вызывается деструктор базового класса.
 Если конструктор производного класса получает аргументы, то механизм списка 
инициализаторов передает их значения конструктору базового класса, который 
принимает аргументы указанных типов. За исключением случая виртуальных базовых 
классов, производный класс может передавать значения только своему непосредственному 
базовому классу. Однако принимающий класс может использовать тот же механизм для 
передачи информации своему непосредственному базовому классу и т.д. Список
инициализаторов членов может использоваться только в конструкторах.
	Отношения между производным и базовым классами.
 Объект производного класса может использовать методы базового класса, если эти 
методы не закрытые: */
RatedPlayer rplayer1(1140, "Mallory", "Duck", true);
rplayer1.Name();		//объект производного класса использует метод базового класса
/* Указатель базового класса может указывать на объект производного класса без явного 
приведения типа, а ссылка базового класса может ссылаться на объект производного 
класса без явного приведения типа: */
RatedPlayer rplayer1 (1140, "Mallory", "Duck", true);
TableTennisPlayer & rt = rplayer1;		// РАЗРЕШЕНО
TableTennisPlayer * pt = &rplayer1;		// РАЗРЕШЕНО
rt.Name();		// вызов Name() с помощью ссылки
pt->Name();		// вызов Name() с помощью указателя
/* Однако указатель или ссылка на базовый класс позволяет вызывать методы только
базового класса, поэтому с помощью rt или pt невозможно обратиться, например, к
методу ResetRanking().*/
rt.ResetRanking();		// HE РАЗРЕШЕНО
/* Ссылкам и указателям производного класса запрещено присваивать объекты и адреса 
базового класса: */
TableTennisPlayer player("Betsy", "Bloop", true);
RatedPlayer & rr = player;		// HE РАЗРЕШЕНО
RatedPlayer * pr = player;		// HE РАЗРЕШЕНО
/* Функции, определенные со ссылкой или указателем на базовый класс в качестве 
аргументов, могут использоваться с объектами как базового, так и производного класса: */
void Show(const TableTennisPlayer & rt) // формальный параметр rt является ссылкой на базовый класс
{
	using std::cout;
	cout << "Name:
	rt.Name();				// использует метод базового класса
	cout << "\nTable: ";
	if (rt.HasTable())		// использует метод базового класса
		cout << "yes\n";
	else
		cout << "no\n";
}
/* Формальный параметр rt является ссылкой на базовый класс, следовательно, он
может указывать на объект базового или производного класса. Поэтому метод Show()
можно использовать и с аргументом TableTennis, и с аргументом RatedPlayer: */
TableTennisPlayer player1("Tara", "Boomdea", false);
RatedPlayer rplayer1(1140, "Mallory", "Duck", true);
Show(player1);		// работает с аргументом TableTennisPlayer
Show(rplayer1);		// работает с аргументом RatedPlayer
/* Аналогичное отношение справедливо для функции, у которой формальный параметр 
представляет собой указатель на базовый класс. Ее можно вызвать как с адресом
объекта базового класса, так и с адресом объекта производного класса в качестве 
фактического аргумента: */
void Wohs(const TableTennisPlayer * pt); // функция с параметром-указателем
...
TableTennisPlayer player1("Tara", "Boomdea", false);
RatedPlayer rplayer1(1140, "Mallory", "Duck", true);
Wohs(&player1);	 // работает с аргументом TableTennisPlayer *
Wohs(&rplayer1); // работает с аргументом RatedPlayer *
/* Свойство совместимости ссылок также позволяет инициализировать объект 
базового класса значением объекта производного класса, хоть и не напрямую.
 Пусть: */
RatedPlayer olaf1(1840, "Olaf", "Loaf", true);
TableTennisPlayer olaf2(olaf1);		// инициализация olaf2
/* Точным соответствием для инициализации olaf2 был бы конструктор со 
следующим прототипом: */
TableTennisPlayer(const RatedPlayer &);	// не существует
/* В определениях класса нет такого конструктора, однако существует неявный 
конструктор копирования: */
TableTennisPlayer(const TableTennisPlayer &);
/* Формальный параметр является ссылкой на базовый тип, значит, он может 
указывать и на производный тип. Поэтому при попытке инициализировать olaf2 
значением olaf1 используется данный конструктор, который копирует члены firstname,
lastname и hasTable. To есть он инициализирует olaf2 значением объекта
TableTennisPlayer, вложенного в объект olaf1 типа RatedPlayer.
Аналогично объекту базового класса можно присвоить объект производного класса: */
RatedPlayer olaf1(1840, "Olaf", "Loaf", true);
TableTennisPlayer winner;
winner = olaf1; // присваивание производного объекта базовому объекту
// В этом случае программа использует неявную перегруженную операцию присваивания:
TableTennisPlayer & operator=(const TableTennisPlayer &) const;
/* Ссылка базового класса указывает на объект производного класса, и в winner 
присваивается только часть olaf1, соответствующая базовому классу.
	Наследование: отношение является.
 В C++ имеется три варианта наследования: открытое, защищенное и закрытое. 
Открытое наследование моделирует отношение является (is-a). Это значит, что объект 
производного класса должен также быть объектом базового класса. Все, что можно делать 
с объектом базового класса, должно быть возможным и для объекта производного класса.
 Поскольку производный класс может содержать дополнительные свойства, то, такое отношение 
точнее называть "является разновидностью", однако общепринятым стал термин является.
 Открытое наследование не моделирует отношение содержит, (has-a). has-a легче всего 
моделировать, включив объект в качестве члена данных класса.
 Открытое наследование не моделирует отношение подобен (is-Iike-a) — т.е. оно не 
делает сравнений. Наследование может добавлять свойства в базовый класс, но оно не 
удаляет свойства из базового класса. Для работы с общими характеристиками можно создать 
класс, содержащий эти характеристики, а затем использовать данный класс либо в отношении 
является, либо в отношении содержит для определения взаимосвязанных классов.
 Открытое наследование не моделирует отношение реализован как (is-implemented-as-a). 
Например, можно реализовать стек с помощью массива. Однако будет неправильно породить 
класс Stack от класса Array.
 Открытое наследование не моделирует отношение использует (uses-a). Например, компьютер 
может использовать лазерный принтер, но не имеет смысла порождать класс Printer от класса 
Computer, и наоборот. Однако можно разработать дружественные функции или классы для 
управления обменом данными между объектами Printer и Computer.
 В C++ ничто не мешает использовать открытое наследование для моделирования отношений: 
содержит, реализован как или использует (has-a, is-implemented-as-a, uses-a). Однако это, 
как правило, приводит к проблемам при программировании. Поэтому надо придерживаться 
отношений является (is-a).
	Полиморфное открытое наследование.
 Возможны ситуации, когда метод должен обладать разным поведением в производном и 
базовом классах. Другими словами, поведение конкретного метода может отличаться в
зависимости от объекта, который его вызывает. Такое более сложное поведение 
называется полиморфным, поскольку у метода имеется несколько моделей поведения в
зависимости от контекста. Существуют два основных механизма для реализации 
полиморфного открытого наследования:
• переопределение методов базового класса в производном классе;
• использование виртуальных методов.
 Разработка двух классов:
Один класс представляет чековый счет Brass Account, а второй — чековый счет 
Brass Plus, в котором добавлено свойство защиты от овердрафта (превышения кредита).
То есть, если клиент выписывает чек на сумму, которая больше (но не намного), чем 
его баланс, то банк оплачивает этот чек, предоставляя клиенту кредит для 
дополнительного платежа, и начисляет процент на этот кредит. Эти два вида счета 
можно охарактеризовать через данные, которые требуют хранения, и допустимые операции.
 Информация для счета Brass Account:
• имя клиента;
• номер счета;
• текущий баланс.
 Необходимые операции:
• создание счета;
• внесение денег на счет;
• снятие денег со счета;
• вывод состояния счета.
Счет Brass Plus должен содержать все свойства Brass Account, а также следующие
дополнительные информационные элементы:
• максимальное значение овердрафта;
• процентная ставка, начисляемая на овердрафт;
• величина овердрафта, которую клиент должен банку на данный момент.
 Дополнительные операции не нужны, однако две операции необходимо реализовать 
по-другому:
• операция снятия денег для счета Brass Plus должна содержать защиту от овердрафта;
• операция вывода должна отображать всю дополнительную информацию, 
необходимую для счета Brass Plus.
 Разработка классов Brass и BrassPlus:
Класс BrassPlus соответствует критерию отношения является. Все, что верно для 
объектов Brass, будет верно и для объектов BrassPlus.
• Счет Brass Plus ограничивает сумму денег, которую банк может одолжить клиенту 
для покрытия овердрафта. Значение по умолчанию — $500, но для некоторых клиентов 
может быть установлен другой лимит.
• Банк может изменять предел овердрафта для клиента.
• Счет Brass Plus предусматривает начисление процентов на ссуду. Значение по 
умолчанию — 11,125%, но для некоторых клиентов может быть установлена другая ставка.
• Банк может изменять процентную ставку клиента.
• Счет учитывает, какую сумму клиент должен банку (ссуда овердрафта плюс 
проценты). Клиент не может погасить эту сумму через обычный вклад или 
переводом денег с другого счета. Он должен заплатить наличными специальному 
банковскому служащему, который, если понадобится, будет разыскивать клиента. Как
только долг погашен, на счету указывается нулевое значение задолженности. */
,// brass.h  -- bank account classes
#ifndef _BRASS_H_
#define _BRASS_H_
#include <string>
/* Оба класса объявляют методы ViewAcct() и Withdraw(); однако вести себя
они будут в разных объектах по-разному. */
class Brass
{
private:
    std::string fullName;
    long acctNum;
    double balance;
public:
    Brass(const std::string & s = "Nullbody", long an = -1,
                double bal = 0.0);
    void Deposit(double amt);
    double Balance() const;
// виртуальные методы:
    virtual void ViewAcct() const;
    virtual void Withdraw(double amt);
    virtual ~Brass() {} // виртуальный деструктор, который ничего не делает
};
/* Класс BrassPlus добавляет в класс Brass три новых закрытых члена данных и
три новых открытых функции-члена. */
class BrassPlus : public Brass
{
private:
    double maxLoan;
    double rate;
    double owesBank;
public:
    BrassPlus(const std::string & s = "Nullbody", long an = -1,
            double bal = 0.0, double ml = 500,
            double r = 0.11125);
    BrassPlus(const Brass & ba, double ml = 500, 
		                        double r = 0.11125);
// виртуальные методы:
    virtual void ViewAcct()const;
    virtual void Withdraw(double amt);
    void ResetMax(double m) { maxLoan = m; }
    void ResetRate(double r) { rate = r; };
    void ResetOwes() { owesBank = 0; }
};
#endif
// Уточненным именем для версии базового класса служит Brass::ViewAcct()
void Brass::ViewAcct() const {}
// А для производного класса — BrassPlus::ViewAcct()
void BrassPlus::ViewAcct() const {}
// Для определения нужной версии программа будет использовать тип объекта:
Brass dom	 ("Dominic Banker", 11224, 4183.45);
BrassPlus dot("Dorothy Banker", 12118, 2592.00);
dom.ViewAcct();		// вызывается Brass::ViewAcct()
dot.ViewAcct();		// вызывается BrassPlus::ViewAcct()
/* Аналогично существуют и две версии Withdrawn : одна для объектов Brass и
одна — для объектов BrassPlus. Методы, которые ведут себя одинаково для обоих
классов, такие как Deposit() и Balance(), объявлены только в базовом классе.
 Применение virtual определяет, какой метод используется, если метод вызывается 
не объектом, а ссылкой или указателем. Без ключевого слова virtual программа 
выбирает метод, основываясь на типе ссылки или указателя. Но если присутствует 
ключевое слово virtual, программа выбирает метод, основываясь на типе объекта, 
на который указывает ссылка или указатель. Вот как ведет себя программа, если 
функция ViewAcct() не является виртуальной: */
// Поведение не виртуальной функции ViewAcct()
// Метод выбирается в соответствии с типом ссылки
Brass dom	 ("Dominic Banker", 11224, 4183.45);
BrassPlus dot("Dorothy Banker", 12118, 2592.00);
Brass & b1_ref = dom;
Brass & b2_ref = dot;
b1_ref.ViewAcct();		// вызывается Brass::ViewAcct()
b2_ref.ViewAcct();		// вызывается Brass::ViewAcct()
/* Использование указателей на Brass вместо ссылки дает аналогичное поведение.
Для сравнения продемонстрируем поведение при виртуальной функции ViewAcct(): */
// Поведение виртуальной функции ViewAcct()
// Метод выбирается в соответствии с типом объекта
Brass dom	 ("Dominic Banker", 11224, 4183.45);
BrassPlus dot("Dorothy Banker", 12118, 2592.00);
Brass & b1_ref = dom;
Brass & b2_ref = dot;
b1_ref.ViewAcct();		// вызывается Brass::ViewAcct()
b2_ref.ViewAcct();		// вызывается BrassPlus::ViewAcct()
/* Общей рекомендацией будет объявление в базовом классе в качестве виртуальных тех 
методов, которые могут быть переопределены в производном классе. Если метод объявлен 
в базовом классе как виртуальный, он автоматически является виртуальным и в 
производном классе. Тогда программа выбирает версию метода, основываясь на типе объекта, 
а не на типе ссылки и указателя.Однако в объявлениях производного класса также 
рекомендуется  указывать, какие функции являются виртуальными, с помощью ключевого 
слова virtual. Для правильной последовательности вызовов деструкторов при уничтожении 
производного объекта в базовом классе принято объявлять виртуальный деструктор.
// BrassPlus Methods */
BrassPlus::BrassPlus(const string & s, long an, double bal, // Для доступа к закрытым данным базового класса,
           double ml, double r) : Brass(s, an, bal)         // конструкторы производного класса используют
{                                                           // списки инициализаторов членов.
    maxLoan = ml;
    owesBank = 0.0;
    rate = r;
}
BrassPlus::BrassPlus(const Brass & ba, double ml, double r)
    : Brass(ba)												// используется неявный конструктор копирования
{
    maxLoan = ml;
    owesBank = 0.0;
    rate = r;
}
/* Каждый из этих конструкторов использует список инициализаторов членов для
передачи информации базового класса конструктору базового класса, а затем —
тело конструктора для инициализации новых элементов данных, добавляемых классом
BrassPlus.
 Метод производного класса может вызвать открытый метод базового класса: */
// Переопределение реализации метода ViewAcct()
void BrassPlus::ViewAcct() const
{
	...
    Brass::ViewAcct();                          		// отображение базовой части
    cout << "Maximum loan: $" << maxLoan  << endl;	// максимальный заём
    cout << "Owed to bank: $" << owesBank << endl;	// долг банку
    cout.precision(3);                              // формат ###.###
    cout << "Loan Rate: " << 100 * rate   << "%\n";	// процент на заём
    ... 
}
/* BrassPlus::ViewAcct() выводит добавленные данные-члены BrassPlus
и вызывает метод базового класса Brass::ViewAcct() для вывода данных-членов 
базового класса. Использование операции разрешения контекста в методе 
производного класса для вызова метода базового класса — стандартный прием.
 Предположим, что вместо предыдущего кода написан такой: */
// Переопределение реализации метода ViewAcct()
void BrassPlus::ViewAcct () const
{
	ViewAcct(); // рекурсивный вызов
}
/* При отсутствии операции разрешения контекста компилятор считает, что
ViewAcct() — это BrassPlus::ViewAcct(), и создает рекурсивную функцию без 
завершения — что совсем не хорошо. */
// Переопределение реализации метода Withdraw()
void BrassPlus::Withdraw(double amt)
{
    format initialState = setFormat();
    precis prec = cout.precision(2);				// set up ###.## format
    double bal = Balance();						// определения исходного баланса
    if (amt <= bal)								// Если клиент снимает сумму, превышающую баланс,
        Brass::Withdraw(amt);					// то метод должен оформить ссуду.
    else if ( amt <= bal + maxLoan - owesBank)
    {
        double advance = amt - bal;
        owesBank += advance * (1.0 + rate);
        cout << "Bank advance: $"   << advance		<< endl;		// аванс банка
        cout << "Finance charge: $" << advance * rate	<< endl;		// долг банку
        Deposit(advance);
        Brass::Withdraw(amt);
    }
    else
        cout << "Credit limit exceeded. Transaction cancelled.\n";	// предел кредита превышен
    restore(initialState, prec); 
}
/* Метод может применить Brass::Withdraw() для доступа к члену баланса, но 
Brass::Withdraw() выдает сообщение об ошибке, если снимаемая сумма превышает баланс.
В данной реализации можно избежать этого сообщения, если воспользоваться методом Deposit() 
для открытия ссуды, а затем, при наличии достаточных средств, вызвать Brass::Withdraw().
 Для определения исходного баланса метод использует функцию базового класса Balance().
Код не обязан применять разрешение контекста для Balance(), поскольку этот метод не 
переопределялся в производном классе (не виртуальный).
 Чтобы не дублировать код, часть действий по форматированию вынесена во 
вспомогательные функции: */
// Для целей форматирования
typedef std::ios_base::fmtflags format;
typedef std::streamsize precis;
format setFormat();
void restore(format f, precis p);
/* Функция setFormat() устанавливает формат с фиксированной точкой и 
возвращает предыдущие настройки: */
format setFormat()
{
// Установка формата
	return cout.setf(std::ios_base::fixed, std::ios_base::floatfield);
}
// А функция restore() восстанавливает формат и точность:
void restore(format f, precis p)
{
	cout.setf(f, std::ios_base::floatfield);
	cout.precision(p);
}
/* Предположим, что вам требуется управлять смесью счетов Brass и BrassPlus. Было бы 
удобно иметь единственный массив, хранящий набор объектов Brass и BrassPlus, но это 
невозможно: каждый элемент массива должен относиться к одному и тому же типу, а Brass 
и BrassPlus — два различных типа. Однако можно создать массив указателей на Brass. В 
этом случае все элементы будут одного типа, но благодаря модели общедоступного 
наследования указатель на Brass может указывать либо на объект Brass, либо на объект 
BrassPlus. To есть, по сути, у нас имеется способ представления коллекции данных более 
чем одного типа в едином массиве. Это и есть полиморфизм:  */
// usebrass2.cpp -- polymorphic example // compile with brass.cpp
#include <iostream>
#include <string>
#include "brass.h"
const int CLIENTS = 4;
int main()
{
   using namespace std;
   Brass * p_clients[CLIENTS];
   std::string temp;
   long tempnum;
   double tempbal;
   char kind;
   for (int i = 0; i < CLIENTS; i++)
   {
       cout << "Enter client's name: ";							// ввод имени клиента
       getline(cin,temp);
       cout << "Enter client's account number: ";					// ввод номера счета клиента
       cin  >> tempnum;
       cout << "Enter opening balance: $";						// ввод начального баланса
       cin  >> tempbal;
       cout << "Enter 1 for Brass Account or 2 for BrassPlus Account: ";
       while (cin >> kind && (kind != '1' && kind != '2'))
           cout	  <<"Enter either 1 or 2: ";
       if (kind == '1')
           p_clients[i] = new Brass(temp, tempnum, tempbal);
       else
       {
           double tmax, trate;
           cout << "Enter the overdraft limit: $";					// ввод предельного овердрафта
           cin  >> tmax;
           cout << "Enter the interest rate as a decimal fraction: "; // ввод процентной ставки
           cin  >> trate;
           p_clients[i] = new BrassPlus(temp, tempnum, tempbal,
                                        tmax, trate);
        }
        while (cin.get() != '\n')
            continue;
   }
   cout << endl;
   for (int i = 0; i < CLIENTS; i++)								// обеспечивается полиморфизм
   { /* Если элемент массива указывает на объект Brass, то вызывается Brass::ViewAcct(), 
		а если на объект BrassPlus — то BrassPlus::ViewAcct(). */
       p_clients[i]->ViewAcct();
       cout << endl;
   }
/* Если деструкторы не виртуальные, то вызывается только деструктор, соответствующий 
типу указателя. Это означает, что всегда будет вызываться только деструктор Brass, 
даже если указатель указывает на объект BrassPlus. Но при наличии виртуальных деструкторов, 
если указатель указывает на объект BrassPlus, вызывается деструктор BrassPlus. А когда 
деструктор BrassPlus завершает свою работу, он автоматически вызывает деструктор базового 
класса. Таким образом, применение виртуальных деструкторов гарантирует вызов деструкторов 
в корректной последовательности: */
   for (int i = 0; i < CLIENTS; i++)
   {
       delete p_clients[i];		// освобождение памяти
   }
   cout << "Done.\n";         
   return 0; 
}
/*	Статическое и динамическое связывание.
 Интерпретация вызова функции в исходном коде в виде выполнения определенной части кода 
называется связыванием имени функции. Из-за перегрузки функций компилятор должен учесть 
не только имя, но и аргументы функции, чтобы определить, какую функцию использовать.
Связывание, выполняемое во время компиляции, называется статическим (или ранним) связыванием.
 Виртуальные функции усложняют ситуацию: решение о том, какую функцию использовать, не 
может быть принято во время компиляции, поскольку компилятор не знает, с объектом какого 
типа собирается работать пользователь. Поэтому компилятор должен генерировать код, который 
позволяет выбирать нужный виртуальный метод во время работы программы. Такой процесс 
называется динамическим (или поздним) связыванием.
	Совместимость типов указателей и ссылок.
 Обычно в C++ запрещено присваивать адрес одного типа указателю другого типа. Также не 
разрешается ссылке одного типа ссылаться на другой тип: */
double х = 2.5;
int * pi = &х;	// недопустимое присваиванеи: несоответствие типов указателей
long & rl = х;	// недопустимое присваиванеи: несоответствие типов ссылок
/* Однако ссылка или указатель на базовый класс может ссылаться на объект производного 
класса без явного приведения типа. Например, допустимы такие инициализации: */
BrassPlus dilly ("Annie Dill", 493222, 2000);
Brass * pb = &dilly;		// нормально
Brass & rb = dilly;		// нормально
/* Преобразование ссылки или указателя на производный класс в ссылку или 
указатель на базовый класс называется восходящим приведением. Оно всегда разрешено 
для открытого наследования и не требует явного приведения типа. Это правило является
частью выражения отношения является. Функция, разработанная для управления ссылкой на 
Brass, может без проблем делать то же самое и для объекта BrassPlus. Аналогичный 
принцип применим и при передаче указателя на объект в качестве аргумента функции.
Восходящее приведение транзитивно: если от класса BrassPlus породить класс
BrassPlusPlus, то указатель или ссылка на Brass сможет ссылаться на объект Brass,
BrassPlus или BrassPlusPlus.
 Обратный процесс, т.е. преобразование указателя или ссылки на базовый класс в
указатель или ссылку на производный класс, называется нисходящим приведением, и оно
не разрешено без явного приведения типа. */
class Employee					// работник
{
private:
	char name[40];
public:
	void show_name();
};
class Singer : public Employee	// певец
{
public:
	void range();
};
...
Employee veep;
Singer trala;
...
Employee * pe = &trala;		// Восходящее приведение — допускается неявное приведение типа
Singer * ps = (Singer *) &veep; // Нисходящее приведение — требуется явное приведение типа
...
pe->show_name();				/* Восходящее приведение безопасно, т.к. Singer является Employee
							   (каждый экземпляр Singer наследует name) */
ps->range();					/* Нисходящее приведение небезопасно, т.к. Employee не является Singer
							   (Employee не нужен метод range()).
 Восходящее приведение также выполняется для вызовов функций со ссылками или
указателями на базовый класс в качестве параметров.
Предположим, что каждая функция вызывает виртуальный метод ViewAcct(): */
void fr(Brass & rb);		// использует rb.ViewAcct()
void fp(Brass * pb);		// использует pb->ViewAcct()
void fv(Brass b);		// использует b.ViewAcct()
int main ()
{
	Brass b		("Billy Bee",  123432, 10000.0);
	BrassPlus bp("Betty Beep", 232313, 12345.0);
	fr(b);		// использует Brass::ViewAcct()
	fr(bp);		// использует BrassPlus::ViewAcct()
	fp(b);		// использует Brass::ViewAcct()
	fp(bp);		// использует BrassPlus::ViewAcct()
	fv(b);		// использует Brass::ViewAcct()
	fv(bp);		// использует Brass::ViewAcct()
...
}
/* Передача по значению приводит к передаче в функцию fv() только компонента Brass
из объекта BrassPlus. Однако из-за неявного восходящего приведения, которое 
выполняется со ссылками и указателями, функции fr() и fp() используют Brass::ViewAcct()
для объектов Brass и BrassPlus::ViewAcct() для объектов BrassPlus.
 Из-за выполнения неявного восходящего приведения указатель или ссылка базового 
класса могут ссылаться как на объект базового класса, так и на объект производного 
класса — что делает необходимым динамическое связывание. Такое связывание обеспечивают 
виртуальные методы C++.
	Виртуальные функции-члены и динамическое связывание.
 Процесс вызова метода через ссылку или указатель: */
BrassPlus ophelia;		// объект производного класса
Brass * bp;				// указатель на базовый класс
bp = &ophelia;			// указатель Brass на объект BrassPlus
bp->ViewAcct(); 			// какой вариант?
/* Если функция ViewAcct() не объявлена как виртуальная в базовом классе, то 
выражение bp->ViewAcct() руководствуется типом указателя (Brass *) и вызывает 
Brass::ViewAcct(). Тип указателя известен во время компиляции, поэтому компилятор 
может связать ViewAcct() с Brass::ViewAcct() еще на этапе компиляции. В общем, 
для не виртуальных методов компилятор использует статическое связывание.
 Если функция ViewAcct() объявлена в базовом классе как виртуальная, то выражение 
bp->ViewAcct() руководствуется типом объекта (BrassPlus) и вызывает BrassPlus::ViewAcct().
Тип объекта BrassPlus может быть определен только во время выполнения. Поэтому компилятор 
генерирует код, который во время выполнения программы связывает ViewAcct() с 
Brass::ViewAcct() или BrassPlus::ViewAcct(), в зависимости от типа объекта. То есть 
для виртуальных методов компилятор использует динамическое связывание.
	Зачем существуют два типа связывания, и почему по умолчанию применяется 
	статическое связывание.
 Зачем вообще нужно статическое связывание: эффективность и концептуальная модель.
Если, Вы разрабатываете класс, который не будет использоваться как базовый для
наследования, то Вам не нужно динамическое связывание. Оно не понадобится и когда Вы 
используете производный класс, который не переопределяет методы. Эффективность 
статического связывания и является причиной того, что оно выбирается в C++ по умолчанию.
Страуструп: Вы не должны платить (расходовать память или время) за те возможности, 
которые Вы не используете. Поэтому к виртуальным функциям стоит прибегать только тогда, 
когда они нужны по сути задачи.
 Концептуальная модель: бывает, что при разработке класса появляются функции, которые 
нежелательно переопределять в производных классах. Примером может служить функция 
Brass::Balance(), которая возвращает баланс счета. Объявив эту функцию невиртуальной, Вы, 
во-первых, повысите ее эффективность, а, во-вторых, заявите, что эта функция не должна 
переопределяться. Значит, объявлять виртуальными следует только те методы, которые 
предположительно будут переопределяться.
	Как работают виртуальные функции?
 Обычно компиляторы управляют виртуальными функциями, добавляя в каждый объект скрытый 
член. Этот член хранит указатель на массив адресов функций. Такой массив обычно 
называется таблицей виртуальных функций. Таблица виртуальных функций хранит адреса 
виртуальных функций, объявленных для объектов данного класса. Например, объект базового 
класса содержит указатель на таблицу адресов всех виртуальных функций для этого класса. 
Объект производного класса содержит указатель на отдельную таблицу адресов. Если 
производный класс дает новое определение виртуальной функции, то в таблице виртуальных 
функций содержится адрес новой функции. Если производный класс не переопределяет 
виртуальную функцию, таблица виртуальных функций хранит адрес исходной версии функции.
Если производный класс определяет новую функцию и объявляет ее виртуальной,
ее адрес добавляется в таблицу виртуальных функций. Независимо от количества виртуальных 
функций, в объект добавляется только один адрес; варьируется только размер самой таблицы.*/
class Scientist						// ученый
{
	char name[40];
public:
	virtual void show_name();
	virtual void show_all();
	...
};
class Physicist : public Scientist	// физик
{
	char field[40];
public:
	void show_all();					// переопределена
	virtual void show_field();		// новая
	...
};
// Таблица виртуальных функций в объекте Scientist:
Адрес Scientist::show_name () == 4064; Адрес Scientist::show_all() == 6400;
// Таблица виртуальных функций в объекте Physicist:
// функция не переопределена:				// функция переопределена:
Адрес Scientist::show_name () == 4064; Адрес Physicist::show_all() == 6820;
Адрес Physicist::show_field() == 7280;	// : новая функция
/* Объект Scientist со скрытым указателем vptr, который указывает на таблицу 
виртуальных функций Scientist: */
	...	|	Sophie Fant	|	2008		|
	...	|		name	|	vptr	|
/* Объект Physicist со скрытым указателем vptr, который указывает на таблицу 
виртуальных функций Physicist: */
	...	|	Adam Crusher|	2096		| nuclear structure	|
	...	|		name	|	vptr	|		field		|
Physicist adam("Adam Crusher", "nuclear structure");
Scientist * psc = &adam;	 // 1.Найти значение psc->vptr (равно 2096). 2.Перейти к таблице по адресу 2096.
psc->show_all();			 // 3.Найти адрес второй функции в таблице (равен 6820). 4.Перейти по этому адресу
						 // (6820) и выполнить найденную там функцию.
/* • Если в базовом классе объявление метода класса начинается с ключевого 
слова virtual, то функция становится виртуальной для базового класса и для всех
классов, производных от данного, включая классы, порожденные от 
порожденных классов, и т.д.
• Если виртуальный метод вызывается через ссылку или указатель на объект, то
программа использует метод, определенный для типа объекта, а не для типа
указателя или ссылки. Это называется динамическим (или поздним) связыванием.
Такое поведение очень важно, т.к. указатель или ссылка на базовый класс всегда
может обратиться к объекту производного типа.
• При определении класса, который будет использоваться в качестве базового для
наследования, следует объявить виртуальными те методы классы, которые могут
быть переопределены в производных классах.
	Конструкторы.
 Конструкторы не могут быть виртуальными. При создании объекта производного класса 
вызывается конструктор производного, а не базового класса. Затем конструктор 
производного класса использует конструктор базового класса. Эта последовательность 
отличается от механизма наследования.
	Деструкторы.
 Деструкторы должны быть виртуальными, за исключением тех классов, которые
не используются в качестве базовых. */
Employee * ре = new Singer;	// допустимо, т.к. Employee — базовый класс для Singer
delete ре;					// ~Employee() или ~Singer()?
/* Если применяется стандартное статическое связывание, то оператор delete 
вызывает деструктор ~Employee(). При этом освобождается память, на которую 
указывают компоненты Employee объекта Singer, но не память, на которую указывают 
новые члены класса. Но если деструкторы виртуальные, то тот же самый код вызывает
деструктор ~Singer() для освобождения памяти, на которую указывает компонент
Singer, а затем вызывает деструктор ~Employee() для освобождения памяти, на 
которую указывает компонент Employee. Если для базового класса не требуется 
явный деструктор, следует указать виртуальный деструктор, даже если он ничего 
не будет делать: */
virtual ~BaseClass() {}
/* Наличие виртуального деструктора не будет ошибкой, даже если вы не планируете 
сделать класс базовым, хотя при этом слегка пострадает эффективность.
	Дружественные функции.
 Друзья не могут быть виртуальными функциями: ведь они не являются членами
класса, а виртуальными функциями могут быть только члены. Если это приводит к
проблемам при разработке, то их можно устранить, введя виртуальные функции-члены 
внутри дружественных функций.
	Отсутствие переопределения.
 Если в производном классе нет переопределения какой-то функции (виртуальной или 
нет), то класс будет использовать версию функции из базового класса. Если 
производный класс является частью длинной цепочки порождений, то будет применяться
самая последняя версия функции. Исключение составляет случай, когда базовая версия 
скрыта.
	Переопределение скрывает методы.
Предположим: */
class Dwelling						// жилище
{
public:
	virtual void showperks(int a) const;
};
class Hovel : public Dwelling		// хибара
{
public:
	virtual void showperks() const;
};
// В этом случае вы можете получить предупреждение компилятора наподобие
Warning:	Hovel::showperks(void) hides		Dwelling::showperks(int)
Внимание:	Hovel::showperks(void) скрывает	Dwelling::showperks(int)
/* Но, возможно, предупреждение не будет выдано. В любом случае, из приведенных 
определений следует: */
Hovel trump;
trump.showperks();		// верно
trump.showperks(5);		// неверно
/* Новое определение создает функцию showperks(), которая не принимает аргументы. 
Вместо того чтобы привести к появлению двух перегруженных версий функции, это 
переопределение скрывает версию базового класса, которая принимает аргумент int. 
В общем, переопределение унаследованных методов не является разновидностью перегрузки. 
При переопределении функции в производном классе происходит не просто перегрузка 
объявления базового класса с той же самой сигнатурой функций. Вместо этого скрываются 
все методы базового класса с тем же именем и любыми сигнатурами аргументов.
 Правила:
  Во-первых, при переопределении унаследованного метода необходимо удостовериться в 
точном совпадении с исходным прототипом. Исключение из этого правила состоит в том, 
что если возвращаемый тип является указателем или ссылкой на базовый класс, то его 
можно заменить указателем или ссылкой на производный класс. Это свойство называется 
ковариантностью возвращаемого типа, поскольку возвращаемый тип можно изменять 
параллельно с типом класса: */
class Dwelling						// жилище
{
public:
// Базовый метод:
	virtual Dwelling & build(int n);
};
class Hovel : public Dwelling		// хибара
{
public:
// Производный метод с ковариантным возвращаемым типом:
	virtual Hovel & build(int n);	// та же сигнатура функции
};
/* Данное исключение относится только к возвращаемым значениям, но не к аргументам.
 Во-вторых, если объявление базового класса перегружается, в производном классе
необходимо переопределить все версии базового класса: */
class Dwelling						// жилище
{
public:
// Три перегруженных функции showperks()
virtual void showperks(int a)	 const;
virtual void showperks(double x) const;
virtual void showperks()		 const;
};
class Hovel : public Dwelling		// хибара
{
public:
// Три переопределенных функции showperks()
virtual void showperks(int a)	 const;
virtual void showperks(double x) const;
virtual void showperks()		 const;
};
/* Если переопределить только одну версию, то две остальных становятся скрытыми
и не могут использоваться объектами производного класса. Если никакие изменения
не нужны, то переопределение может просто вызывать версию базового класса: */
void Hovel::showperks() const { Dwelling::showperks(); }
/*	Управление доступом: protected (защищенный).
 Доступ к членам класса из раздела protected можно получить извне только с помощью 
открытых членов класса. Различие между private и protected проявляется только внутри 
классов, порожденных от базового класса. Члены производного класса имеют прямой 
доступ к защищенным protected членам базового класса, но не имеют прямого доступа к 
закрытым членам private базового класса. То есть члены из защищенной категории ведут 
себя как закрытые члены для внешнего мира и как открытые члены для производных классов.
Например, предположим, что в классе Brass член balance объявлен как protected: */
class Brass
{
protected:
	double balance;
...
};
/* В этом случае класс BrassPlus имеет прямой доступ к члену balance без применения 
методов Brass. Например, ядро функции BrassPlus::Withdraw() можно записать так: */
void BrassPlus::Withdraw(double amt)			// виртуальный метод
{
	if (amt < 0)
	cout << "Withdrawal amount must be positive; "
		 <<"withdrawal canceled.\n";			// снимаемая сумма должна быть положительной
	else if (amt <= balance)					// прямой доступ к balance
		balance -= amt;
	else if (amt <= balance + maxLoan - owesBank)
	{
		double advance = amt - balance;
		owesBank += advance * (1.0 + rate);
		cout << "Bank advance: $"		<< advance		  << endl; // аванс банка
		cout << "Finance charge: $"	<< advance * rate << endl; // долг банку
		Deposit(advance);
		balance	 -= amt;
	}
	else
		cout << "Credit limit exceeded. Transaction cancelled.\n";
}
/* Защищенные данные-члены могут упростить код, но в нём присутствует проектный изъян. 
Например, если бы член balance в классе BrassPlus был защищенным, то код можно было бы 
записать следующим образом: */
void BrassPlus::Reset(double amt)
{
	balance = amt;
}
/* Класс Brass разработан таким образом, что интерфейс функций Deposit() и Withdraw() 
предусматривает только один способ для изменения balance. Однако метод Reset(), по сути, 
делает balance открытой переменной для объектов BrassPlus, обходя защитные меры в 
функции Withdraw().
	Абстрактные базовые классы. */
class Ellipse
{
private:
	double x;			// координата х центра эллипса
	double у;			// координата у центра эллипса
	double a;			// большая полуось
	double b;			// малая полуось
	double angle;		// угол наклона в градусах
public:
	void Move(int nx, ny) { x = nx; у = ny; }
	virtual double Area() const { return 3.14159 * a * b; }
	virtual void Rotate(double nang) { angle += nang; }
	virtual void Scale (double sa, double sb) { a *= sa; b *= sb; }
// Теперь предположим, что класс Circle порождается от класса Ellipse:
class Circle : public Ellipse {...};
/* Хотя окружность и является эллипсом, такое порождение несколько неуклюже. 
Например, размер и форма окружности задаются только одним значением (ее радиусом); 
для нее не нужны величины большой полуоси (а) и малой полуоси (b). Конструкторы 
Circle могут присвоить одно и то же значение членам а и b, но тогда будет 
избыточное представление одной и той же информации. Параметр angle и метод 
Rotate() не имеют смысла для окружности, а метод Scale() в существующем виде 
может превратить окружность в овал, по-разному растянув две оси. В целом легче 
определить класс Circle без применения наследования: */
class Circle // без наследования
{
private:
	double x; // координата х центра окружности
	double у; // координата у центра окружности
	double r; // радиус
public:
	void Move(int nx, ny) { x = nx; у = ny; }
	double Area() const { return 3.14159 * r * r; }
	void Scale(double sr) { r *= sr; }
};
/* Теперь класс содержит только необходимые переменные. Но это решение тоже не
удовлетворительно. Классы Circle и Ellipse имеют много общего, однако при их
отдельном определении этот факт игнорируется.
 Из классов Ellipse и Circle можно извлечь их общие свойства и поместить их в АБК. 
Затем можно породить от этого АБК и Circle, и Ellipse. После этого можно, например, 
использовать массив указателей базового класса для работы со смесью объектов Ellipse 
и Circle — т.е. воспользоваться полиморфизмом. В данном случае для двух классов 
общими являются координаты центра фигуры, метод Move(), который работает одинаково 
для двух классов, а также метод Area(), работающий по-разному. Метод Area() и 
невозможно реализовать для АБК, т.к. в нем нет необходимых данных-членов. В C++ 
имеется способ для представления нереализованной функции — чистая виртуальная 
функция, которая в конце своего объявления содержит конструкцию = 0: */
class BaseEllipse						// абстрактный базовый класс (АБК)
{
private:
	double x;							// координата х центра
	double у;							// координата у центра
public:
	BaseEllipse (double x0 = 0, double y0 = 0) : х(х0), у(у0) {}
	virtual ~BaseEllipse() {}
	void Move (int nx, ny) { x = nx; у = ny; }
	virtual double Area() const = 0;		// чистая виртуальная функция
}
/* Если объявление класса содержит чистую виртуальную функцию, то объект 
такого класса создать невозможно. Смысл классов с чистыми виртуальными функциями
в том, что они предназначены только для использования в качестве базовых классов.
Чтобы класс был настоящим АБК, он должен содержать, по крайней мере, одну 
чистую виртуальную функцию. В C++ даже для чистой виртуальной функции допускается 
иметь определение. Например, возможно, что все базовые методы похожи на Move() тем, 
что они могут быть определены для базового класса, но класс все-таки нужно сделать 
абстрактным. Тогда можно сделать абстрактным прототип: */
void Move(int nx, ny) = 0;
/* Базовый класс при этом становится абстрактным. Но после этого все равно можно
записать определение в файле реализации: */
void BaseEllipse::Move(int nx, ny) { x = nx; у = ny; }
/* Теперь от класса BaseEllipse можно породить классы Ellipse и Circle, 
добавляя члены, необходимые для завершения каждого класса. Класс Circle всегда 
представляет окружности, а класс Ellipse представляет эллипсы, которые могут быть 
и окружностями. Однако окружность класса Ellipse можно трансформировать в эллипс, 
а окружность класса Circle должна оставаться окружностью. Программа, использующая 
эти классы, сможет создавать объекты Ellipse и Circle, но не BaseEllipse. Поскольку 
у объектов Circle и Ellipse один и тот же базовый класс, с коллекцией таких 
объектов можно работать с помощью массива указателей на BaseEllipse. Классы, 
подобные Circle и Ellipse, иногда называются конкретными классами, чтобы подчеркнуть 
возможность создавать объекты данных типов. Классы, порождаемые от АБК, содержат 
обычные виртуальные функции для реализации интерфейса со свойствами конкретного 
производного класса.
	Применение концепции абстрактных базовых классов. */
#ifndef _ACCTABC_H_
#define _ACCTABC_H_
#include <iostream>
#include <string>
// Abstract Base Class
class AcctABC
{
private:                                    // закрытые члены
    std::string fullName;
    long   acctNum;
    double balance;
protected:                                  // защищенные члены
/* Здесь определения структур и функции помещены в защищенную часть определения 
класса. Это делает их доступными в базовом классе и производных классах, но 
скрывает от внешнего мира. */
    struct Formatting 
    {
         std::ios_base::fmtflags flag;
         std::streamsize pr;
    };
/* Защищенные методы FullName() и AcctNum() предоставляют доступ только для
чтения к членам данных fullName и acctNum, а также позволяют индивидуально 
настроить функцию ViewAcct() для каждого производного класса. */
    const std::string & FullName() const { return fullName; }
    long AcctNum() const { return acctNum; }
    Formatting SetFormat() const;
    void Restore(Formatting & f) const;
public:										// открытые члены
    AcctABC(const std::string & s = "Nullbody", long an = -1,
            double bal = 0.0);
    void Deposit(double amt) ;
    virtual void Withdraw(double amt) = 0;	// чистая виртуальная функция
    double Balance() const { return balance; };
    virtual void ViewAcct() const = 0;		// чистая виртуальная функция
    virtual ~AcctABC() {}					// виртуальный деструктор 
};
// Brass Account Class
class Brass : public AcctABC                // конкретный класс Brass производный от АБК AcctABC
{
public:
// в списке инициализаторов членов конструктора производного класса есть явный вызов конструктора базового класса:
    Brass(const std::string & s = "Nullbody", long an = -1,	// конструктор инициализирует члены
          double bal = 0.0) : AcctABC(s, an, bal) {}			// AcctABC
    virtual void Withdraw(double amt);
    virtual void ViewAcct() const;
    virtual ~Brass() {}						// виртуальный деструктор
};
// Brass Plus Account Class
class BrassPlus : public AcctABC			// конкретный класс BrassPlus производный от АБК AcctABC
{
private:
    double maxLoan;
    double rate;
    double owesBank;
public:
    BrassPlus(const std::string & s = "Nullbody", long an = -1,
              double bal = 0.0, double ml = 500,  double r = 0.10);
// в списке инициализаторов членов конструктора производного класса есть явный вызов конструктора родительского класса:
    BrassPlus(const Brass & ba, double ml = 500,  double r = 0.1);
    virtual void ViewAcct()const;
    virtual void Withdraw(double amt);
    void ResetMax(double m)  { maxLoan = m; }
    void ResetRate(double r) { rate = r; };
    void ResetOwes() { owesBank = 0; }
};
#endif
// acctabc.cpp — bank account class methods:
// protected methods for formatting — возвращает структуру Formatting
AcctABC::Formatting AcctABC::SetFormat() const
{
 // set up ###.## format
    Formatting f;
    f.flag = cout.setf(ios_base::fixed, ios_base::floatfield);
    f.pr   = cout.precision(2);
    return f; 
}
void AcctABC::Restore(Formatting & f) const	 // изменяет структуру форматирования
{
    cout.setf(f.flag, ios_base::floatfield);
    cout.precision(f.pr);
}
/*	Методология АБК.
 Прежде чем приступить к разработке АБК, сначала нужно выяснить, какие классы необходимы 
в данной задаче, и как они зависят друг от друга. При проектировании иерархии наследования 
классов конкретными классами должны быть только те, которые никогда не будут выступать 
в качестве базовых классов. Такой подход позволяет получить более ясные конструкции с 
меньшими затратами. АБК требует, чтобы его чистые виртуальные функции перегружались во всех
конкретных производных классах — т.е. производный класс должен подчиняться правилам 
интерфейса, установленным в АБК. Эта модель общепринята в парадигмах программирования 
на основе компонентов, где применение АБК позволяет разработчику компонентов создавать 
"интерфейсный контракт". Так гарантируется, что все компоненты, порожденные от АБК, 
поддерживают, по меньшей мере, общие возможности, установленные АБК.
	Наследование и динамическое выделение памяти.
 Если сам производный класс не использует динамическое выделение памяти, то никакие 
особые меры не нужны. Но если использует, их надо принять.
 Случай 1: производный класс не использует операцию new.
Допустим, имеется следующий базовый класс, в котором используется динамическое 
выделение памяти: */
class baseDMA
{
private:
	char * label;
	int rating;
public:
	baseDMA(const char * l = "null", int r = 0);
	baseDMA(const baseDMA & rs);					// явный конструктор копирования
	virtual ~baseDMA();							// виртуальный деструктор
	baseDMA & operator=(const baseDMA & rs);		// перегруженная операция присваивания
	...
};
/* Предположим, что от класса baseDMA нужно породить класс lackDMA, в котором не 
используется ни операция new, ни другие нестандартные возможности, которые 
требуют особого обращения:
// Производный класс lacksDMA, не использующий динамическое выделение памяти */
class lacksDMA : public baseDMA
{
private:
	char color[40];
public:
	...
};
/* Здесь не нужно определять явный деструктор, конструктор копирования и операцию
присваивания для класса lacksDMA. Если деструктор не определен, компилятор
генерирует деструктор по умолчанию, который ничего не делает.
 Конструктор копирования по умолчанию выполняет почленное копирование, что годится 
для нового члена lacksDMA, поскольку не искажает унаследованный объект baseDMA. 
Однако копирование члена класса или унаследованного компонента класса выполняется 
конструктором копирования для данного класса. Поэтому конструктор копирования по 
умолчанию для класса lacksDMA использует явный конструктор копирования baseDMA, 
чтобы скопировать часть baseDMA из объекта lacksDMA. Значит, конструктор 
копирования по умолчанию годится для нового члена lacksDMA, а также для 
унаследованного объекта baseDMA.
 Операция присваивания по умолчанию для производного класса автоматически выполняет 
операцию присваивания базового класса для компонента базового класса.
Эти свойства унаследованных объектов верны и для членов класса, которые сами
являются объектами.
 Случай 2: производный класс использует операцию new
Предположим, что в производном классе применяется операция new: */
class hasDMA : public baseDMA
{
private:
	char * style;		// использование new в конструкторах
public:
	...
};
/* В этом случае, конечно, для производного класса необходимо определить явный
деструктор, конструктор копирования и операцию присваивания. 
 Деструктор производного класса автоматически вызывает деструктор базового
класса, поэтому он сам отвечает только за зачистку действий конструкторов 
производного класса. Значит, деструктор hasDMA должен освободить память, 
управляемую указателем style, и передать управление деструктору baseDMA, который 
освободит память, управляемую указателем label: */
baseDMA::~baseDMA()		// очистка в baseDMA
{
	delete[] label;
}
hasDMA::~hasDMA()		// очистка в hasDMA
{
	delete[] style;
}
/* Конструктор копирования baseDMA следует обычной модели для символьных массивов. 
Это значит, что с помощью функции strlen() определяется размер памяти, необходимой 
для хранения строки в стиле С, выделяется достаточный объем памяти (количество 
символов плюс один байт для нулевого символа) и используется функция strcpy() для 
копирования исходной строки: */
baseDMA::baseDMA(const baseDMA & rs)
{
	label = new char[std::strlen(rs.label) + 1];
	std::strcpy(label, rs.label);
	rating = rs.rating;
}
/* Конструктор копирования hasDMA имеет доступ только к данным hasDMA, поэтому
он должен вызвать конструктор копирования baseDMA для обработки части данных baseDMA: */
hasDMA::hasDMA(const hasDMA & hs) : baseDMA(hs)
{
	style = new char[std::strlen(hs.style) + 1];
	std::strcpy(style, hs.style);
} /* Здесь важно то, что список инициализаторов членов передает ссылку hasDMA 
конструктору baseDMA. He существует ни одного конструктора baseDMA с параметром
типа ссылки на hasDMA, но они и не нужны: ведь конструктору копирования baseDMA
передается ссылка на baseDMA, а ссылка на базовый класс может ссылаться и на 
производный класс. Поэтому конструктор копирования baseDMA использует порцию
baseDMA аргумента hasDMA для создания порции baseDMA нового объекта.
 Операция присваивания baseDMA выглядит вполне обычно: */
baseDMA & baseDMA::operator=(const baseDMA & rs)
{
	if (this == &rs)
		return *this;
	delete[] label;
	label = new char[std::strlen(rs.label) + 1];
	std::strcpy(label, rs.label);
	rating = rs.rating;
	return *this;
}
/* Будучи методом hasDMA, он может непосредственно обращаться только к данным hasDMA. 
Но явная операция присваивания для производного класса должна позаботиться и о 
присваивании для унаследованного объекта baseDMA базового класса. Это можно сделать 
с помощью явного вызова операции присваивания, определенной в базовом классе: */
hasDMA & hasDMA::operator=(const hasDMA & hs)
{
	if (this == &hs)
		return *this;
	baseDMA::operator=(hs);		// явный вызов операции присваивания, определенной в базовом классе
	delete[] style;				// подготовка к операции new для style
	style = new char[std::strlen(hs.style) + 1];
	std::strcpy(style, hs.style);
		return *this;
}
/* Применение функциональной, а не операционной, нотации baseDMA::operator=(hs);
позволяет использовать операцию разрешения контекста. В сущности, этот оператор 
означает следующее: */
*this = hs;						// использовать baseDMA::operator=()
/* из последнего кода компилятор сформирует оператор hasDMA::operator=() — т.е. 
рекурсивный вызов. А вот использование функциональной нотации приводит к вызову 
нужной операции присваивания.
 Если и базовый, и производный классы используют динамическое выделение памяти, то 
деструктор, конструктор копирования и операция присваивания производного класса должны 
применять свои аналоги из базового класса для обработки компонента базового класса.
	Пример наследования с динамическим выделением памяти и дружественными функциями.
// dma.h  -- наследование и динамическое выделение памяти */
#ifndef _DMA_H_
#define _DMA_H_
#include <iostream>
// Базовый класс, использующий динамическое выделение памяти
class baseDMA
{
private:
    char * label;
    int rating;
    
public:
    baseDMA(const char * l = "null", int r = 0);
    baseDMA(const baseDMA & rs);
    virtual ~baseDMA();
    baseDMA & operator=(const baseDMA & rs);
    friend std::ostream & operator<<(std::ostream & os, 
                                     const baseDMA & rs);
};
// Производный класс без динамического выделения памяти
// Деструктор не нужен
// Используется неявный конструктор копирования
// Используется неявная операция присваивания
class lacksDMA : public baseDMA
{
private:
    enum { COL_LEN = 40 };
    char color[COL_LEN];
public:
    lacksDMA(const char * c = "blank", const char * l = "null", int r = 0);
// в списке инициализаторов членов конструктора производного класса есть явный вызов конструктора
    lacksDMA(const char * c, const baseDMA & rs); // базового класса
    friend std::ostream & operator<<(std::ostream & os, const lacksDMA & rs);
};
// Производный класс с динамическим выделением памяти
class hasDMA : public baseDMA
{
private:
    char * style;
public:
    hasDMA(const char * s = "none", const char * l = "null", int r = 0);
// в списке инициализаторов членов конструктора производного класса есть явный вызов конструктора
    hasDMA(const char * s, const baseDMA & rs); // базового класса
    hasDMA(const hasDMA & hs);
    ~hasDMA();
    hasDMA & operator=(const hasDMA & rs);  
    friend std::ostream & operator<<(std::ostream & os, const hasDMA & rs);
};
#endif
/* Поскольку друзья не являются функциями-членами, невозможно использовать разрешение 
контекста, чтобы указать, какую функцию следует вызвать. Для устранения этой проблемы 
можно использовать приведение типа, чтобы соответствующая функция была выбрана на основе 
сопоставления прототипов: */
std::ostream & operator<<(std::ostream & os, const hasDMA & hs)
{ // Приведение типа для соответствия operator<<(ostream &, const baseDMA &):
    os << (const baseDMA &) hs;
    os << "Style: " << hs.style << std::endl;
    return os;
}
/*	Обзор структуры класса.
  Функции-члены, генерируемые компилятором.
 Компилятор автоматически генерирует ряд открытых функций-членов, которые называются 
специальными функциями-членами.
 Конструкторы по умолчанию:
Конструктор по умолчанию либо не имеет аргументов вообще, либо для всех его
аргументов предусмотрены значения по умолчанию. Если вы не определите ни одного
конструктора, компилятор самостоятельно сгенерирует конструктор по умолчанию,
иначе будет невозможно создавать объекты. */
Star rigel;			// создание объекта без явной инициализации
Star pleiades[6];	// создание массива неинициализированных объектов
/* Автоматический конструктор по умолчанию вызывает конструкторы по умолчанию для 
всех базовых классов и для всех членов, которые являются объектами другого класса.
Если в списке инициализаторов членов конструктора производного класса нет явного 
вызова конструктора базового класса, то компилятор использует конструктор по 
умолчанию базового класса для создания части базового класса в новом объекте. 
Если в классе определен хоть какой-нибудь конструктор, компилятор не генерирует 
конструктор по умолчанию.
Конструкторы отличаются от других методов класса тем, что они создают новые
объекты, а остальные методы вызываются существующими объектами. Это одна из
причин, по которым конструкторы не наследуются. Наследование означает, что 
производный объект может использовать метод базового класса, а в случае конструкторов
объект не существует до тех пор, пока конструктор не выполнит свою работу.
 Конструкторы копирования:
Конструктор копирования для класса — это конструктор, который принимает в качестве 
аргумента объект типа этого класса. */
Star (const Star &);
/* Конструктор копирования класса используется в следующих ситуациях:
• новый объект инициализируется объектом того же самого класса;
• объект передается в функцию по значению;
• функция возвращает объект по значению;
• компилятор генерирует временный объект.
Если в программе не используется конструктор копирования (явно или неявно),
то компилятор предоставляет прототип, но не определение функции. Если какой-то 
член сам является объектом класса, то почленная инициализация использует конструктор 
копирования, определенный для этого класса. В некоторых случаях почленнная инициализация 
нежелательна. Например, для инициализации указателей-членов с помощью операции new 
обычно требуется глубокое копирование, как в примере класса baseDMA. Либо класс 
может содержать статическую переменную, которую нужно изменить. В подобных 
ситуациях необходимо определить собственный конструктор копирования.
 Операции присваивания:
Операция присваивания по умолчанию выполняет присваивание одного объекта
другому объекту того же самого класса. */
Star sirius;
Star alpha = sirius;	// инициализация
Star dogstar;
dogstar = sirius;		// присваивание
/* Присваивание по умолчанию выполняется почленно. Если какой-то член сам 
является объектом класса, то почленное присваивание по умолчанию использует 
операцию присваивания, определенную для этого класса. */
Star & Star::operator=(const Star &); /* функция операции присваивания возвращает 
ссылку на объект Star.
Компилятор не генерирует операций присваивания для присваивания одного типа
другому. Предположим, что Вам понадобилось присвоить строку объекту Star. Одним
из способов является явное определение такой операции: */
Star & Star::operator=(const char *) {...}
/* Другой способ — применение функции преобразования для преобразования строки в 
объект Star с последующим использованием функции присваивания объекта Star объекту 
Star. Первый способ быстрее, но требует большего объема кода.
 Соображения по поводу преобразований:
Любой конструктор, который может быть вызван с ровно одним аргументом, определяет 
преобразование из типа аргумента в тип класса этого конструктора. */
Star(const char *);						// преобразует char * в Star
Star(const Spectral &, int members = 1);	// преобразует Spectral в Star
/* Конструкторы преобразования используются, когда преобразуемый тип передается 
функции, которая была определена как принимающая аргумент типа класса. */
Star north;
north = "polaris";
/* Второй оператор вызывает функцию Star::operator=(const Star &), используя
конструктор Star::Star(const char *) для создания объекта Star, который 
передается в качестве аргумента в функцию операции присваивания.
Включение выражения explicit в прототип для конструктора с одним 
аргументом блокирует неявные преобразования, хотя и допускает явные: */
class Star
{
public:
	explicit Star(const char *);
	...
};
Star north;
north = "polaris";		// неявно, не разрешено
north = Star("polaris");	// явно, разрешено
/* Функция преобразования — это функция-член класса без аргументов или с объявленным 
возвращаемым типом, имя которой совпадает с типом, в который выполняется преобразование. 
Несмотря на отсутствие объявленного возвращаемого типа, функция должна возвращать 
требуемое преобразованное значение. */
Star::Star double() {...}		// преобразует star в double
Star::Star const char * (){...}	// преобразует в const char
/* Передача объекта по значению и по ссылке:
Передача объекта по значению означает создание временной копии, а для
этого необходим вызов конструктора копирования и последующий вызов деструктора.
Эти вызовы занимают время, причем копирование большого объекта может длиться
гораздо дольше, чем передача ссылки. В случае наследования с применением виртуальных 
функций функция, которая может принимать в качестве аргумента ссылку на базовый 
класс, может успешно работать и с производными классами.
 Возврат объекта или возврат ссылки:
Иногда нужно, чтобы метод возвращал именно объект, но если это не обязательно, 
то вместо объекта лучше использовать ссылку. */
Star nova1(const Star &);	// возвращает объект Star
Star & nova2(const Star &);	// возвращает ссылку на Star
/* При возврате объекта создается временная копия возвращаемого объекта, и 
вызывающая программа получает доступ к этой копии. Поэтому возврат объекта означает
потерю времени на вызов конструктора копирования для создания копии и на вызов
деструктора для уничтожения этой копии. Возврат ссылки похож на передачу объекта по
ссылке: и вызывающая, и вызываемая функция работают с одним и тем же объектом.
 Если функция возвращает созданный в ней временный объект, то ссылку 
использовать не следует. */
Vector Vector::operator+(const Vector & b) const
{
	return Vector (x + b.x, у + b.y);
}
/* Если функция возвращает объект, переданный в нее через ссылку или указатель, 
то нужно возвращать объект по ссылке. */
const Stock & Stock::topval(const Stock & s) const
{
	if (s.total_val > total_val)
		return s;		// объект-аргумент
	else
		return *this;	// вызывающий объект
}
/* Использование квалификатора const:
Ключевое слово const позволяет гарантировать, что метод не изменит аргумент: */
Star::Star(const char * s) {...}	// не изменяет строку, на которую указывает s
/* Квалификатор const можно также применять для того, чтобы метод не 
модифицировал вызвавший его объект: */
void Star::show() const {...}	// не изменяет вызывающий объект
/* Здесь const означает const Star *this, где this указывает на вызывающий
объект. Квалификатор const позволяет гарантировать, что возвращаемая ссылка 
или указатель не сможет использоваться для изменения данных в объекте: */
const Stock & Stock::topval(const Stock & s) const
{
	if (s.total_val > total_val)
		return s;		// объект-аргумент
	else
		return *this;	// вызывающий объект
}
/* Здесь метод возвращает ссылку либо на this, либо на s. Поскольку и this, 
и s объявлены как const, функция не может изменять их — а значит, и возвращаемая 
ссылка также должна быть объявлена как const. Если функция объявляет аргумент 
как ссылку или указатель на const, она не сможет передать этот аргумент в другую 
функцию, кроме случаев, когда эта другая функция также обещает не изменять аргумент.
  Соображения по поводу открытого наследования.
 Отношения является:
Если производный класс не является разновидностью базового класса, то применять 
открытое наследование не стоит. В некоторых случаях лучше всего создать абстрактный 
класс данных с чистыми виртуальными функциями и породить из него все нужные классы.
Одно из проявлений отношения является состоит в том, что указатель на базовый класс 
может указывать на объект производного класса, а ссылка на базовый класс может 
ссылаться на объект производного класса без явного приведения типа.
 Что не наследуется?
Конструкторы также не наследуются. Для создания производного объекта необходим вызов 
конструктора производного класса. Однако, как правило, конструкторы производного 
класса используют списки инициализаторов членов для вызова конструкторов базового 
класса, которые создают в производном объекте часть базового класса. В С++11 добавлен 
механизм, который делает возможным наследование конструкторов.
Деструкторы также не наследуются. Если в базовом классе используется деструктор по 
умолчанию, то компилятор генерирует деструктор по умолчанию производного класса. В 
общем случае, если класс используется как базовый, его деструктор должен быть виртуальным.
 Соображения по поводу операции присваивания:
Операции присваивания не наследуются. Унаследованный метод должен иметь такую же 
сигнатуру функции в производном классе, что и в базовом. Однако сигнатура операции 
присваивания изменяется от класса к классу, т.к. ее формальный параметр совпадает с 
типом класса. Если объект принадлежит производному классу, то для выполнения присваивания 
части базового класса в объекте производного класса компилятор применяет операцию 
присваивания базового класса. Предположим, что производный класс применяет операцию 
new, и поэтому необходимо написать явную операцию присваивания. Операция должна 
работать для каждого члена класса, а не только для новых членов. */
hasDMA & hasDMA::operator=(const hasDMA & hs)
{
	if (this == &hs)
		return *this;
	baseDMA::operator=(hs);	// явный вызов операции присваивания, определенной в базовом классе
	delete[] style;			// подготовка к операции new для style
	style = new char[std::strlen(hs.style) + 1];
	std::strcpy(style, hs.style);
	return *this;
}
// Рассмотрим следующий пример:
Brass blips;	// базовый класс
BrassPlus snips("Rafe Plosh", 91191, 3993.19, 600.0, 0.12); // производный класс
blips = snips;	// присваивание производного объекта базовому объекту
/* Какая из операций присваивания используется? Оператор присваивания транслируется 
в метод, который вызывается объектом, расположенным в левой части: */
blips.operator=(snips);
// Здесь слева находится объект Brass, поэтому он вызывает функцию
Brass::operator=(const Brass &) /* Отношение является позволяет ссылке на Brass 
ссылаться на объект производного класса, такой как snips. Операция присваивания 
имеет дело только с членами базового класса, поэтому член maxLoan и остальные члены 
из класса BrassPlus объекта snips в присваивании игнорируются. То есть производный 
объект можно присвоить базовому, но при этом задействуются только члены базового 
класса. А можно ли присвоить объект базового класса объекту производного класса? */
Brass gp("Griff Hexbait", 21234, 1200);	// базовый класс
BrassPlus temp;							// производный класс
temp = gp;								// возможно ли это?
// Здесь оператор присваивания транслируется в конструкцию:
temp.operator=(gp);
// Слева указан объект BrassPlus, поэтому он вызывает функцию:
BrassPlus::operator=(const BrassPlus &)
/* Ссылка на производный класс не может автоматически указывать на объект базового 
класса, поэтому данный код не будет работать, если нет соответствующего конструктора 
преобразования: */
BrassPlus(const Brass &);
/* Может оказаться, что конструктор преобразования содержит базовые аргументы и 
дополнительные аргументы, причем для дополнительных аргументов указаны значения 
по умолчанию: */
BrassPlus(const Brass & ba, double ml = 500, double r = 0.1);
/* При наличии конструктора преобразования программа использует его для создания 
из объекта gp временного объекта BrassPlus, который затем передается в качестве 
аргумента операции присваивания. Но можно поступить по-другому — определить 
операцию присваивания базового класса производному классу: */
BrassPlus & BrassPlus::operator=(const Brass &) {...}
/* Здесь типы в точности соответствуют оператору присваивания, поэтому 
преобразования типа не нужны. Т.е. присвоить объект базового класса производному
объекту возможно, если производный класс имеет конструктор, который определяет 
преобразование объекта базового класса в объект производного класса. Можно и тогда, 
когда в производном классе определена операция присваивания объекта базового класса 
объекту производного класса.
 Закрытые и защищенные члены:
Производный класс может напрямую обращаться к защищенным членам базового класса, 
однако доступ к закрытым членам возможен только через методы базового класса. 
Значит, объявление членов базового класса закрытыми усиливает защиту, а объявление 
их защищенными упрощает кодирование и ускоряет доступ.
 Соображения по поводу виртуальных методов:
Если метод потребуется переопределять в производном классе, то в базовом классе его 
следует определить как виртуальный. Тогда будет выполняться позднее, или динамическое 
связывание. Учтите, что некорректный код может обойти динамическое связывание. */
void show(const Brass & rba)
{
	rba.ViewAcct();
	cout << endl;
}
void inadequate(Brass ba)
{
	ba.ViewAcct();
	cout << endl;
}
/* Первая функция передает объект по ссылке, а вторая — по значению. Теперь предположим, 
что каждая из этих функций вызывается с аргументом производного класса: */
BrassPlus buzz("Buzz Parsec", 00001111, 4300);
show(buzz);
inadequate(buzz);
/* В вызове функции show() аргумент rba является ссылкой на объект buzz типа
BrassPlus, поэтому rba.ViewAcct() интерпретируется как версия BrassPlus, что
и должно быть. Но в функции inadequate(), которая передает объект по значению,
ba является объектом Brass, созданным конструктором Brass(const Brass &).
(Автоматическое восходящее приведение позволяет аргументу конструктора 
ссылаться на объект BrassPlus.) Поэтому в inadequate() вызов ba.ViewAcct() считается
версией Brass, и выводится только компонент Brass объекта buzz.
 Соображения по поводу дружественных функций:
Дружественная функция фактически не является членом класса и поэтому не наследуется.
Однако может понадобиться, чтобы друг производного класса использовал дружественную 
функцию базового класса. Для этого необходимо привести тип ссылки или указателя на 
производный класс к эквиваленту базового класса, а затем вызвать дружественную 
функцию базового класса с помощью полученного указателя или ссылки: */
ostream & operator<<(ostream & os, const hasDMA & hs)
{
// Приведение типа для соответствия operator<<(ostream &, const baseDMA &)
	os << (const baseDMA &) hs;
	os << "Style: " << hs.style << endl;
	return os;
}
/* Для приведения типа можно также использовать операцию dynamic_cast<>: */
os << dynamic_cast<const baseDMA &> (hs);
/* Эта форма приведения типа является наиболее предпочтительной.
 Соображения по поводу использования методов базового класса:
• Производный объект автоматически использует унаследованные методы 
базового класса, если в производном классе эти методы не переопределены.
• Деструктор производного класса автоматически вызывает деструктор базового
класса.
• Конструктор производного класса автоматически вызывает конструктор по
умолчанию базового класса, если в списке инициализаторов членов не указан
другой конструктор.
• Конструктор производного класса явно вызывает конструктор базового класса,
указанный в списке инициализаторов членов.
• Методы производного класса могут применять операцию разрешения контекста
для вызова открытых и защищенных методов базового класса.
• Друзья производного класса могут приводить тип ссылки или указателя на 
производный класс к ссылке или указателю на базовый класс и затем использовать 
данную ссылку или указатель для вызова дружественной функции базового класса.
