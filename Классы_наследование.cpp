/* В C++ для расширения и изменения классов имеется более удобный метод, чем 
правка кода. Этот способ — наследование классов — позволяет порождать новые классы 
от старых, называемых базовыми классами. Производный класс наследует все свойства, 
включая методы, старого класса. Унаследовать состояние обычно легче, чем построить 
его с нуля. Точно так же порождение класса с помощью наследования обычно проще 
разработки нового. Ниже перечислено, что позволяет делать наследование:
• Добавлять новые возможности в существующий класс. Например, в 
существующий базовый класс массива можно добавить арифметические операции.
• Добавлять данные, которые представляет класс. Например, взяв за основу 
базовый класс строки, можно породить класс, в котором добавлен член данных,
представляющий цвет, и который будет использоваться при выводе строки на экран.
• Изменять поведение методов класса. Например, от класса Passenger, который
представляет услуги, предоставляемые пассажиру авиалинии, можно породить
класс First Class Passenger с более высоким уровнем обслуживания.
 Для создания производного класса не нужен доступ к исходному коду. Если Вы 
приобрели библиотеку классов, которая содержит только заголовочные файлы и
скомпилированный код для методов класса, Вы все равно сможете порождать новые
классы от библиотечных классов. Вы можете передавать собственные классы
другим пользователям, не раскрывая деталей реализации, но предоставляя им 
возможность добавления свойств к этим классам.
	Простой базовый класс.
 В конструкторе задействован список инициализаторов членов: */
TableTennisPlayer::TableTennisPlayer (const string & fn, const string & ln, bool ht) : 
	firstname(fn), lastname(ln), hasTable(ht) {}
// Инициализацию можно выполнить и так:
TableTennisPlayer::TableTennisPlayer (const string & fn, const string & ln, bool ht)
{
	firstname = fn;
	lastname = ln;
	hasTable = ht;
} /* Правда, при таком подходе сначала вызывается конструктор string по умолчанию
для firstname, а затем выполняется операция присваивания для string, которая 
заносит в firstname значение fn. Синтаксис списка инициализаторов членов 
экономит один шаг: он просто инициализирует член firstname значением fn с помощью
конструктора копирования string. */
TableTennisPlayer player1("Chuck", "Blizzard", true);
TableTennisPlayer player2("Tara",  "Boomdea", false);
/* Формальные параметры конструктора объявлены как const string &.
Типы не совпадают, но у класса string, почти как у класса String из главы 12, 
имеется конструктор с параметром const char *, который автоматически вызывается
для создания объекта string, инициализированного строкой в стиле С. 
	Порождение класса. */
// RatedPlayer порожден от базового класса TableTennisPlayer
class RatedPlayer : public TableTennisPlayer {...};
/* Здесь двоеточие указывает на то, что класс RatedPlayer основан на классе
TableTennisPlayer. public TableTennisPlayer является общедоступным базовым классом —
это называется открытым порождением. Объект производного класса содержит в себе 
объект базового класса. При открытом порождении открытые члены базового класса 
становятся открытыми членами производного класса. Закрытые порции базового класса 
становятся частью производного класса, однако доступ к ним возможен только через 
открытые и защищенные методы базового класса. Если объявить объект RatedPlayer, 
он будет обладать следующими особыми характеристиками:
• Объект производного типа хранит данные-члены базового типа. (Производный
класс наследует реализацию базового класса.)
• Объект производного типа может использовать методы базового типа.
(Производный класс наследует интерфейс базового класса.)
 Таким образом, объект RatedPlayer может хранить имя и фамилию каждого игрока, 
а также сведения о том, имеет ли игрок стол. Также объект RatedPlayer может 
использовать методы Name(), HasTable() и ResetTable() из класса TableTennisPlayer
 Необходимо добавить к этим унаследованным свойствам:
• Производному классу нужны собственные конструкторы.
• Производный класс может при необходимости добавлять дополнительные 
данные-члены и методы.
 В нашем случае классу требуется еще один член данных ratings для хранения 
рейтинга и метод для выборки и очистки рейтинга: */
class RatedPlayer : public TableTennisPlayer
{
private:
	unsigned int rating;	// добавленный член данных для хранения рейтинга
public:
	// собственные конструкторы:
	RatedPlayer(unsigned int r = 0, const string & fn = "none", 
				const string & ln = "none", bool ht = false);
	RatedPlayer(unsigned int r, const TableTennisPlayer & tp);
	// добавленные методы:
	unsigned int Rating() const { return rating; }	// для выборки
	void ResetRating(unsigned int r) {rating = r; } // для очистки
};
/* Первый конструктор RatedPlayer использует отдельные формальные параметры для 
каждого члена, а второй конструктор — параметр TableTennisPlayer, связывающий три 
элемента (firstname, lastname и hasTable) в единое целое.
	Варианты доступа.
 Производный класс не имеет непосредственного доступа к закрытым членам базового 
класса, и он вынужден обращаться к ним с помощью методов базового класса. 
Конструкторы RatedPlayer не могут непосредственно устанавливать значения 
унаследованных членов (firstname, lastname и hasTable). Поэтому, чтобы получить 
доступ к закрытым членам базового класса, они должны использовать открытые методы 
базового класса. В частности, конструкторы производного класса должны использовать 
конструкторы базового класса. Когда программа создает объект производного класса, 
сначала конструируется объект базового класса. Это означает, что объект базового 
класса должен быть создан до того, как программа войдет в тело конструктора 
производного класса. Для этого в C++ применяются списки инициализаторов членов: */
RatedPlayer::RatedPlayer(unsigned int r, const string & fn, 
	const string & ln, bool ht) : TableTennisPlayer (fn, ln, ht)
{
	rating = r;
}
//Выражение
: TableTennisPlayer(fn, ln, ht) /* является списком инициализаторов членов.
Это исполняемый код, и он вызывает конструктор TableTennisPlayer. Например: */
RatedPlayer rplayer1(1140, "Mallory", "Duck", true);
/* Конструктор RatedPlayer присваивает формальным параметрам fn, ln и ht 
фактические аргументы "Mallory", "Duck" и true. Потом он передает эти параметры
как фактические аргументы конструктору TableTennisPlayer. Этот конструктор,
в свою очередь, создает вложенный объект TableTennisPlayer и сохраняет в нем
данные "Mallory", "Duck" и true. Затем программа входит в тело конструктора
RatedPlayer, завершает создание объекта RatedPlayer и присваивает члену rating
значение параметра r — т.е. 1140.
 Если опустить вызов конструктора базового класса, программа воспользуется 
конструктором базового класса по умолчанию.
Следовательно, предыдущий код аналогичен следующему: */
RatedPlayer::RatedPlayer(unsigned int r, const string & fn,
	const string & ln, bool ht) // : TableTennisPlayer ()
{
	rating = r;
}
/* Кроме случаев, когда точно нужно использовать конструктор по умолчанию, 
следует предусмотреть явный вызов соответствующего конструктора базового класса.
Теперь рассмотрим код для второго конструктора: */
RatedPlayer::RatedPlayer(unsigned int r, const TableTennisPlayer & tp)
	: TableTennisPlayer(tp)
{
	rating = r;
}
// Информация TableTennisPlayer также передается конструктору TableTennisPlayer:
TableTennisPlayer(tp)
/* Поскольку tp имеет тип const TableTennisPlayer &, вызывается конструктор копирования 
базового класса. Поскольку конструктор копирования в базовом классе не определен, 
компилятор генерирует его автоматически. В данном случае годится неявный конструктор, 
который выполняет почленное копирование, т.к. класс не использует непосредственно 
динамическое выделение памяти. (Члены string используют динамическое выделение памяти, 
однако при почленном копировании таких членов применяется конструктор копирования
класса string.)
 При необходимости для членов производного класса можно также использовать список 
инициализаторов. В этом случае в списке вместо имени класса используется имя члена: */
// Альтернативный вариант
RatedPlayer::RatedPlayer(unsigned int r, const TableTennisPlayer & tp)
	: TableTennisPlayer(tp), rating (r) {}
/* Основные моменты, о конструкторах для производных классов:
• Сначала создается объект базового класса. Конструктор производного
класса всегда вызывает конструктор базового класса. 
• Конструктор производного класса должен передавать информацию базового
класса конструктору базового класса через список инициализаторов членов,
чтобы указать, какой конструктор базового класса следует использовать. В 
противном случае вызывается конструктор базового класса по умолчанию.
• Конструктор производного класса должен инициализировать данные-члены, 
добавленные в производном классе.
 Если не предусмотрены явные деструкторы, используются неявные. Уничтожение 
объектов происходит в порядке, обратном порядку их создания. То есть, сначала 
выполняется тело деструктора производного класса, а затем автоматически 
вызывается деструктор базового класса.
 Если конструктор производного класса получает аргументы, то механизм списка 
инициализаторов передает их значения конструктору базового класса, который 
принимает аргументы указанных типов. За исключением случая виртуальных базовых 
классов, производный класс может передавать значения только своему непосредственному 
базовому классу. Однако принимающий класс может использовать тот же механизм для 
передачи информации своему непосредственному базовому классу и т.д. Список
инициализаторов членов может использоваться только в конструкторах.
	Отношения между производным и базовым классами.
 Объект производного класса может использовать методы базового класса, если эти 
методы не закрытые: */
RatedPlayer rplayer1(1140, "Mallory", "Duck", true);
rplayer1.Name();		//объект производного класса использует метод базового класса
/* Указатель базового класса может указывать на объект производного класса без явного 
приведения типа, а ссылка базового класса может ссылаться на объект производного 
класса без явного приведения типа: */
RatedPlayer rplayer1 (1140, "Mallory", "Duck", true);
TableTennisPlayer & rt = rplayer1;
TableTennisPlayer * pt = &rplayer1;
rt.Name();	// вызов Name() с помощью ссылки
pt->Name(); // вызов Name() с помощью указателя

/* Однако указатель или ссылка на базовый класс позволяет вызывать методы только
базового класса, поэтому с помощью rt или pt невозможно обратиться, например, к
методу ResetRanking().
 Ссылкам и указателям производного класса запрещено присваивать объекты и адреса 
базового класса: */
TableTennisPlayer player("Betsy", "Bloop", true);
RatedPlayer & rr = player; // HE РАЗРЕШЕНО
RatedPlayer * pr = player; // HE РАЗРЕШЕНО
/* Функции, определенные со ссылкой или указателем на базовый класс в качестве 
аргументов, могут использоваться с объектами как базового, так и производного класса: */
void Show(const TableTennisPlayer & rt)
{
	using std::cout;
	cout << "Name:
	rt.Name();
	cout << "\nTable: ";
	if (rt.HasTableO )
		cout << "yes\n";
	else
		cout << "no\n";
}
/* Формальный параметр rt является ссылкой на базовый класс, следовательно, он
может указывать на объект базового или производного класса. Поэтому метод Show()
можно использовать и с аргументом TableTennis, и с аргументом RatedPlayer: */
TableTennisPlayer player1("Тага", "Boomdea", false);
RatedPlayer rplayer1(1140, "Mallory", "Duck", true);
Show(player1);	// работает с аргументом TableTennisPlayer
Show(rplayer1); // работает с аргументом RatedPlayer
/* Аналогичное отношение справедливо для функции, у которой формальный параметр 
представляет собой указатель на базовый класс. Ее можно вызвать как с адресом
объекта базового класса, так и с адресом объекта производного класса в качестве 
фактического аргумента: */
void Wohs(const TableTennisPlayer * pt); // функция с параметром-указателем
...
TableTennisPlayer player1("Тага", "Boomdea", false);
RatedPlayer rplayer1(1140, "Mallory", "Duck", true);
Wohs(&player1);	 // работает с аргументом TableTennisPlayer *
Wohs(&rplayer1); // работает с аргументом RatedPlayer *
/* Свойство совместимости ссылок также позволяет инициализировать объект 
базового класса значением объекта производного класса, хоть и не напрямую.
 Пусть: */
RatedPlayer olaf1(1840, "Olaf", "Loaf", true);
TableTennisPlayer olaf2(olaf1);
/* Точным соответствием для инициализации olaf2 был бы конструктор со 
следующим прототипом: */
TableTennisPlayer(const RatedPlayer &); // не существует
/* В определениях класса нет такого конструктора, однако существует неявный 
конструктор копирования: */
TableTennisPlayer(const TableTennisPlayer &);
/* Формальный параметр является ссылкой на базовый тип, значит, он может 
указывать и на производный тип. Поэтому при попытке инициализировать olaf2 
значением olaf1 используется данный конструктор, который копирует члены firstname,
lastname и hasTable. To есть он инициализирует olaf2 значением объекта
TableTennisPlayer, вложенного в объект olaf1 типа RatedPlayer.
Аналогично объекту базового класса можно присвоить объект производного класса: */
RatedPlayer olaf1(1840, "Olaf", "Loaf", true);
TableTennisPlayer winner;
winner = olaf1; // присваивание производного объекта базовому объекту
// В этом случае программа использует неявную перегруженную операцию присваивания:
TableTennisPlayer & operator=(const TableTennisPlayer &) const;
/* Ссылка базового класса указывает на объект производного класса, и в winner 
копируется только часть olaf1, соответствующая базовому классу.
	Наследование: отношение является.
 





















