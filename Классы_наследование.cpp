/* В C++ для расширения и изменения классов имеется более удобный метод, чем 
правка кода. Этот способ — наследование классов — позволяет порождать новые классы 
от старых, называемых базовыми классами. Производный класс наследует все свойства, 
включая методы, старого класса. Унаследовать состояние обычно легче, чем построить 
его с нуля. Точно так же порождение класса с помощью наследования обычно проще 
разработки нового. Ниже перечислено, что позволяет делать наследование:
• Добавлять новые возможности в существующий класс. Например, в 
существующий базовый класс массива можно добавить арифметические операции.
• Добавлять данные, которые представляет класс. Например, взяв за основу 
базовый класс строки, можно породить класс, в котором добавлен член данных,
представляющий цвет, и который будет использоваться при выводе строки на экран.
• Изменять поведение методов класса. Например, от класса Passenger, который
представляет услуги, предоставляемые пассажиру авиалинии, можно породить
класс First Class Passenger с более высоким уровнем обслуживания.
 Для создания производного класса не нужен доступ к исходному коду. Если Вы 
приобрели библиотеку классов, которая содержит только заголовочные файлы и
скомпилированный код для методов класса, Вы все равно сможете порождать новые
классы от библиотечных классов. Вы можете передавать собственные классы
другим пользователям, не раскрывая деталей реализации, но предоставляя им 
возможность добавления свойств к этим классам.
	Простой базовый класс.
 В конструкторе задействован список инициализаторов членов: */
TableTennisPlayer::TableTennisPlayer (const string & fn, const string & ln, bool ht) : 
	firstname(fn), lastname(ln), hasTable(ht) {}
// Инициализацию можно выполнить и так:
TableTennisPlayer::TableTennisPlayer (const string & fn, const string & ln, bool ht)
{
	firstname = fn;
	lastname = ln;
	hasTable = ht;
} /* Правда, при таком подходе сначала вызывается конструктор string по умолчанию
для firstname, а затем выполняется операция присваивания для string, которая 
заносит в firstname значение fn. Синтаксис списка инициализаторов членов 
экономит один шаг: он просто инициализирует член firstname значением fn с помощью
конструктора копирования string. */
TableTennisPlayer player1("Chuck", "Blizzard", true);
TableTennisPlayer player2("Tara",  "Boomdea", false);
/* Формальные параметры конструктора объявлены как const string &.
Типы не совпадают, но у класса string, почти как у класса String из главы 12, 
имеется конструктор с параметром const char *, который автоматически вызывается
для создания объекта string, инициализированного строкой в стиле С. 
	Порождение класса. */
// RatedPlayer порожден от базового класса TableTennisPlayer
class RatedPlayer : public TableTennisPlayer {...};
/* Здесь двоеточие указывает на то, что класс RatedPlayer основан на классе
TableTennisPlayer. public TableTennisPlayer является общедоступным базовым классом —
это называется открытым порождением. Объект производного класса содержит в себе 
объект базового класса. При открытом порождении открытые члены базового класса 
становятся открытыми членами производного класса. Закрытые порции базового класса 
становятся частью производного класса, однако доступ к ним возможен только через 
открытые и защищенные методы базового класса. Если объявить объект RatedPlayer, 
он будет обладать следующими особыми характеристиками:
• Объект производного типа хранит данные-члены базового типа. (Производный
класс наследует реализацию базового класса.)
• Объект производного типа может использовать методы базового типа.
(Производный класс наследует интерфейс базового класса.)
 Таким образом, объект RatedPlayer может хранить имя и фамилию каждого игрока, 
а также сведения о том, имеет ли игрок стол. Также объект RatedPlayer может 
использовать методы Name(), HasTable() и ResetTable() из класса TableTennisPlayer
 Необходимо добавить к этим унаследованным свойствам:
• Производному классу нужны собственные конструкторы.
• Производный класс может при необходимости добавлять дополнительные 
данные-члены и методы.
 В нашем случае классу требуется еще один член данных ratings для хранения 
рейтинга и метод для выборки и очистки рейтинга: */
class RatedPlayer : public TableTennisPlayer
{
private:
	unsigned int rating;	// добавленный член данных для хранения рейтинга
public:
	// собственные конструкторы:
	RatedPlayer(unsigned int r = 0, const string & fn = "none", 
				const string & ln = "none", bool ht = false);
	RatedPlayer(unsigned int r, const TableTennisPlayer & tp);
	// добавленные методы:
	unsigned int Rating() const { return rating; }	// для выборки
	void ResetRating(unsigned int r) {rating = r; } // для очистки
};
/* Первый конструктор RatedPlayer использует отдельные формальные параметры для 
каждого члена, а второй конструктор — параметр TableTennisPlayer, связывающий три 
элемента (firstname, lastname и hasTable) в единое целое.
	Варианты доступа.
 Производный класс не имеет непосредственного доступа к закрытым членам базового 
класса, и он вынужден обращаться к ним с помощью методов базового класса. 
Конструкторы RatedPlayer не могут непосредственно устанавливать значения 
унаследованных членов (firstname, lastname и hasTable). Поэтому, чтобы получить 
доступ к закрытым членам базового класса, они должны использовать открытые методы 
базового класса. В частности, конструкторы производного класса должны использовать 
конструкторы базового класса. Когда программа создает объект производного класса, 
сначала конструируется объект базового класса. Это означает, что объект базового 
класса должен быть создан до того, как программа войдет в тело конструктора 
производного класса. Для этого в C++ применяются списки инициализаторов членов: */
RatedPlayer::RatedPlayer(unsigned int r, const string & fn, 
	const string & ln, bool ht) : TableTennisPlayer (fn, ln, ht)
{
	rating = r;
}
//Выражение
: TableTennisPlayer(fn, ln, ht) /* является списком инициализаторов членов.
Это исполняемый код, и он вызывает конструктор TableTennisPlayer. Например: */
RatedPlayer rplayer1(1140, "Mallory", "Duck", true);
/* Конструктор RatedPlayer присваивает формальным параметрам fn, ln и ht 
фактические аргументы "Mallory", "Duck" и true. Потом он передает эти параметры
как фактические аргументы конструктору TableTennisPlayer. Этот конструктор,
в свою очередь, создает вложенный объект TableTennisPlayer и сохраняет в нем
данные "Mallory", "Duck" и true. Затем программа входит в тело конструктора
RatedPlayer, завершает создание объекта RatedPlayer и присваивает члену rating
значение параметра r — т.е. 1140.
 Если опустить вызов конструктора базового класса, программа воспользуется 
конструктором базового класса по умолчанию.
Следовательно, предыдущий код аналогичен следующему: */
RatedPlayer::RatedPlayer(unsigned int r, const string & fn,
	const string & ln, bool ht) // : TableTennisPlayer ()
{
	rating = r;
}
/* Кроме случаев, когда точно нужно использовать конструктор по умолчанию, 
следует предусмотреть явный вызов соответствующего конструктора базового класса.
Теперь рассмотрим код для второго конструктора: */
RatedPlayer::RatedPlayer(unsigned int r, const TableTennisPlayer & tp)
	: TableTennisPlayer(tp)
{
	rating = r;
}
// Информация TableTennisPlayer также передается конструктору TableTennisPlayer:
TableTennisPlayer(tp)
/* Поскольку tp имеет тип const TableTennisPlayer &, вызывается конструктор копирования 
базового класса. Поскольку конструктор копирования в базовом классе не определен, 
компилятор генерирует его автоматически. В данном случае годится неявный конструктор, 
который выполняет почленное копирование, т.к. класс не использует непосредственно 
динамическое выделение памяти. (Члены string используют динамическое выделение памяти, 
однако при почленном копировании таких членов применяется конструктор копирования
класса string.)
 При необходимости для членов производного класса можно также использовать список 
инициализаторов. В этом случае в списке вместо имени класса используется имя члена: */
// Альтернативный вариант
RatedPlayer::RatedPlayer(unsigned int r, const TableTennisPlayer & tp)
	: TableTennisPlayer(tp), rating (r) {}
/* Основные моменты, о конструкторах для производных классов:
• Сначала создается объект базового класса. Конструктор производного
класса всегда вызывает конструктор базового класса. 
• Конструктор производного класса должен передавать информацию базового
класса конструктору базового класса через список инициализаторов членов,
чтобы указать, какой конструктор базового класса следует использовать. В 
противном случае вызывается конструктор базового класса по умолчанию.
• Конструктор производного класса должен инициализировать данные-члены, 
добавленные в производном классе.
 Если не предусмотрены явные деструкторы, используются неявные. Уничтожение 
объектов происходит в порядке, обратном порядку их создания. То есть, сначала 
выполняется тело деструктора производного класса, а затем автоматически 
вызывается деструктор базового класса.
 Если конструктор производного класса получает аргументы, то механизм списка 
инициализаторов передает их значения конструктору базового класса, который 
принимает аргументы указанных типов. За исключением случая виртуальных базовых 
классов, производный класс может передавать значения только своему непосредственному 
базовому классу. Однако принимающий класс может использовать тот же механизм для 
передачи информации своему непосредственному базовому классу и т.д. Список
инициализаторов членов может использоваться только в конструкторах.
	Отношения между производным и базовым классами.
 Объект производного класса может использовать методы базового класса, если эти 
методы не закрытые: */
RatedPlayer rplayer1(1140, "Mallory", "Duck", true);
rplayer1.Name();		//объект производного класса использует метод базового класса
/* Указатель базового класса может указывать на объект производного класса без явного 
приведения типа, а ссылка базового класса может ссылаться на объект производного 
класса без явного приведения типа: */
RatedPlayer rplayer1 (1140, "Mallory", "Duck", true);
TableTennisPlayer & rt = rplayer1;		// РАЗРЕШЕНО
TableTennisPlayer * pt = &rplayer1;		// РАЗРЕШЕНО
rt.Name();		// вызов Name() с помощью ссылки
pt->Name();		// вызов Name() с помощью указателя
/* Однако указатель или ссылка на базовый класс позволяет вызывать методы только
базового класса, поэтому с помощью rt или pt невозможно обратиться, например, к
методу ResetRanking().*/
rt.ResetRanking();		// HE РАЗРЕШЕНО
/* Ссылкам и указателям производного класса запрещено присваивать объекты и адреса 
базового класса: */
TableTennisPlayer player("Betsy", "Bloop", true);
RatedPlayer & rr = player;		// HE РАЗРЕШЕНО
RatedPlayer * pr = player;		// HE РАЗРЕШЕНО
/* Функции, определенные со ссылкой или указателем на базовый класс в качестве 
аргументов, могут использоваться с объектами как базового, так и производного класса: */
void Show(const TableTennisPlayer & rt) // формальный параметр rt является ссылкой на базовый класс
{
	using std::cout;
	cout << "Name:
	rt.Name();				// использует метод базового класса
	cout << "\nTable: ";
	if (rt.HasTable())		// использует метод базового класса
		cout << "yes\n";
	else
		cout << "no\n";
}
/* Формальный параметр rt является ссылкой на базовый класс, следовательно, он
может указывать на объект базового или производного класса. Поэтому метод Show()
можно использовать и с аргументом TableTennis, и с аргументом RatedPlayer: */
TableTennisPlayer player1("Tara", "Boomdea", false);
RatedPlayer rplayer1(1140, "Mallory", "Duck", true);
Show(player1);		// работает с аргументом TableTennisPlayer
Show(rplayer1);		// работает с аргументом RatedPlayer
/* Аналогичное отношение справедливо для функции, у которой формальный параметр 
представляет собой указатель на базовый класс. Ее можно вызвать как с адресом
объекта базового класса, так и с адресом объекта производного класса в качестве 
фактического аргумента: */
void Wohs(const TableTennisPlayer * pt); // функция с параметром-указателем
...
TableTennisPlayer player1("Tara", "Boomdea", false);
RatedPlayer rplayer1(1140, "Mallory", "Duck", true);
Wohs(&player1);	 // работает с аргументом TableTennisPlayer *
Wohs(&rplayer1); // работает с аргументом RatedPlayer *
/* Свойство совместимости ссылок также позволяет инициализировать объект 
базового класса значением объекта производного класса, хоть и не напрямую.
 Пусть: */
RatedPlayer olaf1(1840, "Olaf", "Loaf", true);
TableTennisPlayer olaf2(olaf1);		// инициализация olaf2
/* Точным соответствием для инициализации olaf2 был бы конструктор со 
следующим прототипом: */
TableTennisPlayer(const RatedPlayer &);	// не существует
/* В определениях класса нет такого конструктора, однако существует неявный 
конструктор копирования: */
TableTennisPlayer(const TableTennisPlayer &);
/* Формальный параметр является ссылкой на базовый тип, значит, он может 
указывать и на производный тип. Поэтому при попытке инициализировать olaf2 
значением olaf1 используется данный конструктор, который копирует члены firstname,
lastname и hasTable. To есть он инициализирует olaf2 значением объекта
TableTennisPlayer, вложенного в объект olaf1 типа RatedPlayer.
Аналогично объекту базового класса можно присвоить объект производного класса: */
RatedPlayer olaf1(1840, "Olaf", "Loaf", true);
TableTennisPlayer winner;
winner = olaf1; // присваивание производного объекта базовому объекту
// В этом случае программа использует неявную перегруженную операцию присваивания:
TableTennisPlayer & operator=(const TableTennisPlayer &) const;
/* Ссылка базового класса указывает на объект производного класса, и в winner 
присваивается только часть olaf1, соответствующая базовому классу.
	Наследование: отношение является.
 В C++ имеется три варианта наследования: открытое, защищенное и закрытое. 
Открытое наследование моделирует отношение является (is-a). Это значит, что объект 
производного класса должен также быть объектом базового класса. Все, что можно делать 
с объектом базового класса, должно быть возможным и для объекта производного класса.
 Поскольку производный класс может содержать дополнительные свойства, то, такое отношение 
точнее называть "является разновидностью", однако общепринятым стал термин является.
 Открытое наследование не моделирует отношение содержит, (has-a). has-a легче всего 
моделировать, включив объект в качестве члена данных класса.
 Открытое наследование не моделирует отношение подобен (is-Iike-a) — т.е. оно не 
делает сравнений. Наследование может добавлять свойства в базовый класс, но оно не 
удаляет свойства из базового класса. Для работы с общими характеристиками можно создать 
класс, содержащий эти характеристики, а затем использовать данный класс либо в отношении 
является, либо в отношении содержит для определения взаимосвязанных классов.
 Открытое наследование не моделирует отношение реализован как (is-implemented-as-a). 
Например, можно реализовать стек с помощью массива. Однако будет неправильно породить 
класс Stack от класса Array.
 Открытое наследование не моделирует отношение использует (uses-a). Например, компьютер 
может использовать лазерный принтер, но не имеет смысла порождать класс Printer от класса 
Computer, и наоборот. Однако можно разработать дружественные функции или классы для 
управления обменом данными между объектами Printer и Computer.
 В C++ ничто не мешает использовать открытое наследование для моделирования отношений: 
содержит, реализован как или использует (has-a, is-implemented-as-a, uses-a). Однако это, 
как правило, приводит к проблемам при программировании. Поэтому надо придерживаться 
отношений является (is-a).
	Полиморфное открытое наследование.
 Возможны ситуации, когда метод должен обладать разным поведением в производном и 
базовом классах. Другими словами, поведение конкретного метода может отличаться в
зависимости от объекта, который его вызывает. Такое более сложное поведение 
называется полиморфным, поскольку у метода имеется несколько моделей поведения в
зависимости от контекста. Существуют два основных механизма для реализации 
полиморфного открытого наследования:
• переопределение методов базового класса в производном классе;
• использование виртуальных методов.
 Разработка двух классов:
Один класс представляет чековый счет Brass Account, а второй — чековый счет 
Brass Plus, в котором добавлено свойство защиты от овердрафта (превышения кредита).
То есть, если клиент выписывает чек на сумму, которая больше (но не намного), чем 
его баланс, то банк оплачивает этот чек, предоставляя клиенту кредит для 
дополнительного платежа, и начисляет процент на этот кредит. Эти два вида счета 
можно охарактеризовать через данные, которые требуют хранения, и допустимые операции.
 Информация для счета Brass Account:
• имя клиента;
• номер счета;
• текущий баланс.
 Необходимые операции:
• создание счета;
• внесение денег на счет;
• снятие денег со счета;
• вывод состояния счета.
Счет Brass Plus должен содержать все свойства Brass Account, а также следующие
дополнительные информационные элементы:
• максимальное значение овердрафта;
• процентная ставка, начисляемая на овердрафт;
• величина овердрафта, которую клиент должен банку на данный момент.
 Дополнительные операции не нужны, однако две операции необходимо реализовать 
по-другому:
• операция снятия денег для счета Brass Plus должна содержать защиту от овердрафта;
• операция вывода должна отображать всю дополнительную информацию, 
необходимую для счета Brass Plus.
 Разработка классов Brass и BrassPlus:
Класс BrassPlus соответствует критерию отношения является. Все, что верно для 
объектов Brass, будет верно и для объектов BrassPlus.
• Счет Brass Plus ограничивает сумму денег, которую банк может одолжить клиенту 
для покрытия овердрафта. Значение по умолчанию — $500, но для некоторых клиентов 
может быть установлен другой лимит.
• Банк может изменять предел овердрафта для клиента.
• Счет Brass Plus предусматривает начисление процентов на ссуду. Значение по 
умолчанию — 11,125%, но для некоторых клиентов может быть установлена другая ставка.
• Банк может изменять процентную ставку клиента.
• Счет учитывает, какую сумму клиент должен банку (ссуда овердрафта плюс 
проценты). Клиент не может погасить эту сумму через обычный вклад или 
переводом денег с другого счета. Он должен заплатить наличными специальному 
банковскому служащему, который, если понадобится, будет разыскивать клиента. Как
только долг погашен, на счету указывается нулевое значение задолженности. */
,// brass.h  -- bank account classes
#ifndef _BRASS_H_
#define _BRASS_H_
#include <string>
/* Оба класса объявляют методы ViewAcct() и Withdraw(); однако вести себя
они будут в разных объектах по-разному. */
class Brass
{
private:
    std::string fullName;
    long acctNum;
    double balance;
public:
    Brass(const std::string & s = "Nullbody", long an = -1,
                double bal = 0.0);
    void Deposit(double amt);
    double Balance() const;
// виртуальные методы:
    virtual void ViewAcct() const;
    virtual void Withdraw(double amt);
    virtual ~Brass() {} // виртуальный деструктор, который ничего не делает
};
/* Класс BrassPlus добавляет в класс Brass три новых закрытых члена данных и
три новых открытых функции-члена. */
class BrassPlus : public Brass
{
private:
    double maxLoan;
    double rate;
    double owesBank;
public:
    BrassPlus(const std::string & s = "Nullbody", long an = -1,
            double bal = 0.0, double ml = 500,
            double r = 0.11125);
    BrassPlus(const Brass & ba, double ml = 500, 
		                        double r = 0.11125);
// виртуальные методы:
    virtual void ViewAcct()const;
    virtual void Withdraw(double amt);
    void ResetMax(double m) { maxLoan = m; }
    void ResetRate(double r) { rate = r; };
    void ResetOwes() { owesBank = 0; }
};
#endif
// Уточненным именем для версии базового класса служит Brass::ViewAcct()
void Brass::ViewAcct() const {}
// А для производного класса — BrassPlus::ViewAcct()
void BrassPlus::ViewAcct() const {}
// Для определения нужной версии программа будет использовать тип объекта:
Brass dom	 ("Dominic Banker", 11224, 4183.45);
BrassPlus dot("Dorothy Banker", 12118, 2592.00);
dom.ViewAcct();		// вызывается Brass::ViewAcct()
dot.ViewAcct();		// вызывается BrassPlus::ViewAcct()
/* Аналогично существуют и две версии Withdrawn : одна для объектов Brass и
одна — для объектов BrassPlus. Методы, которые ведут себя одинаково для обоих
классов, такие как Deposit() и Balance(), объявлены только в базовом классе.
 Применение virtual определяет, какой метод используется, если метод вызывается 
не объектом, а ссылкой или указателем. Без ключевого слова virtual программа 
выбирает метод, основываясь на типе ссылки или указателя. Но если присутствует 
ключевое слово virtual, программа выбирает метод, основываясь на типе объекта, 
на который указывает ссылка или указатель. Вот как ведет себя программа, если 
функция ViewAcct() не является виртуальной: */
// Поведение не виртуальной функции ViewAcct()
// Метод выбирается в соответствии с типом ссылки
Brass dom	 ("Dominic Banker", 11224, 4183.45);
BrassPlus dot("Dorothy Banker", 12118, 2592.00);
Brass & b1_ref = dom;
Brass & b2_ref = dot;
b1_ref.ViewAcct();		// вызывается Brass::ViewAcct()
b2_ref.ViewAcct();		// вызывается Brass::ViewAcct()
/* Использование указателей на Brass вместо ссылки дает аналогичное поведение.
Для сравнения продемонстрируем поведение при виртуальной функции ViewAcct(): */
// Поведение виртуальной функции ViewAcct()
// Метод выбирается в соответствии с типом объекта
Brass dom	 ("Dominic Banker", 11224, 4183.45);
BrassPlus dot("Dorothy Banker", 12118, 2592.00);
Brass & b1_ref = dom;
Brass & b2_ref = dot;
b1_ref.ViewAcct();		// вызывается Brass::ViewAcct()
b2_ref.ViewAcct();		// вызывается BrassPlus::ViewAcct()
/* Общей рекомендацией будет объявление в базовом классе в качестве виртуальных тех 
методов, которые могут быть переопределены в производном классе. Если метод объявлен 
в базовом классе как виртуальный, он автоматически является виртуальным и в 
производном классе. Тогда программа выбирает версию метода, основываясь на типе объекта, 
а не на типе ссылки и указателя.Однако в объявлениях производного класса также 
рекомендуется  указывать, какие функции являются виртуальными, с помощью ключевого 
слова virtual. Для правильной последовательности вызовов деструкторов при уничтожении 
производного объекта в базовом классе принято объявлять виртуальный деструктор.
// BrassPlus Methods */
BrassPlus::BrassPlus(const string & s, long an, double bal, // Для доступа к закрытым данным базового класса,
           double ml, double r) : Brass(s, an, bal)         // конструкторы производного класса используют
{                                                           // списки инициализаторов членов.
    maxLoan = ml;
    owesBank = 0.0;
    rate = r;
}
BrassPlus::BrassPlus(const Brass & ba, double ml, double r)
    : Brass(ba)												// используется неявный конструктор копирования
{
    maxLoan = ml;
    owesBank = 0.0;
    rate = r;
}
/* Каждый из этих конструкторов использует список инициализаторов членов для
передачи информации базового класса конструктору базового класса, а затем —
тело конструктора для инициализации новых элементов данных, добавляемых классом
BrassPlus.
 Метод производного класса может вызвать открытый метод базового класса: */
// Переопределение реализации метода ViewAcct()
void BrassPlus::ViewAcct() const
{
	...
    Brass::ViewAcct();                          		// отображение базовой части
    cout << "Maximum loan: $" << maxLoan  << endl;	// максимальный заём
    cout << "Owed to bank: $" << owesBank << endl;	// долг банку
    cout.precision(3);                              // формат ###.###
    cout << "Loan Rate: " << 100 * rate   << "%\n";	// процент на заём
    ... 
}
/* BrassPlus::ViewAcct() выводит добавленные данные-члены BrassPlus
и вызывает метод базового класса Brass::ViewAcct() для вывода данных-членов 
базового класса. Использование операции разрешения контекста в методе 
производного класса для вызова метода базового класса — стандартный прием.
 Предположим, что вместо предыдущего кода написан такой: */
// Переопределение реализации метода ViewAcct()
void BrassPlus::ViewAcct () const
{
	ViewAcct(); // рекурсивный вызов
}
/* При отсутствии операции разрешения контекста компилятор считает, что
ViewAcct() — это BrassPlus::ViewAcct(), и создает рекурсивную функцию без 
завершения — что совсем не хорошо. */
// Переопределение реализации метода Withdraw()
void BrassPlus::Withdraw(double amt)
{
    format initialState = setFormat();
    precis prec = cout.precision(2);								// set up ###.## format
    double bal = Balance();						// определения исходного баланса
    if (amt <= bal)								// Если клиент снимает сумму, превышающую баланс,
        Brass::Withdraw(amt);					// то метод должен оформить ссуду.
    else if ( amt <= bal + maxLoan - owesBank)
    {
        double advance = amt - bal;
        owesBank += advance * (1.0 + rate);
        cout << "Bank advance: $"   << advance		<< endl;		// аванс банка
        cout << "Finance charge: $" << advance * rate	<< endl;		// долг банку
        Deposit(advance);
        Brass::Withdraw(amt);
    }
    else
        cout << "Credit limit exceeded. Transaction cancelled.\n";	// предел кредита превышен
    restore(initialState, prec); 
}
/* Метод может применить Brass::Withdraw() для доступа к члену баланса, но 
Brass::Withdraw() выдает сообщение об ошибке, если снимаемая сумма превышает баланс.
В данной реализации можно избежать этого сообщения, если воспользоваться методом Deposit() 
для открытия ссуды, а затем, при наличии достаточных средств, вызвать Brass::Withdraw().
 Для определения исходного баланса метод использует функцию базового класса Balance().
Код не обязан применять разрешение контекста для Balance(), поскольку этот метод не 
переопределялся в производном классе (не виртуальный).
 Чтобы не дублировать код, часть действий по форматированию вынесена во 
вспомогательные функции: */
// Для целей форматирования
typedef std::ios_base::fmtflags format;
typedef std::streamsize precis;
format setFormat();
void restore(format f, precis p);
/*Функция setFormat() устанавливает формат с фиксированной точкой и 
возвращает предыдущие настройки: */
format setFormat()
{
// Установка формата
	return cout.setf(std::ios_base::fixed, std::ios_base::floatfield);
}
// А функция restore() восстанавливает формат и точность:
void restore(format f, precis p)
{
	cout.setf(f, std::ios_base::floatfield);
	cout.precision(p);
}
/* Предположим, что вам требуется управлять смесью счетов Brass и BrassPlus. Было бы 
удобно иметь единственный массив, хранящий набор объектов Brass и BrassPlus, но это 
невозможно: каждый элемент массива должен относиться к одному и тому же типу, а Brass 
и BrassPlus — два различных типа. Однако можно создать массив указателей на Brass. В 
этом случае все элементы будут одного типа, но благодаря модели общедоступного 
наследования указатель на Brass может указывать либо на объект Brass, либо на объект 
BrassPlus. To есть, по сути, у нас имеется способ представления коллекции данных более 
чем одного типа в едином массиве. Это и есть полиморфизм:  */
// usebrass2.cpp -- polymorphic example // compile with brass.cpp
#include <iostream>
#include <string>
#include "brass.h"
const int CLIENTS = 4;
int main()
{
   using std::cin;
   using std::cout;
   using std::endl;
   Brass * p_clients[CLIENTS];
   std::string temp;
   long tempnum;
   double tempbal;
   char kind;
   for (int i = 0; i < CLIENTS; i++)
   {
       cout << "Enter client's name: ";							// ввод имени клиента
       getline(cin,temp);
       cout << "Enter client's account number: ";					// ввод номера счета клиента
       cin  >> tempnum;
       cout << "Enter opening balance: $";						// ввод начального баланса
       cin  >> tempbal;
       cout << "Enter 1 for Brass Account or "
            << "2 for BrassPlus Account: ";
       while (cin >> kind && (kind != '1' && kind != '2'))
           cout	  <<"Enter either 1 or 2: ";
       if (kind == '1')
           p_clients[i] = new Brass(temp, tempnum, tempbal);
       else
       {
           double tmax, trate;
           cout << "Enter the overdraft limit: $";					// ввод предельного овердрафта
           cin  >> tmax;
           cout << "Enter the interest rate "						// ввод процентной ставки
                << "as a decimal fraction: ";
           cin  >> trate;
           p_clients[i] = new BrassPlus(temp, tempnum, tempbal,
                                        tmax, trate);
        }
        while (cin.get() != '\n')
            continue;
   }
   cout << endl;
   for (int i = 0; i < CLIENTS; i++)								// обеспечивается полиморфизм
   { /* Если элемент массива указывает на объект Brass, то вызывается Brass::ViewAcct(), 
		а если на объект BrassPlus — то BrassPlus::ViewAcct(). */
       p_clients[i]->ViewAcct();
       cout << endl;
   }
/* Если деструкторы не виртуальные, то вызывается только деструктор, соответствующий 
типу указателя. Это означает, что всегда будет вызываться только деструктор Brass, 
даже если указатель указывает на объект BrassPlus. Но при наличии виртуальных деструкторов, 
если указатель указывает на объект BrassPlus, вызывается деструктор BrassPlus. А когда 
деструктор BrassPlus завершает свою работу, он автоматически вызывает конструктор базового 
класса. Таким образом, применение виртуальных деструкторов гарантирует вызов деструкторов 
в корректной последовательности: */
   for (int i = 0; i < CLIENTS; i++)
   {
       delete p_clients[i];										// освобождение памяти
   }
   cout << "Done.\n";         
   return 0; 
}
/*	Статическое и динамическое связывание.
 Интерпретация вызова функции в исходном коде в виде выполнения определенной части кода 
называется связыванием имени функции. Из-за перегрузки функций компилятор должен учесть 
не только имя, но и аргументы функции, чтобы определить, какую функцию использовать.
Связывание, выполняемое во время компиляции, называется статическим (или ранним) связыванием.
 Виртуальные функции усложняют ситуацию: решение о том, какую функцию использовать, не 
может быть принято во время компиляции, поскольку компилятор не знает, с объектом какого 
типа собирается работать пользователь. Поэтому компилятор должен генерировать код, который 
позволяет выбирать нужный виртуальный метод во время работы программы. Такой процесс 
называется динамическим (или поздним) связыванием.
	Совместимость типов указателей и ссылок.
 Обычно в C++ запрещено присваивать адрес одного типа указателю другого типа. Также не 
разрешается ссылке одного типа ссылаться на другой тип: */
double х = 2.5;
int * pi = &х;	// недопустимое присваиванеи: несоответствие типов указателей
long & rl = х;	// недопустимое присваиванеи: несоответствие типов ссылок
/* Однако ссылка или указатель на базовый класс может ссылаться на объект производного 
класса без явного приведения типа. Например, допустимы такие инициализации: */
BrassPlus dilly ("Annie Dill", 493222, 2000);
Brass * pb = &dilly;		// нормально
Brass & rb = dilly;		// нормально
/* Преобразование ссылки или указателя на производный класс в ссылку или 
указатель на базовый класс называется восходящим приведением. Оно всегда разрешено 
для открытого наследования и не требует явного приведения типа. Это правило является
частью выражения отношения является. Функция, разработанная для управления ссылкой на 
Brass, может без проблем делать то же самое и для объекта BrassPlus. Аналогичный 
принцип применим и при передаче указателя на объект в качестве аргумента функции.
Восходящее приведение транзитивно: если от класса BrassPlus породить класс
BrassPlusPlus, то указатель или ссылка на Brass сможет ссылаться на объект Brass,
BrassPlus или BrassPlusPlus.
 Обратный процесс, т.е. преобразование указателя или ссылки на базовый класс в
указатель или ссылку на производный класс, называется нисходящим приведением, и оно
не разрешено без явного приведения типа.
 Восходящее приведение также выполняется для вызовов функций со ссылками или
указателями на базовый класс в качестве параметров.
Предположим, что каждая функция вызывает виртуальный метод ViewAcct(): */
void fr(Brass & rb);		// использует rb.ViewAcct()
void fp(Brass * pb);		// использует pb->ViewAcct()
void fv(Brass b);		// использует b.ViewAcct()
int main ()
{
	Brass b		("Billy Bee",  123432, 10000.0);
	BrassPlus bp("Betty Beep", 232313, 12345.0);
	fr(b);		// использует Brass::ViewAcct()
	fr(bp);		// использует BrassPlus::ViewAcct()
	fp(b);		// использует Brass::ViewAcct()
	fp(bp);		// использует BrassPlus::ViewAcct()
	fv(b);		// использует Brass::ViewAcct()
	fv(bp);		// использует Brass::ViewAcct()
...
}
/* Передача по значению приводит к передаче в функцию fv() только компонента Brass
из объекта BrassPlus. Однако из-за неявного восходящего приведения, которое 
выполняется со ссылками и указателями, функции fr() и fp() используют Brass::ViewAcct()
для объектов Brass и BrassPlus::ViewAcct() для объектов BrassPlus.
 Из-за выполнения неявного восходящего приведения указатель или ссылка базового 
класса могут ссылаться как на объект базового класса, так и на объект производного 
класса — что делает необходимым динамическое связывание. Такое связывание обеспечивают 
виртуальные методы C++.
	Виртуальные функции-члены и динамическое связывание.
 













