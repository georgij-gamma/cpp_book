/*	При объектно-ориентированном подходе вы концентрируетесь на
объекте, как его представляет пользователь, думая о данных, которые нужны для 
описания объекта, и операциях, описывающих взаимодействие пользователя с данными.
После разработки описания интерфейса вы перейдете к выработке решений о том,
как реализовать этот интерфейс и как организовать хранение данных. И, наконец, вы
соберете все это вместе в программу, соответствующую новому проекту.
	Абстракция — это ключевой шаг в представлении информации в
терминах ее интерфейса с пользователем. То есть вы абстрагируете основные 
операционные характеристики проблемы и выражаете решение в этих терминах.
	Спецификация базового типа выполняет три вещи.
• Определяет, сколько памяти нужно объекту.
• Определяет, как интерпретируются биты памяти. (Типы long и float могут 
занимать одинаковое количество бит памяти, но транслируются в числовые 
значения по-разному.)
• Определяет, какие операции, или методы, могут быть применены с 
использованием этого объекта данных.
 Когда вы определяете пользовательский тип в C++, то должны предоставить 
информацию об операциях над ним самостоятельно.
	Классы — это типы, определяемые пользователем и реализующие абстрактный, 
интерфейс, а объект — экземпляр класса. Это значит, что объект является переменной 
этого типа или эквивалентом переменной, такой как выделенный операцией new.
Класс — предназначен для трансляции абстракций в пользовательские типы.
Он комбинирует представление данных и методов для манипулирования 
этими данными в пределах одного аккуратного пакета.
	Спецификация класса состоит из двух частей:
• Объявление класса, описывающее компоненты данных в терминах членов 
данных, а также открытый интерфейс в терминах функций-членов, называемых
методами.
• Определения методов класса, которые описывают, как реализованы определенные
функции-члены.
	Интерфейс программы управляет преобразованием ваших намерений в специфическую
информацию, сохраняемую в компьютере. В отношении классов мы говорим об открытом
интерфейсе. В этом случае потребителем его является программа, использующая класс,
система взаимодействия состоит из объектов класса, а интерфейс состоит из методов, 
предоставленных тем, кто написал этот класс. Интерфейс позволяет вам, как программисту,
написать код, взаимодействующий с объектами класса, и таким образом, дает программе
возможность взаимодействовать с объектами класса.
Например, чтобы определить количество символов в объекте string, вам не нужно открывать 
этот объект и смотреть что у него внутри. Вы просто используете метод size() класса, 
предоставленный его разработчиком. Таким образом, метод size() является частью открытого 
интерфейса между пользователем и объектом класса string. Аналогичным образом метод
getline() является частью открытого интерфейса класса istream. Программа, использующая
сіn, не обращается напрямую к внутренностям объекта сіn для чтения строки ввода; 
вместо этого всю работу выполняет getline(). */
// Пример:
// stock00.h -- Stock class interface
#ifndef STOCK00_H_
#define STOCK00_H_

#include <string>  
class Stock 	// Данный синтаксис идентифицирует Stock
{				// в качестве имени типа для нового класса.
				// Это позволяет объявлять переменные, которые 
				// называются объектами или экземплярами типа Stock.
private: //  Инкапсуляция - сокрытие данных. Доступ к членам объекта из раздела private программа
    //  может получить только через открытые функции-члены из раздела public (или через дружественные функции).
    std::string company; // член класса Stock, хранит название компании
    long shares;		 // член класса Stock.. содержит количество долей общего пакета акций компании
    double share_val;	 // соответствует объему каждой доли
    double total_val;	 // общий объем всех долей
    void set_tot() { total_val = shares * share_val; } // встроенная функция-член класса Stock определена 
	// на месте и поскольку эта функция представляет собой просто реализацию внутреннего кода,
    // а не является частью открытого интерфейса, в классе она объявлена как закрытая функция-член.
	// (То есть set_tot) представляет собой функцию-член, которая используется разработчиком класса, 
	// но не теми, кто пишет код, использующий класс.) 
public:     // Любая программа, которая использует объект определенного класса,
    // может иметь непосредственный доступ к членам из раздела public (абстракцию).
    void acquire(const std::string & co, long n, double pr); // прототип функции-члена, определится в программе
    void buy(long num, double price);
    void sell(long num, double price);
    void update(double price);
    void show();
};	// обратите внимание на точку с запятой в конце.
/*	Связывание данных и методов в единое целое — наиболее замечательное
свойство класса. При таком проектном решении создание объекта типа Stock 
автоматически устанавливает правила, регулирующие его использование.
	Прототипы функций в определении класса Stock демонстрируют 
установку функций-членов.
	Управление доступом.
	Открытые функции-члены public действуют в качестве посредников между 
программой и закрытыми членами private объекта; они предоставляют
интерфейс между объектом и программой. Эта изоляция данных от прямого доступа
со стороны программы называется сокрытием данных. (В C++ имеется третье 
ключевое слово для управления доступом — protected, которое объясняется при 
обсуждении наследовании в главе 13).
	Проектное решение класса пытается отделить открытый интерфейс от специфики
реализации. Открытый интерфейс представляет абстрактный компонент проектного
решения. Собрание деталей реализации в одном месте и отделение их от абстракции
называется инкапсуляцией. Сокрытие данных (помещение данных в раздел private
класса) является примером инкапсуляции, и поэтому оно скрывает функциональные
детали реализации в разделе private, как это сделано в классе Stock с функцией
set_tot(). Другим примером инкапсуляции может служить обычная практика 
помещения определений функций класса в файл, отдельный от объявления класса.
	• Размещение прототипов функций в едином объявлении класса вместо того, чтобы 
держать их раздельно, унифицирует описание за счет размещения его в одном месте.
	• Объявление данных с закрытым доступом разрешает доступ к ним только для
авторизованных функций.
	Поскольку одним из главных принципов ООП является сокрытие данных, то единицы
данных обычно размещаются в разделе private. Функции-члены, которые образуют
интерфейс класса, размещаются в разделе public; в противном случае вызвать эти
функции из программы не удастся. 
	Использовать ключевое слово private в объявлении класса не обязательно, 
поскольку это спецификатор доступа к объектам класса по умолчанию: */
class World
{
	float mass;		// по умолчанию private
	char name[20];	// по умолчанию private
public:
	void tellall(void);
	...
}
/*	Разница между структурами и классами состоит в том, что типом доступа по 
умолчанию у структур является public, в то время как у классов — private. 
Программисты на C++ обычно используют классы для реализации описаний классов, 
тогда как ограниченные структуры применяются для чистых объектов данных 
(которые часто называются простыми старыми структурами данных (plain-old data — POD)).
	Реализация функций-членов класса.
	• При определении функции-члена для идентификации класса, которому 
принадлежит функция, используется операция разрешения контекста (::).
	• Методы класса имеют доступ к private-компонентам класса.
	Операция разрешения контекста идентифицирует класс, к 
которому данный метод относится. */
void Stock::update(double price)
//	Такое же имя можно использовать для функций-членов другого класса.
void Button::update(double price)
/*	Идентификатор update() имеет область видимости класса. Другие функции-члены 
класса Stock могут при необходимости использовать метод update() без операции 
разрешения контекста. Это связано с тем, что они принадлежат одному классу, и, 
следовательно, имеют общую область видимости.
	Единственный способ однозначного разрешения имен методов — использовать
полное имя, включающее имя класса. Stock::update() называется уточненным именем
функции. Простое имя update(), с другой стороны, является сокращением 
(не уточненным именем) полного имени и может применяться только в контексте класса.
	Специальной характеристикой методов является то, что метод может
иметь доступ к закрытым членам класса: */
cout << "Company: " << company 
	 << " Shares: "  << shares << endl;
	 << " Share Price: $" << share_val
	 << " Total Worth: $" << total_val << endl;
/*	Здесь company, shares и т.д. являются закрытыми данными-членами класса Stock.
	Встроенные методы.
	Любая функция с определением внутри объявления класса автоматически 
становится встроенной (inline). Stock::settot() является встроенной функцией.
	Можно определить функцию-член вне объявления класса и, тем не
менее, сделать ее встроенной. Чтобы это сделать, просто используйте квалификатор
inline при определении функции в разделе реализации класса: */
class Stock
{
private:
	void set_tot(); // определение оставлено отдельным
	...
public:
	...
};
  
inline void Stock::set_tot() // использование inline в определении
{
  total_val = shares * hare_val;
}
/* Правила для встроенных функций требуют, чтобы они были 
определены в каждом файле, в котором используются. Проще поместить эти определения 
в тот же заголовочный файл, где объявлен класс. Согласно правилу перезаписи, 
определение метода внутри объявления класса эквивалентно замене определения метода 
прототипом и последующей перезаписью определения в виде встроенной функции 
немедленно после объявления класса. 
	Объявление переменных класса: */
	Stock kate, joe; // создает два объекта класса Stock.
	kate.show(); 	 // объект kate вызывает функцию-член
	joe.show(); 	 // объект joe вызывает функцию-член
/* Это значит, что метод интерпретирует shares как kate.shares, a share_val —
как kate.share_val. В этом случае kate.shares занимает один фрагмент
памяти, a joe.shares — другой. Но kate.show() и joe.show() представляют собой
один и тот же метод, т.е. оба выполняют один и тот же блок кода, только применяют
этот код к разным данным. Вызов функции-члена — это то, что в некоторых объектно-
ориентированных языках называется отправкой сообщния. Таким образом, отправка
сообщения двум разным объектам вызывает один и тот же метод, который 
применяется к двум разным объектам.
	Когда вы вызываете функцию-член, она использует данные-члены конкретного
объекта, примененного для ее вызова.
	Создавать объект класса можно за счет объявления переменной этого класса либо 
использования операция new для размещения в памяти объекта этого класса. Объекты 
можно передавать в аргументах, возвращать их из функций, присваивать один объект другому.
	Важнейшим моментом для использования нового типа является понимание того, что 
делают функции-члены; Вы недолжны задумываться о деталях реализации.
	Клиент-серверная модель:
	Клиентом является программа, которая использует класс. Объявление класса, включая 
его методы, образует сервер, который является ресурсом, доступным нуждающейся в нем 
программе. Клиент взаимодействует с сервером только через открытый (public) интерфейс. 
Это означает, что единственной ответственностью клиента и, как следствие — программиста, 
является знание интерфейса. Ответственностью сервера и, как следствие — его 
разработчика, является обеспечение того, чтобы его реализация надежно и точно 
соответствовала интерфейсу. Любые изменения, вносимые разработчиком сервера в класс, 
должны касаться деталей реализации, но не интерфейса. Это позволяет программистам 
разрабатывать клиент и сервер независимо друг от друга.
	Типичное объявление класса имеет следующую форму: */
class имяКласса
	{
	private:
		объявления данных-членов
	public:
		прототипы функций-членов
	};
/*	Содержимое открытого раздела включает абстрактную часть проектного 
решения — открытый интерфейс. Инкапсуляция данных в закрытом разделе защищает их
целостность и называется сокрытием данных. Использование классов — это способ, 
для облегчения реализации абстракций, сокрытия данных и инкапсуляции ООП.
Спецификации класса — это реализация функций-членов класса.
 Класс Bozo имеет функцию-член Retort(), которая 
возвращает указатель на тип char: */
char * Bozo::Retort();
/*	Retort() — не только функция типа char *, это функция типа
char *, принадлежащая классу Bozo. Полное, или уточненное, имя функции будет 
выглядеть как Bozo::Retort(). Retort имеет область видимости класса, поэтому 
необходима операция разрешения контекста для уточнения имени, когда оно встречается 
вне объявления и вне методов класса. Для создания объекта, который является частным 
примером класса, применяется имя класса, как если бы оно было именем типа: */
Bozo bozetta;
/* Это работает потому, что класс является типом, определенным пользователем.
Функция-член класса, или метод, вызывается с использованием объекта класса. Это
делается с помощью операции членства (точки): */
cout << bozetta.Retort();
/*	Конструкторы и деструкторы классов
	В общем случае лучше, чтобы все объекты инициализировались при их создании.
Конструкторы класса предназначены для создания новых объектов и присваивания 
значений их членам-данным. Конструктор класса имеет то же имя, что и класс, но 
благодаря возможностям перегрузки функций, существует возможность создавать более 
одного конструктора с одним и тем же именем и разным набором аргументов. Имя метода 
конструктора совпадает с именем класса. Например, возможный конструктор для класса 
Stock — это функция-член Stock(). Конструкторы не имеют возвращаемого значения, 
они не объявляются с типом void и не имеют объявленного типа. инициализация должна
соответствовать списку аргументов конструктора. 
	Объявление и определение конструкторов.
Прототип конструктора с несколькими аргументами по умолчанию: */
Stock (const string & со, long n = 0, double pr = 0.0) ;
/* Тип возвращаемого значения не указан. Прототип размещен в открытом разделе 
объявления класса.
// Определение конструктора: */
Stock::Stock(const string & со, long n, double pr)
{
	company = со;
	if (n < 0)
	{
		std::cerr << "Number of shares can't be negative; "
				  << company << " shares set to 0.\n";
		shares = 0;
	}
	else
		shares = n;
	share_val = pr;
	set_tot();
}
/* В данном случае программа автоматически вызовет конструктор при объявлении объекта.
Так поступать нельзя! */
Stock::Stock(const string & company, long shares, double share_val){...}
/* Аргументы конструктора не являются переменными-членами; они представляют значения, 
которые присваиваются членам класса. Таким образом, они должны иметь отличающиеся имена.
Одним из часто используемых способов, призванных помочь избежать этого, является 
использование префикса т_ для идентификации данных-членов: */
class Stock
{
private:
	string m_company;
	long m_chares;
/* Другой также часто применяемый способ заключается в применении суффикса в виде 
подчеркивания для имен членов: */
class Stock
{
private:
string company_;
long shares_;
/* Воспользовавшись одним из соглашений, в качестве имен параметров в открытом 
интерфейсе можно использовать company и shares.
	Использование конструкторов.
	Два способа инициализации объектов с помощью конструктора.
Первый — вызвать конструктор явно: */
Stock food = Stock ("World Cabbage", 250, 1.25);
/* Это устанавливает значение члена company объекта food равным строке "World 
Cabbage", значение shares равным 250 и т.д.
Второй способ — вызвать конструктор неявно: */
Stock garment("Furry Mason", 50, 2.5);
// Эта более компактная форма эквивалентна следующему явному вызову:
Stock garment = Stock("Furry Mason", 50, 2.5);
/*	Как использовать конструктор вместе с new:
	C++ использует конструктор класса, когда вы создаете объект класса,
даже если применяется операция new для динамического выделения памяти.*/
Stock *pstock = new Stock("Electroshock Games",18,19.0);
/* Оператор, создающий объект Stock, инициализирует его значениями, 
переданными в аргументах, и присваивает адрес нового объекта указателю pstock. В этом 
случае объект не имеет имени, но для управления объектом можно применять указатель.
Конструкторы используются способом, отличным от всех остальных методов 
класса. Обычно объект применяется для вызова метода: */
stock1.show(); // объект stock вызывает метод show()
/* Однако нельзя использовать объект для вызова конструктора, поскольку до тех
пор, пока конструктор не завершит создание объекта, его не существует. Вместо того
чтобы вызываться объектом, конструктор служит для создания объекта.
	Конструкторы по умолчанию.
	Конструктор по умолчанию — это конструктор, который используется для создания
объекта, когда не предоставлены явные инициализирующие значения. */
Stock fluffy_the_cat; // используется конструктор по умолчанию
/* Если вы забудете о написании конструкторов, то C++ автоматически создаст 
конструктор по умолчанию. Это — неявная версия конструктора по умолчанию, 
который ничего не делает. Для класса Stock конструктор по умолчанию будет таким: */
Stock::Stock() { }
/* В результате создается объект fluffy_the_cat с инициализированными членами,
как в следующем операторе создается х без указания его значения: */
int x;
// Если вы предоставите конструктор не по умолчанию вроде:
Stock (const string & со, long n, double pr)
/* но не предложите собственную версию конструктора по умолчанию, то 
следующее объявление вызовет ошибку: */
Stock stock1; // невозможно с существующим конструктором
/* Конструктор по умолчанию можно создать двумя способами. Один из них предусматривает 
указание значений по умолчанию для всех аргументов в существующем конструкторе: */
Stock (const string & со = "Error", long n = 0, double pr = 0.0)
/* Второй способ — использование возможности перегрузки функций для 
определения второго конструктора без аргументов: */
Stock();
// Допускается наличие только одного конструктора по умолчанию.
Stock::Stock()	// конструктор по умолчанию
{
	company = "no name";
	shares = 0;
	share_val = 0.0;
	total_val = 0.0;
}
/* При проектировании класса обычно должен быть предусмотрен конструктор по 
умолчанию, который неявно инициализирует все переменные-члены класса. 
 После создания конструктора по умолчанию любым из двух способов  
можно объявлять объектные переменные без явной инициализации: */
Stock first;				// вызывает конструктор по умолчанию неявно
Stock first = Stock();		// вызывает конструктор по умолчанию явно
Stock *prelief = new Stock; // вызывает конструктор по умолчанию неявно
// Вас не должна сбивать с толку неявная форма конструктора не по умолчанию:
Stock first("Concrete Conglomerate"); // вызывает конструктор, не по умолчанию
Stock second();	// объявляет функцию, возвращающую объект Stock
Stock third;	// вызывает конструктор по умолчанию не явно.
/* Первое объявление из приведенных выше вызывает конструктор не по 
умолчанию — т.е. такой, который принимает аргументы. Второе объявление устанавливает,
что second() — это функция, возвращающая объект Stock. При неявном вызове 
конструктора по умолчанию круглые скобки указываться не должны.
	Деструкторы.
	В момент исчезновения конструктора программа автоматически вызывает специальную 
функцию-член деструктор. Конструктор класса Stock не делает никаких действий наподобие 
вызова new, поэтому деструктору класса Stock делать нечего. В таком случае можно просто 
позволить компилятору сгенерировать неявный деструктор, который ничего не делает.
	Деструктор имеет специальное имя. Оно формируется из имени класса и предваряющего 
его символа тильды (~). То есть деструктор для класса Stock называется ~Stock(). 
Подобно конструктору, деструктор не имеет ни возвращаемого значения, ни объявляемого типа. 
Но в отличие от конструктора, деструктор не должен иметь аргументы. */
Stock::~Stock()
{
}
/* Если вы создаете статический объект класса, то его деструктор вызывается
автоматически при завершении работы программы. Если вы создаете автоматический
(локальный) объект класса, как в приведенном примере, то его деструктор 
вызывается автоматически, когда выполнение программы покидает блок кода, в котором 
определен объект. Если объект создается с использованием операции new, он размещается
в свободной памяти, и его деструктор вызывается автоматически, когда вызывается
delete для ее освобождения. Если вы не предусмотрите деструктор, компилятор 
неявно создаст конструктор по умолчанию и, если обнаружит код, который ведет к 
уничтожению объекта, также неявно создаст деструктор.
	Срок существования автоматических переменных, таких как stock1 и stock2, истекает, 
когда выполнение программы покидает блок, содержащий их определения. Без этих 
дополнительных фигурных скобок таким блоком являлось бы тело функции main(), поэтому 
деструкторы не были бы вызваны вплоть до полного завершения main(). В оконной среде 
это означает, что окно программы закроется перед вызовом двух деструкторов, и увидеть 
два последних сообщения не удастся. Но благодаря скобкам, два последних вызова 
деструкторов произойдут перед достижением оператора return, так что сообщения смогут 
отобразиться. */
Stock stock1("NanoSmart", 12, 20.0); /* создает объект Stock по имени stock1 и 
инициализирует его данные-члены указанными значениями.
	Фундаментальная разница между следующими двумя операторами: */
Stock stock2 = Stock ("Boffo Objects", 2, 2.0); /* Первый оператор вызывает инициализацию; 
он создает объект с указанным значением, и может создавать либо не создавать временный 
объект. Если компилятор использует вариант вызова конструктора для создания 
временного объекта, который затем копируется в stock2, то для временного объекта
вызывается деструктор. */
stock1 = Stock("Nifty Foods", 10, 50.0); /* Второй оператор вызывает присваивание. 
Использование конструктора в операции присваивания в таком виде всегда служит причиной 
создания временного объекта перед выполнением собственно присваивания. Затем программа 
уничтожает временный объект, вызывая его деструктор.
Но лучше, если возможно, выбирайте вариант инициализации. Обычно это более эффективно. */
stock2 = stock1; // Присваивание stock1 объекту stock2
/* В случае присваивания одного объекта другому объекту того же класса по умолчанию C++
копирует содержимое каждого члена данных исходного объекта в соответствующий член
данных другого объекта.
	Когда функция main() завершает работу, ее локальные переменные (stock1 и
stock2) перестают существовать. Поскольку такие автоматические переменные 
размещаются в стеке, последний созданный объект удаляется первым, а первый 
созданный — последним.
	В C++11 можно использовать синтаксис списковой инициализации для классов.
Для этого потребуется предоставить в фигурных скобках содержимое, 
соответствующее списку аргументов конструктора: */
Stock hot_tip = {"Derivatives Plus Plus", 100, 45.0};
Stock jock {"Sport Age Storage, Inc"};
Stock temp {};
/* В случае объекта jock для второго и третьего аргументов будут применяться значения
по умолчанию — 0 и 0.0. Третье объявление соответствует конструктору по умолчанию.
 С++11 предлагает класс по имени std::initializer_list, который может использоваться 
в качестве типа для параметра функции или метода. Этот класс представляет список 
произвольной длины, все элементы которого имеют один и тот же тип или могут быть 
преобразованы к одному и тому же типу.
	Функции-члены const: */
const Stock land = Stock("Kludgehorn Properties");
land.show();	// не работает
/* show() не гарантирует того, что он не изменит объект, который из-за объявления 
как const меняться не должен. В методе show() нет аргументов, которые можно было 
бы квалифицировать как const. Вместо них используемый объект неявно задан вызовом 
этого метода. Объявление метода show() должно выглядеть следующим образом: */
void show() const; // обещает не изменять вызываемый объект
// Начало определения функции должно выглядеть так:
void Stock::show() const /* обещает не изменять вызываемый объект, называются
константной функцией-членом. */
Bozo(const char *fname, const char *lname); // прототип конструктора
Bozo bozetta = Bozo("Bozetta", "Biggens"); 	// основная форма
Bozo fufu("Fufu", "O'Dweeb"); 				// сокращенная форма
Bozo *pc = new Bozo("Popo", "Le Peu"); 		// динамический объект
// В С++11 можно взамен применять списковую инициализацию:
Bozo bozetta = {"Bozetta", "Biggens"};	// C++11
Bozo fufu{"Fufu", "O'Dweeb"};			// C++11
Bozo *pc = new Bozo{"Popo", "Le Peu"};	// C++11
/* Когда конструктор имеет только один аргумент, он вызывается в случае 
инициализации объекта значением, которое имеет тот же тип, что и аргумент 
конструктора. */
Bozo(int age);			 // прототип конструктора
// Тогда можно использовать любую из следующих форм инициализации объекта:
Bozo dribble = Bozo(44); // первичная форма
Bozo roon(66);			 // вторичная форма
Bozo tubby = 32;		 // специальная форма для конструктора с одним аргументом
/* Третий пример является новым, он может привести к неприятным сюрпризам.
Конструктор, который принимает один аргумент, позволяет использовать синтаксис 
присваивания для инициализации объекта значением: */
имяКласса объект = значение; /* Эта возможность может привести к возникновению 
проблем, но ее можно заблокировать.
	Конструктор по умолчанию может либо не иметь аргументов, либо предусматривать 
значения по умолчанию для всех аргументов: */
Bozo();		// прототип конструктора по умолчанию
Bistro(const char *s = "Chez Zero"); // значение по умолчанию для класса Bistro
// Программа использует конструкторы по умолчанию для неинициализированных объектов:
Bozo bibi; 			 // используется конструктор по умолчанию
Bozo *pb = new Bozo; // используется конструктор по умолчанию
~Bozo();	// деструктор класса
/* Деструкторы классов, в которых используется операция delete, становятся 
необходимыми, когда в конструкторах классов применяется операция new.
	Указатель this.
Поскольку программа не имеет прямого доступа к total_val, не сможет дать ответ 
на вопрос, какая из ваших долей обладает наибольшим пакетом акций.
Надо предусмотреть методы, возвращающие эти данные: */
class Stock
{
private:
	double total_val;
	void set_tot() { total_val = shares * share_val; }	// встроенная функция-член 
	...													// класса Stock
public:
	double total() const { return total_val; }	// делает total_val доступным в 
};												// программе только для чтения.
/* Можно воспользоваться другим подходом с указателем this. Подход заключается 
в определении функции-члена, которая будет просматривать два объекта Stock и 
возвращать ссылку на больший из них. */
const Stock & topval(const Stock & s) const;
/* Слово const внутри скобок указывает, что функция не будет модифицировать 
объект, к которому получает явный доступ, а слово const, которое следует за 
скобками, устанавливает, что функция не будет изменять объект, на который 
ссылается неявно. Поскольку функция возвращает ссылку на один из const-объектов, 
тип ее возврата также является ссылкой const.
 Для сравнения двух объектов Stock — stock1 и stock2 — и присвоения объекту top 
того из них, который имеет большее значение total_val, можно воспользоваться 
любым из следующих двух операторов: */
top = stock1.topval(stock2); // Обращается к stock1 неявно, a к stock2 - явно, 
							 // поскольку объект this передается в виде аргумента.
top = stock2.topval(stock1); // Доступ неявный, поскольку объект this вызывает 
							 // функцию-член класса.
/* В обоих случаях метод сравнивает два объекта и возвращает ссылку на тот, 
который имеет большее значение total_val. */
const Stock & Stock::topval(const Stock & s) const
{
	if (s.total_val > total_val)
		return s;	 // объект-аргумент
	else
		return ????; // вызывающий объект
}
/* Здесь s.total_val — это суммарное значение объекта, переданное в виде 
аргумента, a total_val — суммарное значение объекта, которому сообщение передается. 
Если s.total_val больше total_val, то функция возвращает s. В противном случае она
возвратит объект, использованный для вызова метода (объект, которому передано 
сообщение topval). Проблема: псевдонима для stock1 не существует.
Решение: в применении специального указателя this. Он указывает на объект, который 
использован для вызова функции-члена (обычно this передается методу в виде скрытого 
аргумента). Таким образом, вызов stock1.topval(stock2) устанавливает значение this 
равным адресу объекта stock1 и делает его доступным методу topval(). Аналогичным 
образом, вызов функции stock2.topval(stock1) устанавливает значение this равным 
адресу объекта stock2. Фактически total_val внутри total() является сокращенной 
нотацией this->total_val. Каждая функция-член, включая конструкторы и деструкторы, 
имеет указатель this. Если метод нуждается в получении ссылки на вызвавший объект 
в целом, он может использовать и выражение *this. Чтобы вернуть сам объект из метода, 
нужно примененить операцию разыменования * к указателю *this, тогда операция даст 
значение, на которое указатель указывает: */
return *this; // вызывающий объект - псевдоним второго объекта
/* Тот факт, что возвращаемое значение представляет собой ссылку, означает, что
возвращаемый объект является тем же самым объектом, который вызвал данный 
метод, а не копией, переданной механизмом возврата.
	Массив объектов. */
Stock mystuff[4];		// создание массива из 4 объектов Stock
mystuff[0].update();	// применяет updateO к первому элементу
mystuff[3].show();		// применяет show() к 4-му элементу
const Stock *tops = mystuff[2].topval(mystuff[1]); // сравнивает 2-й и 3-й элементы и 
// устанавливает tops в указатель на тот из них, у которого больше значение total_val
/* Для инициализации элементов массива можно использовать конструктор. В этом
случае необходимо вызывать конструктор для каждого индивидуального элемента: */
const int STKS = 4;
Stock stocks[STKS] =
{
	Stock("NanoSmart", 12.5, 20),
	Stock("Boffo Objects", 200, 2.0),
	Stock("Monolithic Obelisks", 130, 3.25),
	Stock("Fleep Enterprises", 60, 6.5)
}; /* т.к. применяется стандартная форма инициализации массива:
каждое значение представлено вызовом метода конструктора.
 Если класс имеет более одного конструктора, для разных элементов можно использовать 
разные конструкторы: */
const int STKS = 10;
Stock stocks[STKS] =
{
	Stock("NanoSmart", 12.5, 20),
	Stock(),
	Stock("Monolithic Obelisks", 130, 3.25)
}; // оставшиеся семь членов инициализируются конструктором по умолчанию.
// Преобразование программы на C++:
void Stock::show() const
{
	cout << "Company: " << company
		 << " Shares: " << shares << '\n'
		 << " Share Price: $" << share_val
		 << " Total Worth: $" << total_val << '\n';
}
// в программу на СИ:
void show(const Stock *this)
{
	cout << "Company: " << this->company
		 << " Shares: "	<< this->shares « '\n'
		 << " Share Price: $" << this->share_val
		 << " Total Worth: $" << this->total_val << '\n';
} /* To есть квалификатор Stock:: преобразуется в аргумент функции, который 
представляет собой указатель на Stock, после чего этот указатель используется 
для доступа к членам класса. Аналогичным образом преобразуются вызовы функций: */
top.show ();
// в такой вид:
show(&top);
// В той же манере указателю this присваивается адрес вызывающего объекта.

/*	Область видимости класса.
Данные-члены и функции-члены класса - Сущности, имеющие область видимости класса, 
известны внутри класса, но не известны за его пределами. Одни и те же имена 
членов класса можно без конфликтов использовать в разных классах. Нельзя 
непосредственно обращаться к членам класса из внешнего мира. */
Stock sleeper("Exclusive Ore", 100, 0.25); // создание объекта
sleeper.show(); // использование объекта для вызова функции-члена
show();			// неверно — вызывать метод напрямую нельзя
// При определении функций-членов должна применяться операция разрешения контекста:
void Stock::update(double price)
{
	...
}
/* В пределах объявления класса или определения функции-члена можно использовать 
неуточненные (короткие) имена членов. Имя конструктора распознается при вызове 
потому, что оно совпадает с именем класса. */
class Ik
{
private:
	int fuss;	// fuss имеет область видимости класса
public:
	Ik (int f = 9) { fuss = f; } // fuss находится в области видимости
	void ViewIk() const;	// ViewIk имеет область видимости класса
};
void Ik::ViewIk() const		// Ik:: помещает Viewlk в область видимости Ik
{
	cout << fuss << endl;	// fuss находится в области видимости внутри метода класса
}
...
int main()
{
	Ik *pik = new Ik;
	Ik ее = Ik(8);	 // конструктор находится в области видимости, т.к. имеет имя класса
	ee.ViewIk(); 	 // объект класса переносит Viewlk в область видимости
	pik->ViewIk();	 // указатель на Ik переносит Viewlk в область видимости
...
/* Константы с областью видимости класса. */
class Bakery
{
private:
	const int Months =12; // объявление константы НЕ УДАСТСЯ
	double costs[Months];
...
/* Объявление класса описывает, как выглядит объект, но не создает объекта. 
Пока не создан объект, хранить это значение негде.
 Первый способ — объявить внутри класса перечисление: */
class Bakery
{
private:
	enum {Months = 12}; // не создает переменную-член класса, 
						// Months становится символическим именем.
	double costs[Months];
...
/* Кстати класс ios_base в разделе public объявляет идентификаторы вроде 
ios_base::fixed. Здесь fixed — обычно перечисление, определенное в классе iosbase.
 Второй способ определения константы в классе — с использованием ключевого 
слова static: */
class Bakery
{
private:
	static const int Months = 12; // создает одиночную константу па имени Months,
	// хранящуюся вместе с остальными статическими переменными, а не в каждом объекте
	double costs[Months];
	...
// Перечисления с областью видимости (С++11).
enum egg {Small, Medium, Large, Jumbo};		 // вместе работать
enum t_shirt {Small, Medium, Large, Xlarge}; /* не будет, потому что члены по имени 
Small в перечислениях egg и t_shirt будут находиться в одной и той же области 
видимости, вызывая конфликт имен. За счет указания для перечислителей области 
видимости класса, позволяет работать: */
enum class egg {Small, Medium, Large, Jumbo}; // вместо class можно использовать struct
enum struct t_shirt {Small, Medium, Large, Xlarge};
// Теперь понадобится указывать имя enum для уточнения перечислителя:
egg choice = egg::Large;		// перечислитель Large из перечисления egg
t_shirt Floyd = t_shirt::Large; // перечислитель Large из перечисления t_shirt
/* За счет наличия области видимости класса, перечислители из разных определений
enum больше не имеют потенциальных конфликтов имен. Перечисления с областью видимости 
не поддерживают неявных преобразований в целочисленные типы: */
enum egg_old {Small, Medium, Large, Jumbo};			// без области видимости
enum class t_shirt {Small, Medium, Large, Xlarge};	// с областью видимости
egg_old one = Medium;								// без области видимости
t_shirt rolf = t_shirt::Large;						// с областью видимости
int king = one;		// неявное преобразование для перечисления без области видимости
int ring = rolf;	// не разрешено, неявное преобразование типа не поддерживается
if (king < Jumbo)	// разрешено
	std::cout << "Jumbo converted to int before comparison.\n";
if (king < t_shirt::Medium)	// не разрешено
	std::cout << "Not allowed: < not defined for scoped enum.\n";
// Однако при необходимости можно выполнять явное преобразование типа:
int Frodo = int(t_shirt::Small); // Frodo устанавливается в 0
/* По умолчанию лежащим в основе типом для перечислений с областью видимости C++11
является int. Более того, доступен синтаксис для указания другого лежащего в основе
типа. Лежащим в основе типом для pizza является short: */
enum class : short pizza {Small, Medium, Large, XLarge};
/* Лежащий в основе тип должен быть целочисленным.
	Абстрактные типы данных (ADT).
Стек содержит множество элементов. (Это свойство делает его контейнером —
т.е. еще более общей абстракцией.) Вдобавок стек характеризуется операциями, 
которые на нем можно выполнять:
• создание пустого стека;
• добавление элемента в вершину стека (т.е. заталкивание (push) элемента);
•  удаление элемента из вершины стека (т.е. выталкивание (pop)  элемента);
• проверка, полон ли стек;
• проверка, пуст ли стек.
Это описание может быть сопоставлено с объявлением класса, в котором 
общедоступные функции-члены предоставляют интерфейс, реализующий операции над
стеком. Закрытые данные-члены будут обеспечивать хранение информации в стеке. */
// stack.h -- определение класса для абстрактного типа данных — стека:
#ifndef STACK_H_
#define STACK_H_
typedef unsigned long Item;
class Stack
{
private:
	enum {MAX = 10};	// константа, специфичная для класса
	Item items[MAX];	// создать стек для хранения элементов типа unsigned long
	int top;			// индекс вершины стека
public:
	Stack();
	bool isempty() const;
	bool isfull() const;
// push() возвращает false, если стек полон, и true - в противном случае
	bool push(const Item & item); // добавляет элемент в стек
// pop() возвращает false, если стек пуст, и true - в противном случае
	bool pop(Item & item);	// выталкивает элемент с вершины стека
};
#endif
/* Раздел private показывает, что стек реализован с помощью массива, но раздел 
public никак не отражает этот факт. То есть обычный массив можно заменить
динамическим массивом, не меняя интерфейс класса.
 Можно использовать isempty() и isfull() для проверки перед попытками 
модификации стека или с помощью возвращаемых значений push() и pop()
определять, удалась ли соответствующая операция. */
// stack.cpp -- Stack member functions
#include "stack.h"
Stack::Stack()    // создание пустого стека
{
    top = 0;
}
bool Stack::isempty() const
{
    return top == 0;
}
bool Stack::isfull() const
{
    return top == MAX;
}
bool Stack::push(const Item & item) 
{
    if (top < MAX)
    {
        items[top++] = item;
        return true;
    }
    else
        return false;
}
bool Stack::pop(Item & item)
{
    if (top > 0)
    {
        item = items[--top];
        return true;
    }
    else
        return false; 
}
/* Конструктор по умолчанию гарантирует, что все стеки будут создаваться пустыми.
Код функций-членов pop() и push() гарантирует корректное управление вершиной
стека. */
// stacker.cpp -- тестирование класса Stack
#include <iostream>
#include <cctype>  // or ctype.h
#include "stack.h"

unsigned short a;

int main()
{
    using namespace std;
    Stack st;	// создание пустого стека
    char ch;
    unsigned long po;
	// A - добавление заказа, Р - обработка заказа, Q - завершение
    cout << "Please enter \'A\' to add a purchase order,\n"
         << "\'P\' to process a PO, or \'Q\' to quit.\n";
    while (cin >> ch && toupper(ch) != 'Q')
    {
        while (cin.get() != '\n')   
            continue;
        if (!isalpha(ch))
        {
            cout << '\a';
            continue;
        }
        switch(ch)
        {
             case 'A':
             case 'a': cout << "Enter a PO number to add: ";		// запрос номера заказа
                       cin  >> po;
                       if (st.isfull())
                           cout << "stack already full\n";		// стек уже полон
                       else
                           st.push(po);							// заказ втолкнуть
                       break;
             case 'P':
             case 'p': if (st.isempty())
                           cout << "stack already empty\n";		// стек уже пуст
                       else
					   {
                           st.pop(po);
                           cout << "PO #" << po << " popped\n";	// заказ вытолкнут
                       }
                       break;
        }
		cout << "Please enter \'A\' to add a purchase order,\n"
			 << "\'P\' to process a PO, or \'Q\' to quit.\n";
    }
    cout << "Bye\n";
    return 0; 
}
/* 


String * favorite = new String(sayings[choice]);
/* Здесь указатель favorite обеспечивает доступ к безымянному объекту, созданному
операцией new. Этот синтаксис означает инициализацию нового объекта String с 
помощью объекта sayings[choice]. При этом вызывается конструктор копирования,
поскольку тип аргумента для конструктора копирования (const String &) 
соответствует инициализирующему значению (sayings[choice] ).

*/