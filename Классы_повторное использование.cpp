/* Использование членов класса, которые сами представляют собой объекты другого 
класса — называется включением (containment), или композицией (composition), 
или иерархическим представлением (layering). Включение, закрытое (private) 
наследование и защищенное (protected) наследование обычно используются для 
создания отношений содержит - когда вновь создаваемый класс содержит в себе 
объект другого, уже существующего класса. Шаблоны классов — еще один способ 
повторного использования кода.
	Классы с объектами-членами.
  Класс valarray:
 Класс valarray поддерживается заголовочным файлом valaray и предназначен для 
работы с числовыми значениями (или с классами с аналогичными свойствами). Он
поддерживает операции суммирования содержимого массива и поиск максимального
и минимального значений в массиве. Поскольку класс valarray может работать с 
данными различных типов, он определен как шаблонный класс. При объявлении 
объекта на основе шаблона необходимо указать его конкретный тип: */
valarray<int> q_values;					// массив значений int
valarray<double> weights;				// массив значений double
double gpa[5] = {3.1, 3.5, 3.8, 2.9, 3.3};
valarray<double> v1;						// массив элементов double, размер 0
valarray<int> v2(8);						// массив из 8 элементов int
valarray<int> v3(10, 8);					// массив из 8 элементов int, и каждый равен 10
valarray<double> v4(gpa, 4);				// массив из 4 элементов, равных первым 4 элементам массива gpa
/* Можно создать пустой массив нулевого размера, пустой массив заданного размера, 
массив, всем элементам которого присвоены одинаковые значения, и массив, 
инициализированный значениями из обычного массива. Кроме того, в С++11 можно 
применять списки инициализаторов: */
valarray<int> v5 = {20, 32, 17, 9}; // С++11
/* Ниже описаны некоторые методы класса valarray:
• operator[]() — обеспечивает доступ к отдельным элементам;
• size() — возвращает количество элементов;
• sum()  — возвращает сумму значений элементов;
• max()  — возвращает максимальный элемент;
• min()  — возвращает минимальный элемент.
  Проект класса student.
 В классе Student планируется использовать объект string для представления 
имени и объект valarray<double> для хранения набора оценок. Может возникнуть 
желание породить класс Student от этих двух классов. Это было бы примером 
множественного открытого наследования, возможного в C++, но в данном случае 
это неприемлемо. Дело в том, что отношение класса Student с этими классами
не соответствует модели является. Студент — это не имя и не массив оценок. 
Здесь мы имеем дело с отношением содержит (containment). У студента есть имя, 
и у студента есть набор оценок. Обычно для моделирования отношений содержит в 
C++ используется композиция или включение, когда класс содержит члены, 
являющиеся объектами других классов. Например: */
class Student
{
private:
	string name;			 // используется объект string для имени
	valarray<double> scores;	 // используется объект valarray<double> для оценок
	...
}
/* Класс Student содержит реализацию своих объектов-членов, но не наследует их 
интерфейс. Например, объект Student использует для представления имени реализацию 
string, а не char * name или char name[26]. Однако объект Student не может 
изначально использовать функцию string operator+=() для добавления символов.
При открытом наследовании класс наследует интерфейс и, возможно, реализацию(Чистые
виртуальные функции базового класса могут предоставлять интерфейс без реализации.)
Наличие интерфейса характерно для отношения является. А при композиции класс имеет
реализацию без интерфейса. Отсутствие наследования интерфейса характерно для 
отношения содержит.
 То, что объект класса автоматически не получает интерфейс включаемого объекта, 
полезно для отношения содержит. Например, класс string перегружает операцию
+ для конкатенации двух строк, но выполнять конкатенацию двух объектов Student
бессмысленно. Поэтому в данном случае не имеет смысла использовать открытое 
наследование. Правда, часть интерфейса наследуемого класса может пригодиться и в 
новом классе. Например, можно использовать метод operator<() из интерфейса класса
string для сортировки объектов Student по имени. Для этого потребуется определить 
функцию-член Student::operator<(), внутри которой вызывается функция
string::operator<(). */
// studentc.h -- определение класса Student с использованием включения
#ifndef _STUDENT_H_
#define _STUDENT_H_

#include <iostream>
#include <string>   
#include <valarray>
class Student
{   
private:
    typedef std::valarray<double> ArrayDb;
    std::string name;                       // включенный объект
    ArrayDb scores;                         // включенный объект
    // Закрытый метод для вывода оценок
    std::ostream & arr_out(std::ostream & os) const;
public:
// Для объектов-членов в списке инициализаторов членов конструкторы используют имя члена:
    Student() : name("Null Student"), scores() {}
/* Конструктор, который можно вызвать с одним аргументом, работает как функция неявного 
преобразования типа аргумента в тип класса. Такое поведение нежелательно. */
    // Указание ключевого слова explicit отключает неявное преобразование:
    explicit Student(const std::string & s)             : name(s),       scores()      {}
    explicit Student(int n)                             : name("Nully"), scores(n)     {}
    Student(const std::string & s, int n)               : name(s),       scores(n)     {}
    Student(const std::string & s, const ArrayDb & a)   : name(s),       scores(a)     {}
// name(str) и scores(pd, n) вызывают конструкторы:  string(const char *), valarray<double>(const double *, int)
    Student(const char * str, const double * pd, int n) : name(str),     scores(pd, n) {}
    ~Student() {}
    double Average() const;
    const std::string & Name() const;
    double & operator[](int i);
    double   operator[](int i) const;
// Друзья
    // Ввод
    friend std::istream & operator>>(std::istream & is, Student & stu);     // 1 слово
    friend std::istream & getline   (std::istream & is, Student & stu);     // 1 строка
    // Вывод
    friend std::ostream & operator<<(std::ostream & os, const Student & stu);
};
#endif
/*  Инициализация включенных объектов.
Инициализация членов встроенных типов, например: */
Queue::Queue(int qs) : qsize(qs) {...} // инициализация qsize значением qs
/* Для унаследованных объектов конструкторы используют в списке инициализаторов
членов имя класса, чтобы вызвать конкретный конструктор базового класса. Список 
инициализаторов членов для инициализации порции производного объекта, которая 
взята из базового класса, например: */
hasDMA::hasDMA(const hasDMA & hs) : baseDMA(hs) {...}
// Для объектов-членов в списке инициализаторов членов конструкторы используют имя члена:
Student(const char * str, const double * pd, int n) : name(str), scores(pd, n) {}
/* Каждый элемент в списке инициализации вызывает соответствующий конструктор. Так, элемент
name(str) вызывает конструктор string(const char *), а элемент scores(pd, n)
вызывает конструктор ArrayDb (const double *, int), который в силу определения
typedef на самом деле является таким конструктором: */
valarray <double>(const double *, int)
/* В C++ все объекты-члены унаследованных компонентов должны быть созданы до того, 
как будут созданы все остальные объекты. Значит, без списка инициализаторов C++ 
использует конструктор по умолчанию, определенный для классов объектов-членов.
При наличии более одного объекта в списке инициализаторов эти объекты инициализируются 
в том порядке, в котором они объявлены, а не в порядке, в котором они содержатся в 
списке инициализаторов. Например: */
Student(const char * str, const double * pd, int n) : scores(pd, n), name(str) {}
/* Член name будет инициализирован первым, поскольку он объявлен первым в определении
класса. В данном случае точный порядок инициализации не важен, однако он будет 
существенным, если в коде значение одного члена используется в составе выражения для 
инициализации другого члена.
  Использование интерфейса для включенного объекта.
Интерфейс для включенных объектов не является открытым, но его можно 
использовать внутри методов класса. Например, вот как определить функцию, 
возвращающую среднее значение оценок студента: */
double Student::Average()const					// вызов метода Student
{
	if (scores.size() > 0)						// вызов метода valarray
		return scores.sum() / scores.size();		// вызов методов valarray
	else
		return 0;
}
/* Аналогично можно определить дружественную функцию, которая пользуется 
версией операции << из класса string: */
// Использование версии операции << из класса string
ostream & operator<<(ostream & os, const Student & stu)
{
	os << "Scores for " << stu.name << ":\n";
	...
}
/* Поскольку член stu.name является объектом string, он вызывает функцию
operator<<(ostream &, const strings), являющуюся частью пакета класса string.
Функция operator<<(ostream & os, const Student & stu) должна быть дружественной 
классу Student, чтобы иметь доступ к члену name. (Но можно использовать 
открытый метод Name(), а не закрытый член name.) */
const string & Student::Name() const
{
    return name;
}
/* Аналогично в функции можно было бы применять valarray-реализацию операции<< 
для вывода — правда, ее нет. Поэтому для решения данной задачи в классе 
определен закрытый вспомогательный метод: */
ostream & Student::arr_out(ostream & os) const
{
    int i;
    int lim = scores.size();
    if (lim > 0)
    {
        for (i = 0; i < lim; i++)
        {
            os << scores[i] << " ";
            if (i % 5 == 4)
                os << endl;
        }
        if (i % 5 != 0)
            os << endl;
    }
    else
        os << " empty array ";
    return os; 
}
/* Использование такой вспомогательной функции собирает в одном месте разбросанные 
фрагменты кода и делает код дружественной функции более аккуратным: */
ostream & operator<<(ostream & os, const Student & stu)
{
    os << "Scores for " << stu.name << ":\n";
    stu.arr_out(os);			// использование закрытого метода для scores
    return os;
}
// Использует версию getline(ostream &, const string &) из класса string:
istream & getline(istream & is, Student & stu)
{
    getline(is, stu.name);
    return is;
}
/*	Закрытое наследование.
В C++ имеется и другое средство реализации отношений содержит — закрытое 
наследование. При использовании закрытого наследования открытые (public) и 
защищенные (protected) члены базового класса становятся закрытыми членами 
производного класса — т.е. методы базового класса не переходят в открытый 
интерфейс производного объекта. Однако они могут использоваться внутри 
функций-членов производного класса. При закрытом наследовании класс наследует 
реализацию. Например, если базовым классом для класса Student является класс 
string, класс Student будет содержать компонент унаследованного класса string, 
который можно использовать для хранения строк. А методы класса Student могут 
использовать методы класса string для внутреннего доступа к компоненту string.
Включение добавляет в класс именованный объект-член, а закрытое наследование
добавляет в класс неименованный унаследованный объект. Для обозначения объектов, 
добавленных путем наследования или включения, используется термин подобъект.
 Закрытое наследование обеспечивает те же свойства, что и включение —
реализацию, но не интерфейс. Поэтому его также можно использовать для реализации
отношения содержит.
  Новый вариант класса student.
 Для получения закрытого интерфейса при определении класса необходимо 
использовать ключевое слово private вместо public. (private принимается по 
умолчанию, поэтому отсутствие квалификатора доступа также приведет к закрытому 
наследованию.) Класс Student должен наследовать два класса, поэтому в объявлении 
класса Student следует указать их оба: */
class Student : private std::string, private std::valarray<double>
{
public:
	...
};
/* Наследование от нескольких базовых классов называется множественным 
наследованием. В новом классе не нужны собственные закрытые данные, поскольку оба 
наследуемых базовых класса содержат все необходимые данные-члены. Версия 
примера с включением содержит в качестве членов два явно именованных объекта name и 
score, а версия с закрытым наследованием содержит в качестве унаследованных членов два 
неименованных подобъекта std::string(str), std::valarray<double>. Это первое из главных 
отличий между двумя рассматриваемыми подходами.
  Инициализация компонентов базового класса.
 Наличие неявно унаследованных компонентов вместо объектов-членов влияет на кодирование 
этого примера, поскольку для описания объекта уже нельзя использовать идентификаторы 
name и score. Вместо этого придется вернуться к технологии, применяемой при открытом 
наследовании. В новой версии примера для наследуемых классов должен использоваться 
список инициализаторов членов, в котором для указания конструктора вместо имени члена
применяется имя класса: */					// используются имена классов для наследования:
Student(const char * str, const double * pd, int n) : std::string(str), ArrayDb(pd, n) {}
/* ArrayDb — это typedef для std::valarray<double>.
Единственным отличием между включением и закрытым наследованием является отсутствие 
явно указанных имен объектов и применение имен классов вместо имен членов во 
встроенных конструкторах.
  Доступ к методам базового класса.
 Закрытое наследование позволяет использовать методы базового класса только
внутри методов производного класса. Но иногда необходимо обращаться к методам
базового класса извне. Например, объявление класса Student предполагает 
возможность вызова функции Average().*/
double Student::Average() const
{ /* наследование позволяет применять имя класса и операцию разрешения контекста 
	для вызова методов базовых классов: */
    if (std::valarray<double>::size() > 0)
        return std::valarray<double>::sum() / std::valarray<double>::size();
	...
}
Объект Student
	Объект string
		string::size() /* Доступ с областью видимости класса Student через
открытые методы класса string, вызываемые операцией разрешения контекста. */
	Объект valarray<double>
		valarray<double>::sum() /* Доступ с областью видимости класса Student
через открытые методы класса valarray<double>, вызываемые операцией разрешения контекста.
  Доступ к объектам базового класса.
Операция разрешения контекста позволяет обращаться к методам базового класса.
А что если нужен доступ к самому объекту базового класса? Например, в версии класса
Student с включением метод Name() возвращает член name объекта string. Но при
закрытом наследовании у объекта string нет имени. Как же код класса Student 
может обратиться к внутреннему объекту string? Решением служит приведение типов.
Тип Student порожден от string, поэтому объект Student можно привести к типу string.
Вспомните, что указатель this указывает на вызвавший объект. Тогда *this является 
самим вызвавшим объектом, в данном случае — объектом Student. Чтобы не вызывать 
конструкторы для создания новых объектов, необходимо использовать приведение типа 
для создания ссылок: */
const string & Student::Name() const
{
	return (const string &) *this;
} /* Возвращает ссылку на унаследованный объект string, который 
находится в вызывающем объекте Student.
  Доступ к друзьям базового класса.
 Явное указание имени функции с именем ее класса не работает для дружественных
функций, т.к. дружественная функция не принадлежит этому классу. Но для корректного 
вызова функций можно использовать явное приведение типа к базовому классу. В принципе, 
это та же техника, что и при доступе к объектам базового класса в методах класса. Но 
в случае с друзьями доступно имя объекта Student, поэтому вместо *this в коде 
используется имя объекта. Например: */
ostream & operator<<(ostream & os, const Student & stu)
{
	os << "Scores for " << (const string &) stu << ":\n";
    stu.arr_out(os);  // использование закрытого метода для scores
    return os;
}
/*Если plato — объект типа Student, то показанный ниже оператор вызывает эту
функцию, где stu — ссылка на plato, a os — ссылка на cout: */
cout << plato;
// Следующая строка кода:
os << "Scores for " << (const string &) stu << ":\n";
/* Приведение типа явно преобразует stu в ссылку на объект типа string, а этот тип
вызывает функцию operator<<(ostream &, const string &). Ссылка stu не преобразуется 
автоматически в ссылку на string, поскольку при закрытом наследовании ссылке или 
указателю на базовый класс нельзя присвоить ссылку или указатель на производный 
класс без явного приведения типа. Однако даже при открытом наследовании нужно иметь
явные приведения типов. Одна из причин состоит в том, что без приведения код вроде 
показанного ниже соответствует прототипу дружественной функции, что приводит к 
рекурсивному вызову: */
os << stu;
/* Ещё одна причина: поскольку класс использует множественное наследование, 
компилятор не может определить, в какой базовый класс выполнять преобразование, 
т.к. оба базовых класса поддерживают функцию operator<<(). */
// Использует версию operator>>() из класса string
istream & operator>>(istream & is, Student & stu)
{
    is >> (string &)stu;
    return is;
}
/*  Включение или закрытое наследование?
 Включение проще проследить: в определении класса четко видны явно именованные объекты, 
которые представляют содержащиеся классы, и к этим объектам можно обращаться по именам. 
При наследовании же отношение выглядит более абстрактно. Во-вторых, наследование может 
приводить к трудностям, особенно, если класс наследуется от нескольких базовых классов. 
Может случиться так, что разные базовые классы содержат методы с одинаковыми именами,
или у разных базовых классов общий предок. В общем, при использовании включения меньше 
вероятность столкнуться с проблемами. Включение позволяет иметь несколько подобъектов 
с одинаковыми именами. Если в классе нужны три объекта string, то с помощью включения 
можно определить три отдельных члена string. А наследование позволяет иметь только 
один объект — трудно различить объекты, у которых нет имени.
 Однако у закрытого наследования есть возможности, недостижимые при 
включении. Предположим, что класс содержит защищенные члены, которые могут быть
данными или функциями. Такие члены доступны для производных классов, но не для
всего мира. Если включить этот класс в другой класс с помощью композиции, новый
класс будет как раз частью всего мира, а не наследником, и поэтому не будет иметь
доступ к защищенным членам. Но если использовать наследование, то новый класс
будет наследником, а значит, сможет обращаться к защищенным членам.
Еще одна ситуация, в которой удобно закрытое наследование — переопределение
виртуальных функций. Это привилегия производных, а не содержащих классов. При
закрытом наследовании переопределенные функции могут применяться только внутри класса.
 В общем случае для создания отношения содержит нужно использовать включение. Если же
новому классу нужен доступ к защищенным членам базовых классов или требуется 
переопределить виртуальную функцию, необходимо закрытое наследование.
	Защищенное наследование.
 Защищенное наследование —
это разновидность закрытого наследования. В этом
случае при объявлении базового класса указывается ключевое слово protected: */
class Student : protected std::string, protected std::valarray<double>
{...};
/* При защищенном наследовании открытые и защищенные члены базового класса становятся 
защищенными членами производного класса. Как и при закрытом наследовании, интерфейс 
базового класса доступен в производном классе, но не доступен внешнему миру. Главное 
отличие между защищенным и закрытым наследованием проявляется при порождении от класса, 
который сам является производным классом. При закрытом наследовании класс третьего 
поколения не получает доступа к интерфейсу базовых классов. Это происходит потому, 
что открытые методы базового класса становятся закрытыми в производном классе, и 
доступ к закрытым членам и методам из следующего уровня наследования невозможен. 
При защищенном наследовании открытые методы базового класса становятся защищенными 
членами производного класса и доступны внутри классов следующего уровня наследования.
 Выражение неявное восходящее приведение означает, что указатель или ссылка на базовый 
класс может ссылаться на объект производного класса без явного приведения типа.
  Переопределение доступа с помощью using.
 При защищенном или закрытом порождении открытые члены базового класса
становятся защищенными или закрытыми. Предположим, что нужно создать какой-
то метод базового класса, открытый в производном классе. Одна из возможностей —
определить метод производного класса, использующий метод базового класса. Пусть,
например, нужно, чтобы класс Student мог использовать метод sum() из valarray.
Можно объявить в определении класса метод sum(), а затем определить его 
следующим образом: */
double Student::sum() const 				// открытый метод Student
{
	return std::valarray<double>::sum(); // использует закрытый унаследованный метод
} 
/* Тогда объект Student может вызывать метод Student::sum(), который, в свою
очередь, применяет метод valarray<double>::sum() к встроенному объекту valarray.
Вместо упаковки одной функции в другую можно использовать другой способ —
объявление using, согласно которому конкретный метод базового класса может 
использоваться производным классом, даже если наследование является закрытым.
Предположим, что необходимо применять методы min() и max() из класса valarray 
с классом Student. В этом случае в раздел public файла studenti.h можно 
добавить объявление using: */
class Student : private std::string, private std::valarray<double>
{
public:
	using std::valarray<double>::min;
	using std::valarray<double>::max;
};
/* Объявление using делает методы valarray<double>::min() и valarray<double>::max() 
доступными, как будто это открытые методы класса Student: */
cout << "high score: " << ada[i].max() << endl;
/* Обратите внимание, что объявление using использует только имя члена — без
скобок, сигнатуры функции и возвращаемого типа. Например, чтобы сделать метод
operator[]() из valarray доступным в классе Student, нужно поместить в раздел
private определения класса Student такое объявление using: */
using std::valarray<double>::operator[];
/* После этого будут доступны обе версии — с квалификатором const и без него. Затем
можно удалить существующие прототипы и определения для Student::operator[]().
 Объявление using работает только в случае наследования и не работает при технике
включения. Есть более старый способ переопределения методов базового класса в 
классе, порожденном с помощью закрытого наследования — нужно поместить имя метода
в разделе public класса-наследника, например: */
class Student : private std::string, private std::valarray<double>
{
public:
	std::valarray<double>::operator[]; // переопределен как открытый, достаточно указать имя
};
/* Это похоже на объявление using, но без ключевого слова using. Применять 
такой подход не рекомендуется, поскольку он считается устаревшим.
	Множественное наследование.
Множественное наследование описывает класс, у которого есть несколько базовых
классов. Подобно одиночному наследованию, открытое множественное наследование
выражает отношение является. Например, если имеются классы Waiter и Singer, то
от них можно породить класс SingingWaiter: */
class SingingWaiter : public Waiter, public Singer {...};
/* Оба базовых класса должны сопровождаться ключевым словом public,
т.к. по умолчанию компилятор подразумевает закрытое наследование: */
class SingingWaiter : public Waiter, Singer {...}; // Singer считается закрытым базовым классом
/* Множественное наследование может привнести новые проблемы при программировании —
наследование разных методов с одинаковыми именами от разных базовых классов и 
наследование нескольких экземпляров класса от нескольких взаимосвязанных базовых 
классов. Для устранения этих проблем введены новые правила и варианты синтаксиса. 
Таким образом, использование множественного наследования может оказаться более 
сложным и предрасположенным к проблемам, чем одиночное наследование. */
// worker0.h  -- working classes
#ifndef _WORKER0_H_
#define _WORKER0_H_
#include <string>

class Worker                                // работник — абстрактный базовый класс
{
private:
    std::string fullname;
    long id;
public:
    Worker()                                             : fullname("no one"), id(0L) {}
    Worker(const std::string & s, long n)                : fullname(s),        id(n)  {}
    virtual ~Worker() = 0;                  // чистый виртуальный деструктор
    virtual void Set();
    virtual void Show() const;
};
class Waiter : public Worker                // официант
{
private:
    int panache;
public:
    Waiter()                                             : Worker(),       panache(0) {}
    Waiter(const std::string & s, long n, int p = 0)     : Worker(s, n),   panache(p) {}
    Waiter(const Worker & wk, int p = 0)                 : Worker(wk),     panache(p) {}
    void Set();
    void Show() const;
};
class Singer : public Worker                // певец
{
protected: // ряд внутренних констант, представляющих виды голоса:
    enum {other, alto, contralto, soprano, bass, baritone, tenor};
    enum {Vtypes = 7};
private:
    static char * pv[Vtypes];               // строковые эквиваленты видов голоса
    int voice;
public:
    Singer()                                             : Worker(),     voice(other) {}
    Singer(const std::string & s, long n, int v = other) : Worker(s, n),     voice(v) {}
    Singer(const Worker & wk, int v = other)             : Worker(wk),       voice(v) {}
    void Set();
    void Show() const;
};
#endif
/* Объявления классов включают ряд внутренних констант, представляющих виды голоса. 
Перечисление определяет символические константы alto, contralto и т.д., а в статическом 
массиве рѵ хранятся указатели на строковые эквиваленты в стиле С. В файле реализации, 
осуществляется инициализация этого массива и содержатся определения методов. */
// Методы Singer:
char * Singer::pv[] = {"other", "alto", "contralto",    // указатели на строковые эквиваленты в стиле С
            "soprano", "bass", "baritone", "tenor"};
void Singer::Set()
{
    Worker::Set();
    cout << "Enter number for singer's vocal range:\n"; // Ввод номера вокального диапазона певца
    int i;
    for (i = 0; i < Vtypes; i++)
    {
        cout << i << ": " << pv[i] << "   ";
        if ( i % 4 == 3)
            cout << endl;
    }
    if (i % 4 != 0)
        cout   << endl;
    while (cin >>  voice && (voice < 0 || voice >= Vtypes))
        cout   << "Please enter a value >= 0 and < " << Vtypes << endl;
    while (cin.get() != '\n')
        continue;
}
// worktest.cpp -- тестирование иерархии классов сотрудников:
#include <iostream>
#include "worker0.h"
const int LIM = 4;
int main()
{
    Waiter bob("Bob Apple", 314L, 5);
    Singer bev("Beverly Hills", 522L, 3);
    Waiter w_temp;
    Singer s_temp;

    Worker * pw[LIM] = {&bob, &bev, &w_temp, &s_temp};

    int i;
    for (i = 2; i < LIM; i++)
        pw[i]->Set();
    for (i = 0; i < LIM; i++)
    {
        pw[i]->Show();
        std::cout << std::endl;
    }
    return 0;
}
/* Вроде бы все работает: указатели на Waiter вызывают Waiter::Show() и
Waiter::Set(), а указатели на Singer-Singer::Show() и Singer::Set(). Тем не 
менее, трудности возникают, если нужно добавить класс SingingWaiter, порожденный
от двух классов Singer и Waiter.
  Сколько всего сотрудников?
Начнем с открытого наследования SingingWaiter от классов Singer и Waiter: */
class SingingWaiter : public Singer, public Waiter {...};
/* Поскольку и Singer, и Waiter наследуют компонент Worker, то SingingWaiter
будет иметь два компонента Worker: */
class Singer 		: public Worker {...};
class Waiter 		: public Worker {...};
class SingingWaiter : public Singer, public Waiter {...};
// Объект SingingWaiter наследует два объекта Worker:
Объект SingingWaiter
{
	Подобъект Singer
	{
		Подобъект Worker
		{
			fullname
			id
		}
		pv[Vtypes]
		voice
	}
	Подобъект Waiter
	{
		Пoдoбъeкт Worker
		{
			fullname
			id
		}
		panache
	}
}
/* В обычной ситуации указателю на базовый класс можно присвоить адрес объекта 
производного класса, но теперь эта операция неоднозначна: */
SingingWaiter ed;
Worker * pw = &ed;	// неоднозначность
/* Обычно такое присваивание заносит в указатель на базовый класс адрес объекта
базового класса внутри производного объекта. Но ed содержит два объекта Worker,
из которых нужно выбрать один. Конкретный объект можно указать с помощью 
приведения типа: */
Worker * pw1 = (Waiter *) &ed;	// Worker из Waiter
Worker * pw2 = (Singer *) &ed;	// Worker из Singer
/* Это, безусловно, усложняет использование массива указателей на базовый класс
для ссылок на множество объектов (полиморфизм). С введением множественного наследования 
в C++ появились виртуальные базовые классы, делающие такое наследование возможным.
  Виртуальные базовые классы.
 Виртуальные базовые классы позволяют объекту, порожденному от нескольких 
базовых классов, которые сами имеют общий базовый класс, наследовать только один
объект от этого базового класса. Например, можно сделать класс Worker виртуальным
базовым классом для Singer и Waiter, указав в определениях класса ключевое слово
virtual (virtual и public можно использовать в любом порядке): */
class Singer : virtual public Worker {...};
class Waiter : public virtual Worker {...};
// Затем необходимо определить SingingWaiter, как и раньше:
class SingingWaiter: public Singer, public Waiter {...};
/* Теперь объект SingingWaiter будет содержать лишь одну копию объекта Worker,
а производные объекты Singer и Waiter будут иметь один общий базовый объект
Worker вместо двух его копий. Поскольку объект SingingWaiter теперь
содержит один нодобъект Worker, можно снова использовать полиморфизм. */
// Объект SingingWaiter наследует один объект Worker:
Объект SingingWaiter
{
	Подобъект Worker
	{
		fullname
		id
	}
	Подобъект Singer
	{
		pv[Vtypes]
		voice
	}
	Подобъект Waiter
	{
		panache
	}
}
/* В C++ ключевое слово virtual в виртуальных базовых классах используется для 
новой возможности — это "перегрузка" ключевого слова. Почему нельзя обойтись без 
определения базовых классов виртуальными и сделать виртуальное поведение нормой 
для множественного наследования? Во-первых, бывают случаи, когда нужно иметь 
несколько копий базового класса. Во-вторых, если сделать базовые классы виртуальными, 
программа будет выполнять дополнительную работу — а зачем платить за то, что Вам не 
нужно?
 При добавлении класса SingingWaiter в иерархию класса Worker придется вернуться 
назад и добавить ключевое слово virtual в определения классов Singer и Waiter.
  Новые правила для конструкторов.
 При использовании невиртуальных базовых классов в списке инициализации могут 
присутствовать только конструкторы непосредственных базовых классов.
Однако эти конструкторы, в свою очередь, могут передавать информацию своим 
базовым классам. Например, возможна следующая организация конструкторов: */
class A
{
	int а;
public:
	A(int n = 0) : a(n) {}
	...
};
class B : public A
{
	int b;
public:
	B(int m = 0, int n = 0) : A(n), b(m) {}
	...
};
class С : public В
{
	int с;
public:
	С(int q = 0, int m = 0, int n = 0) : В(m, n), c(q) {}
	...
};
/* Конструктор класса С может вызывать только конструкторы класса В, а конструктор 
В может вызывать только конструкторы из класса А. В примере конструктор С 
использует значение q и передает значения тип обратно конструктору В. Конструктор
В использует значение m и передает значение п конструктору А. Но если Worker будет 
виртуальным базовым классом, автоматическая передача информации работать не будет. 
Рассмотрим, следующий конструктор для случая множественного наследования: */
SingingWaiter(const Worker & wk, int p = 0, int v = Singer::other)
			 : Waiter(wk,p), Singer(wk,v) {}		// неверно
/* Проблема в том, что в данном случае wk автоматически передается в объект
Worker двумя разными путями (через Waiter и Singer). Для устранения возможного
конфликта C++ отключает автоматическую передачу информации через промежуточный 
класс в базовый класс, если он виртуальный. Поэтому вышеприведенный конструктор 
инициализирует члены panache и voice, однако аргумент wk не будет передан в 
подобъект Waiter. Однако компилятор должен создать компонент базового объекта
перед созданием производных компонентов — в данном случае он будет использовать
конструктор по умолчанию Worker. Если для создания виртуального базового класса 
нужен конструктор не по умолчанию, придется явно вызывать соответствующий 
базовый конструктор: */
SingingWaiter(const Worker & wk, int p = 0, int v = Singer::other)
			 : Worker(wk), Waiter (wk,p), Singer(wk,v) {}
/* Здесь явно вызывается конструктор Worker (const Worker & ). Такое использование 
допустимо, а зачастую и необходимо, для виртуальных базовых классов, но ошибочно 
для невиртуальных базовых классов. Если у класса есть непрямой виртуальный базовый 
класс, конструктор этого класса должен явно вызывать конструктор виртуального 
базового класса, за исключением случаев, когда достаточно конструктора по умолчанию 
виртуального базового класса.
  Какой метод использовать?
 Рассмотрим задачу расширения метода Show() для класса SingingWaiter. Предположим,
что новой версии Show() нет, и попытаемся использовать объект SingingWaiter для
вызова унаследованного метода Show(): */
SingingWaiter newhire("Elise Hawks", 2005, 6, soprano);
newhire.Show();		// неоднозначность
/* При одиночном наследовании отсутствие переопределения функции Show() 
приводит к использованию самого последнего наследственного определения этой 
функции. Но в данном случае у каждого прямого предка имеется метод Show(), что делает
этот вызов неоднозначным. Множественное наследование может приводить к неоднозначным 
вызовам функций. Для ясности можно применить операцию разрешения контекста: */
SingingWaiter newhire("Elise Hawks", 2005, 6, soprano);
newhire.Singer::Show();		// использование версии Singer
/* Но лучше переопределить в классе SingingWaiter метод Show(), указав, какую
версию Show() следует использовать. Например, если нужно, чтобы SingingWaiter
пользовался версией из Singer, можно сделать так: */
void SingingWaiter::Show()
{
	Singer::Show();
}
/* Такой способ вызова базового метода из производного метода нормально работает 
для одиночного наследования. Предположим, например, что от класса Waiter(Официант) 
порожден класс HeadWaiter(Старший официант). Можно использовать следующую 
последовательность определений, где каждый производный класс добавляет к информации 
базового класса вывод своей дополнительной информации: */
void Worker::Show() const
{
	cout << "Name: " << fullname << "\n";
	cout << "Employee ID: " << id << "\n";
}
void Waiter::Show() const
{
	Worker::Show();
	cout << "Panache rating: " << panache << "\n";
}
void HeadWaiter::Show() const
{
	Waiter::Show();
	cout << "Presence rating: " << presence << "\n";
}
/* Но для SingingWaiter такой способ не сработает. Показанный метод даст сбой,
поскольку он игнорирует компонент Waiter: */
void SingingWaiter::Show()
{
	Singer::Show();
}
// Это можно исправить, вызвав еще и версию из Waiter:
void SingingWaiter::Show()
{
	Singer::Show();
	Waiter::Show();
}
/* Но тогда имя и идентификатор сотрудника будут выведены дважды, т.к. и
Singer::Show(), и Waiter::Show() вызывают Worker::Show(). Как исправить положение?
Один из способов — воспользоваться модульным подходом вместо инкрементного. То 
есть нужно определить метод, выводящий только компоненты Worker, затем метод, 
выводящий только компоненты Waiter (вместо компонентов Waiter плюс Worker), и, 
наконец, метод, выводящий компоненты Singer. Потом необходимо собрать эти 
компоненты вместе в методе SingingWaiter::Show(). */
void Worker::Data() const
{
	cout << "Name: "	<< fullname << "\n";
	cout << "Employee ID: " << id << "\n";
}
void Waiter::Data() const
{
cout << "Panache rating: " << panache << "\n";
}
void Singer::Data() const
{
	cout << "Vocal range: " << pv[voice] << "\n";
}
void SingingWaiter::Data() const
{
	Singer::Data();
	Waiter::Data();
}
void SingingWaiter::Show() const
{
	cout << "Category: singing waiter\n";
	Worker::Data();
	Data();
}
/* Аналогично можно построить и другие методы Show() из соответствующих 
компонентов Data(). При таком подходе объекты по-прежнему вызывают метод Show() 
открытым образом. Но методы Data() должны быть внутренними в классах — т.е. 
вспомогательными методами, обеспечивающими открытый интерфейс. Однако если сделать 
методы Data() закрытыми, то вызов Worker::Data() из кода Waiter будет невозможным.
Это как раз одна из ситуаций, где могут пригодиться защищенные классы. Если 
методы Data() являются защищенными, их можно использовать внутри всех классов
иерархии, но извне они будут недоступны. Другой способ — сделать не закрытыми, 
а защищенными все компоненты данных. Однако использование защищенных методов 
вместо защищенных данных позволяет более точно управлять доступом к данным.
Методы Set(), запрашивающие данные для установки значений объекта, представляют 
похожую проблему. Например, вызов SingingWaiter::Set() должен запрашивать 
информацию для объекта Worker один раз, а не два. Такое же решение необходимо 
и для Show(). Можно определить защищенные методы Get(), которые запрашивают 
информацию только для одного класса, а затем объединить методы Set(), использующие 
методы Get() в качестве строительных блоков. Итак, введение множественного 
наследования с общим предком требует построения виртуальных базовых классов, 
изменения правил для списков инициализации в конструкторах и, возможно, переделки 
классов, если они написаны с учетом множественного наследования.






























