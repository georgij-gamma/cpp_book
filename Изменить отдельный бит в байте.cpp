/* Си: как изменить отдельный бит в байте
Побитовым исключающим или (операция ^) со степенью двойки от номера нужного бита (справа налево, младший бит имеет номер 0) 
Пример на консольном Си:*/

#include <stdio.h>
#include <math.h>

void main() {
 char b = 0xFF; //Байт
 int n = 3; //Номер бита, который нужно изменить - считаем справа налево с 0
 printf("\nБыло: %02X",b);
 b ^= (int)pow(2,n); //Переключение нужного бита - 0 в 1 или 1 в 0
 printf("\nПосле переключения: %02X",b);
 b ^= (int)pow(2,n);
 printf("\nПереключили еще раз: %02X",b);
}

// На самом деле вычислять степени двойки глупо, раз есть побитовый сдвиг, так что окончательно получаем такую версию:
#include <stdio.h>

void main() {
 char b = 0xFF; //Байт
 int n = 3; //Номер бита, который нужно изменить - считаем справа налево с 0
 printf("\nБыло: %02X", b);
 b ^= 1 << n; //Переключение нужного бита - 0 в 1 или 1 в 0
 printf("\nПосле переключения: %02X",b);
 b ^= 1 << n;
 printf("\nПереключили еще раз: %02X",b);
}

// Проверить, установлен ли в байте тот или иной бит:
if (by & 1 << n) { /* Бит с номером n в байте by установлен */ }
else { /* Бит не установлен */ }

by |= 1 << n;	// Принудительно включает бит номер n в байте by
by &= ~(1 << n);	// Принудительно вЫключает бит номер n из байта by

#include <iostream>
#include <bitset>

int main()
{
	using type = unsigned char;
	
    type A{0}, B{0b11010110}, C{0b10010011};
	
	A = (C << 4) | (B & 0x0F);    // присвоить старшей тетраде A младшую тетраду C и младшей тетраде A младшую тетраду B

	std::cout << int(A) << '\n';
	std::cout << "0b" << std::bitset<sizeof(type)*8>{A} << '\n';
	std::cout << std::hex << std::showbase << int(A) << '\n';

	return 0;
}
// Вывод:
54
0b00110110
0x36