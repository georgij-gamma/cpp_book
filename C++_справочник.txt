enum // представляет собой альтернативный по отношению к const
// способ создания символических констант.
enum spectrum {red, orange, yellow, green, blue, violet, indigo, ultraviolet};
red == 0; ... ultraviolet == 7;
spectrum band;	// band — переменная типа spectrum
band = blue;	// blue - перечислитель == 4
/* Перечисления — целочисленные типы, и они могут быть представлены в виде
int, однако тип int не преобразуется автоматически в тип перечисления: */
++band; 			 // неправильно
int color = blue;	 // правильно, тип spectrum приводится к int
band = 3;			 // неправильно, int не преобразуется в spectrum
color = 3 + red;	 // правильно, red преобразуется в int
band = orange + red; // неправильно, операция '+' не определена для перечислителей.
band = spectrum(3);  // правильно, приведение 3 к типу spectrum
/* Конкретные значения элементов перечислений можно устанавливать явно 
посредством операция присваивания: */
enum bits {one = 1, two = 2, four = 4, eight = 8};
enum bigstep{first, second = 100, third};	// first == 0; third == 101;
enum {zero, null = 0, one, numero_uno = 1}; /* Здесь zero и null имеют значение 0, 
a one и numero_uno — значение 1.
В C++ элементам перечислений можно использовать значения типа int, long или long long.
Каждое перечисление имеет диапазон, и с помощью приведения к типу 
переменной перечисления можно присвоить любое целочисленное значение в пределах
этого диапазона, даже если данное значение не равно ни одному из перечислителей. */
enum bits {one = 1, two = 2, four = 4, eight = 8};
bits myflag;
myflag = bits(6); // правильно, потому что 6 находится в пределах диапазона
/* Для нахождения верхнего предела
выбирается перечислитель с максимальным значением. Затем ищется наименьшее
число, являющееся степенью двойки, которое больше этого максимального значения,
и из него вычитается единица. (Например, максимальное значение bigstep, как 
определено выше, равно 101. Минимальное число, представляющее степень двойки,
которое больше 101, равно 128, поэтому верхним пределом диапазона будет 127.)
Для нахождения минимального предела выбирается минимальное значение 
перечислителя. Если оно равно 0 или больше, то нижним пределом диапазона будет 0. 
Если же минимальное значение перечислителя отрицательное, используется такой же 
подход, как при вычислении верхнего предела, но со знаком минус. (Например, если
минимальный перечислитель равен -6, то следующей степенью двойки будет -8, и
нижний предел получается равным -7.)
 Входной поток cin не распознает перечислимые типы (он не может знать, как вы 
определите их), поэтому программа читает выбор как int. Когда оператор switch 
сравнивает значение int с перечислимой меткой case, он приводит перечисление к 
типу int. Точно также перечисления приводятся к int в проверочном условии цикла 
while. */
enum {red, orange, yellow, green, blue, violet, indigo};
int code;
cin >> code;
while (code >= red && code <= indigo)
{
	switch (code)
	{
		case red : cout << "Her lips were red.\n"; break;
		case orange : cout << "Her hair was orange.\n"; break;
		case yellow : cout << "Her shoes were yellow.\n"; break;
		case green : cout << "Her nails were green.\n"; break;
		case blue : cout << "Her sweatsuit was blue.\n"; break;
		case violet : cout << "Her eyes were violet.\n"; break;
		case indigo : cout << "Her mood was indigo.\n"; break;
		}
cout << "Enter color code (0-6) : ";
cin >> code;
}
/*	Перечисления с областью видимости не поддерживают неявных преобразований 
в целочисленные типы: */
enum egg_old {Small, Medium, Large, Jumbo};			// без области видимости
enum class t_shirt {Small, Medium, Large, Xlarge};	// с областью видимости
egg_old one = Medium;			// без области видимости
t_shirt rolf = t_shirt::Large;  // с областью видимости
int king = one;		// неявное преобразование для перечисления без области видимости
int ring = rolf;	// не разрешено, неявное преобразование типа не поддерживается
if (king < Jumbo)	// разрешено
	std::cout << "Jumbo converted to int before comparison.\n";
if (king < t_shirt::Medium)		// не разрешено
	std::cout << "Not allowed: < not defined for scoped enum.\n";
// Однако при необходимости можно выполнять явное преобразование типа:
int Frodo = int(t_shirt::Small); // Frodo устанавливается в 0
/* По умолчанию лежащим в основе типом для перечислений с областью видимости C++11
является int. Более того, доступен синтаксис для указания другого лежащего в основе
типа. Лежащим в основе типом для pizza является short: */
enum class : short pizza {Small, Medium, Large, XLarge};
/* Лежащий в основе тип должен быть целочисленным.

	Assert — это специальная конструкция, позволяющая проверять предположения о 
значениях произвольных данных в произвольном месте программы. Эта конструкция 
может автоматически сигнализировать при обнаружении некорректных данных, что 
обычно приводит к аварийному завершению программы с указанием места обнаружения 
некорректных данных. Т.к. assert завершает программу сразу же после обнаружения 
некорректных данных, он позволяет быстро локализировать и исправить баги в 
программе, которые привели к некорректным данным. Это его основное назначение. 
Assert'ы позволяют отлавливать ошибки в программах на этапе компиляции либо во 
время исполнения. 
	Assert'ы можно разделить на следующие классы:
• Проверка входящих аргументов в начале функции. */
// Считает факториал числа n.
// Число n должно лежать в пределах от 0 до 10 включительно.
int factorial(int n)
{
  // Факториал отрицательного числа не считается
  assert(n >= 0);
  // Если n превысит 10, то это может привести либо к целочисленному
  // переполнению результата, либо к переполнению стэка.
  assert(n <= 10);
  if (n < 2)
  {
    return 1;
  }

  return factorial(n - 1) * n;
}
/* мы 'забыли' об ограничениях функции factorial() и пытаемся вычислить
// факториалы чисел от 0 до 99.
// проверка внутри factorial() любезно напомнит нам о своих ограничениях,
// так что мы сможем быстро выявить и исправить этот баг.
// если бы эта проверка отсутствовала, то баг мог бы долго оставаться
// незамеченным, периодически давая о себе знать переполнениями стэка и
// некорректным поведением программы.*/
for (int i = 0; i < 100; ++i)
{
  a[i] = factorial(i);
}
/* Важно понимать, что входящие аргументы функции могут быть неявными. Например, 
при вызове метода класса в функцию неявно передается указатель на объект данного 
класса (aka this и self). Также функция может обращаться к данным, объявленным в 
глобальной области видимости, либо к данным из области видимости лексического 
замыкания. Эти аргументы тоже желательно проверять с помощью assert'ов при входе 
в функцию. Если некорректные данные обнаружены на этом этапе, то код данной 
функции может содержать баги. */
int factorial(int n)
{
  int result = 1;
  for (int i = 2; i <= n; ++i)
  {
    result *= i;
  }
  /* С первого взгляда эта проверка никогда не сработает - факториал должен
  // быть всегда положительным числом. Но как только n превысит допустимый
  // предел, произойдет целочисленное переполнение. В этом случае
  // a[i] может принять отрицательное либо нулевое значение.
  // После срабатывания этой проверки мы быстро локализуем баг и поймем,
  // что либо нужно ограничивать значение n, либо использовать целочисленную
  // арифметику с бесконечной точностью. */
  assert(result > 0);
  return result;
}
/* Результат функции может быть неявным. Например, функция может модифицировать 
данные, на которые ссылаются (напрямую или косвенно) аргументы функции. Также 
функция может модифицировать данные из глобальной области видимости или из 
области видимости лексического замыкания. Корректность этих данных желательно 
проверять перед выходом из функции.
Проверка данных, с которыми работает функция, внутри кода функции.
• Если в середине функции обнаруживаются некорректные данные, то баги могут быть 
где-то в районе этой проверки. */
int factorial(int n)
{
  int result = 1;
  while (n > 1) 
  {
    // Знакомая нам проверка на целочисленное переполнение.
    // При ее срабатывании мы быстро определим, что эта функция должна уметь
    // корректно обрабатывать слишком большие n, ведущие к переполнению.
    // Эта проверка лучше, чем проверка из предыдущего пункта (перед выходом
    // из функции), т.к. она срабатывает перед первым переполнением result,
    // тогда как проверка из предыдущего пункта может пропустить случай, когда
    // в результате переполнения (или серии переполнений) итоговое значение
    // result остается положительным.
    assert(result <= INT_MAX / n);
    result *= n;
    --n;
  }
  return result;
}
/* Внутри assert'а нельзя вызывать функции, изменяющие состояние программы либо 
внешнего окружения программы. Например, следующий код неправильно использует 
assert'ы: */
// Захватывает данный мютекс.
// Возвращает 0, если невозможно захватить данный мютекс из-за следующих причин:
// - мютекс уже был захвачен.
// - mtx указывает на некорректный объект мютекса.
// Возвращает 1, если мютекс успешно захвачен.
int acquire_mutex(mutex *mtx);
// Освобождает данный мютекс.
// Возвращает 0, если невозможно освободить данный мютекс из-за следующих
// причин:
// - мютекс не был захвачен.
// - mtx указывает на некорректный объект мютекса.
// Возвращает 1, если мютекс успешно захвачен.
int release_mutes(mutex *mtx);
// Убеждаемся, что мютекс захвачен.
assert(acquire_mutex(mtx));
// Работаем с данными, "защищенными" мютексом.
process_data(data_protected_by_mtx);
// Убеждаемся, что мютекс освобожден.
assert(release_mutes(mtx));
/* Очевидно, что данные могут оказаться незащищенными при отключенных 
assert'ах. Чтобы исправить эту ошибку, нужно сохранять результат выполнения 
функции во временной переменной, после чего использовать эту переменную внутри 
assert'а: */
int is_success;
is_success = acquire_mutex(mtx);
assert(is_success);
// Теперь данные защищены мютексом даже при отключенных assert'ах.
process_data(data_protected_by_mtx);
is_success = release_mutex(mtx);
assert(is_success);
/* Т.к. основное назначение assert'ов — отлов багов (aka ошибки программирования), 
то они не могут заменить обработку ожидаемых ошибок, которые не являются ошибками 
программирования. Например: */
// Пытается записать buf_size байт данных, на которые указывает buf,
// в указанное сетевое соединение connection.
// Возвращает 0 в случае ошибки записи, возникшей не по нашей вине. Например,
// произошел разрыв сетевого соединения во время записи.
// Возвращает 1 в случае успешной записи данных.
int write(connection *connection, const void *buf, size_t buf_size);
int is_success = write(connection, buf, buf_size);
// "Убеждаемся", что данные корректно записаны.
assert(is_success);
/* Если write() возвращает 0, то это вовсе не означает, что в нашей программе есть 
баг. Если assert'ы в программе будут отключены, то ошибка записи может остаться 
незамеченной, что впоследствие может привести к печальным результатам. Поэтому 
assert() тут не подходит. Тут лучше подходит обычная обработка ошибки. Например: */
while (!write(connection, buf, buf_size))
{
  // Пытаемся создать новое соединение и записать данные туда еще раз.
  close_connection(connection);
  connection = create_connection();
}








