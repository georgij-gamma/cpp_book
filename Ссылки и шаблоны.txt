/*Ссылки используются в качестве параметров функции, при этом имя 
переменной в функции становится псевдонимом переменной в вызывающей программе.*/
void swapr(int & a, int & b);
void swapp (int *p, int *q);
/*Различие состоит в том, что вариант с указателем требует применения 
операции разыменования (*) во всех случаях, когда функция использует переменные р и q.
Ссылочную переменную необходимо инициализировать при ее определении.
	При условии, что ссылочный параметр является const, компилятор генерирует временную 
переменную в двух ситуациях:
• когда тип фактического аргумента выбран правильно, но сам параметр не 
является lvalue;
• когда тип фактического параметра выбран неправильно, но может быть 
преобразован в правильный тип.
	lvalue, представляет собой объект 
данных, на который можно ссылаться по адресу. Например, переменная, элемент 
массива, член структуры, ссылка и разыменованный указатель —
все они являются lvalue.
К lvalue не относятся литеральные константы (кроме строк в двойных кавычках, 
которые представлены своими адресами) и выражения, состоящие из нескольких 
элементов.
	Если передаваемый функции аргумент не является lvalue или не совместим по типу с 
соответствующим ссылочным параметром const, C++ создает анонимную переменную требуемого 
типа, присваивает ей значение передаваемого функции аргумента, и делает так, чтобы 
параметр ссылался на эту переменную.
	Причины объявлять ссылочные аргументы как ссылки на констатные данные:
• Использование const защищает от внесения в программы ошибок, приводящих к 
непреднамеренному изменению данных.
• Использование const позволяет функции обрабатывать фактические аргументы как с 
const, так и без const. При этом функция, в прототипе которой квалификатор const 
опущен, может принимать только неконстантные данные.
• Использование ссылки const позволяет функции генерировать и использовать временные 
переменные по мере необходимости.
Исходный ссылочный тип (объявленный с использованием &) называется ссылкой lvalue.
	Для отображения содержимого структуры, не изменяя её, в 
функциях применяется ссылочный параметр const. В таком случае структуру можно
было бы передать по значению, однако использование ссылки более экономично с
точки зрения времени и памяти, чем создание копии исходной структуры.
	Причины использовать ссылочные аргументы:
• чтобы позволить изменять объект данных в вызывающей функции;
• чтобы ускорить работу программы за счет передачи ссылки вместо полной 
копии объекта данных.
	***
	В каких случаях следует использовать ссылку, указатель или передачу по значению? 
	1. Функция использует передаваемые данные без их изменения в перечисленных
ниже ситуациях:
• Если объект данных небольшой, например, такой как встроенный тип данных
или некрупная структура, передавайте его по значению.
• Если объект данных представляет собой массив, используйте указатель, 
поскольку это единственный вариант. Объявите указатель с квалификатором const.
• Если объект данных является структурой приемлемого размера, используйте
const-указатель или const-ссылку для увеличения эффективности программы.
В этом случае удастся сохранить время и пространство, необходимое для 
копирования структуры или строения класса. Объявите указатель или ссылку с 
квалификатором const.
• Если объект данных является объектом класса, используйте ссылку с 
квалификатором const. Семантика строения класса часто требует применения ссылки.
Эта главная причина добавления этого новшества в язык C++. Таким образом,
стандартом является передача объектов класса по ссылке.
	2. Функция изменяет данные вызывающей функции в следующих ситуациях:
• Если объект данных относится к одному из встроенных типов, используйте 
указатель. Если в коде встретилось выражение вида fixit (&х), где х имеет тип int,
это явно означает, что функция должна изменять значение х.
• Если объект данных представляет собой массив, остается один выбор — указатель.
• Если объект данных является структурой, можно использовать ссылку или указатель.
• Когда объект данных представляет собой объект класса, следует применять ссылку.
	Могут существовать причины для других решений. Например, объект сіn 
	использует ссылки на базовые типы данных, поэтому
вместо записи сіn » &n можно применять запись сіn » n.
	***
	Аргументы по умолчанию
	Аргумент по умолчанию представляет собой значение, которое
используется автоматически, если соответствующий фактический параметр в вызове
функции не указан.*/
char * left (const char * str, int n = 1) // функция должна возвращать новую строку,
{										  // т.к. нужно сохранить исходную строку неизменной,
										  // использовать квалификатор const для первого аргумента.
if (n < 0)
	n = 0;
char *p = new char[n+l];
int i;
for (i = 0; i < n && str[i]; i++ )
	p[i] = str[i]; // копирование символов
while (i <= n)
	p[i++] = '\0'; // установка остальных символов строки в '\0'
return p;
}
/*	Перегрузка функций
	Полиморфизм функций, или перегрузка функций, 
предоставляет возможность использовать несколько функций с одним
и тем же именем. Ключевую роль в перегрузке функций играет список аргументов, который 
называется сигнатурой функции.
	Значение без const можно присвоить переменной const, но не наоборот.
	Именно сигнатура, а не тип функции, делает возможным ее 
перегрузку: */
long gronk(int n, float m); // одинаковые сигнатуры, поэтому
double gronk(int n, float m); // объявления не допускаются
/*В C++ нельзя перегружать функцию gronk () подобным образом. Можно иметь 
различные возвращаемые типы, но только при условии, что сигнатуры функций 
отличаются: */
long gronk(int n, float m) ; // различные сигнатуры, поэтому
double gronk(float n, float m) ; // объявления допустимы

/* Перегрузка ссылочных параметров */
void sink(double & rl); // соответствует изменяемому lvalue
void sank(const double & r2) ; // соответствует изменяемому
// или константному lvalue, rvalue
void sunk(double && r3); // соответствует rvalue
/*Ссылочный параметр lvalue по имени rl соответствует изменяемому аргументу lvalue, 
такому как переменная double. Константный ссылочный параметр lvalue по имени r2 
соответствует изменяемому аргументу, константному аргументу lvalue и аргументу rvalue, такому как
сумма двух значений double. И, наконец, ссылка rvalue по имени гЗ соответствует rvalue.
Обратите внимание, что r2 может соответствовать той же разновидности аргументов, как
rl и rЗ. Возникает вопрос, а что случится, если перегрузить функцию с этими тремя типами
параметров? Ответ заключается в том, что будет предпринят поиск более точного 
соответствия:*/
void staff(double & rs); // соответствует изменяемому lvalue
voit staff(const double & res); // соответствует rvalue,
// константному lvalue
void stove(double & rl); // соответствует изменяемому lvalue
void stove(const double & r2); // соответствует константному lvalue
void stove(double && r3); // соответствует rvalue
/* Это позволяет настраивать поведение функции на основе того, каковой является природа
аргумента — lvalue, const или rvalue:*/
double x = 55.5;
const double у = 32.0;
stove(x); // вызывает stove(double &)
stove(у); // вызывает stove(const double &)
stove(x+y); // вызывает stove(double &&)
/* Если, скажем, опустить функцию stove (double &&), то stove (x+y) взамен приведет к
вызову stove(const double &).
	Перегрузку целесообразно использовать для функций, которые выполняют в основном одни 
и те же действия, но с различными типами данных.
	Декорированием имен или искажением имен - это когда имя каждой функции шифруется на 
основе типов формальных параметров, указанных в прототипе функции.
Например*/
long MyFunctionFoo(int, float);
// будет декодировано:
?MyFunctionFoo@@YAXH // может отличаться в разных компиляторах

/*	
*/












