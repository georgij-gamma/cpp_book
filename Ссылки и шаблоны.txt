/*Ссылки используются в качестве параметров функции, при этом имя 
переменной в функции становится псевдонимом переменной в вызывающей программе.*/
void swapr(int & a, int & b);
void swapp (int *p, int *q);
/*Различие состоит в том, что вариант с указателем требует применения 
операции разыменования (*) во всех случаях, когда функция использует переменные р и q.
Ссылочную переменную необходимо инициализировать при ее определении.
	При условии, что ссылочный параметр является const, компилятор генерирует временную 
переменную в двух ситуациях:
• когда тип фактического аргумента выбран правильно, но сам параметр не 
является lvalue;
• когда тип фактического параметра выбран неправильно, но может быть 
преобразован в правильный тип.
	lvalue, представляет собой объект 
данных, на который можно ссылаться по адресу. Например, переменная, элемент 
массива, член структуры, ссылка и разыменованный указатель —
все они являются lvalue.
К lvalue не относятся литеральные константы (кроме строк в двойных кавычках, 
которые представлены своими адресами) и выражения, состоящие из нескольких 
элементов.
	Если передаваемый функции аргумент не является lvalue или не совместим по типу с 
соответствующим ссылочным параметром const, C++ создает анонимную переменную требуемого 
типа, присваивает ей значение передаваемого функции аргумента, и делает так, чтобы 
параметр ссылался на эту переменную.
	Причины объявлять ссылочные аргументы как ссылки на констатные данные:
• Использование const защищает от внесения в программы ошибок, приводящих к 
непреднамеренному изменению данных.
• Использование const позволяет функции обрабатывать фактические аргументы как с 
const, так и без const. При этом функция, в прототипе которой квалификатор const 
опущен, может принимать только неконстантные данные.
• Использование ссылки const позволяет функции генерировать и использовать временные 
переменные по мере необходимости.
Исходный ссылочный тип (объявленный с использованием &) называется ссылкой lvalue.
	Для отображения содержимого структуры, не изменяя её, в 
функциях применяется ссылочный параметр const. В таком случае структуру можно
было бы передать по значению, однако использование ссылки более экономично с
точки зрения времени и памяти, чем создание копии исходной структуры.
	Причины использовать ссылочные аргументы:
• чтобы позволить изменять объект данных в вызывающей функции;
• чтобы ускорить работу программы за счет передачи ссылки вместо полной 
копии объекта данных.
	***
	В каких случаях следует использовать ссылку, указатель или передачу по значению? 
	1. Функция использует передаваемые данные без их изменения в перечисленных
ниже ситуациях:
• Если объект данных небольшой, например, такой как встроенный тип данных
или некрупная структура, передавайте его по значению.
• Если объект данных представляет собой массив, используйте указатель, 
поскольку это единственный вариант. Объявите указатель с квалификатором const.
• Если объект данных является структурой приемлемого размера, используйте
const-указатель или const-ссылку для увеличения эффективности программы.
В этом случае удастся сохранить время и пространство, необходимое для 
копирования структуры или строения класса. Объявите указатель или ссылку с 
квалификатором const.
• Если объект данных является объектом класса, используйте ссылку с 
квалификатором const. Семантика строения класса часто требует применения ссылки.
Эта главная причина добавления этого новшества в язык C++. Таким образом,
стандартом является передача объектов класса по ссылке.
	2. Функция изменяет данные вызывающей функции в следующих ситуациях:
• Если объект данных относится к одному из встроенных типов, используйте 
указатель. Если в коде встретилось выражение вида fixit (&х), где х имеет тип int,
это явно означает, что функция должна изменять значение х.
• Если объект данных представляет собой массив, остается один выбор — указатель.
• Если объект данных является структурой, можно использовать ссылку или указатель.
• Когда объект данных представляет собой объект класса, следует применять ссылку.
	Могут существовать причины для других решений. Например, объект сіn 
	использует ссылки на базовые типы данных, поэтому
вместо записи сіn » &n можно применять запись сіn » n.
	***
	Аргументы по умолчанию
	Аргумент по умолчанию представляет собой значение, которое
используется автоматически, если соответствующий фактический параметр в вызове
функции не указан.*/
char * left (const char * str, int n = 1) // функция должна возвращать новую строку,
{										  // т.к. нужно сохранить исходную строку неизменной,
										  // использовать квалификатор const для первого аргумента.
if (n < 0)
	n = 0;
char *p = new char[n+l];
int i;
for (i = 0; i < n && str[i]; i++ )
	p[i] = str[i]; // копирование символов
while (i <= n)
	p[i++] = '\0'; // установка остальных символов строки в '\0'
return p;
}
/*	Перегрузка функций
	Полиморфизм функций, или перегрузка функций, 
предоставляет возможность использовать несколько функций с одним
и тем же именем. Ключевую роль в перегрузке функций играет список аргументов, который 
называется сигнатурой функции.














