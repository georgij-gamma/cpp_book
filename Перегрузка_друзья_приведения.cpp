/*	Перегрузка операций — это пример полиморфизма C++.
Для перегрузки операции используется специальная форма функции, называемая
функцией операции. */
operator op (список-аргументов) // ор — это символ перегружаемой операции
operator+ () // перегружает операцию +, а
operator* () // операцию *.
// Операция ор должна быть допустимой операцией C++, а не произвольным символом.
operator@ () // не получится, т.к. в C++ нет операции @
operator[]() // перегружает операцию [], поскольку [] — операция индексации массивов.

/* Предположим, что имеется класс Salesperson, в котором определена функция-член 
operator+ () для перегрузки операции +. Тогда если district2, sid и sara —
объекты класса Salesperson, можно написать следующее выражение: */
district2 = sid + sara;
/* Компилятор, распознав операцию как относящуюся к классу Salesperson, 
заменит ее вызовом соответствующей функции операции: */
district2 = sid.operator+(sara);
/* Функция затем использует объект sid неявно (поскольку она вызывает метод), а
объект sara — явно (т.к. он передается в виде аргумента) для вычисления суммы, 
возвращаемой в результате. 
/* Имя функции operator* () позволяет вызывать ее как в нотации
с функцией, так и в нотации с операцией. Компилятор использует тип операнда для
определения того, что необходимо делать: */
int a, b, с;
Time А, В, С;
с = а + b; // используется сложение значений int
С = А + В; // используется сложение, определенное для объектов Time
/* А можно ли складывать более двух объектов? Например, если t1, t2, t3 и t4 
являются объектами класса Time, будет ли допустимым следующий оператор: */
t4 = t1 + t2 + t3; // правильно ли это?
/* Чтобы ответить на этот вопрос, нужно посмотреть, как это выражение 
транслируется в вызовы функций. Поскольку сложение —
операция, выполняемая слева 
направо, первая трансляция дает: */
t4 = t1.operator+ (t2 + t3) ; // правильно ли это?
// Затем аргумент функции также транслируется в вызов функции, и мы получаем:
t4 = t1.operator+(t2.operator+ (t3)); // правильно ли это?
/* Да, верно. Вызов функции t2.operator* (t3) возвращает объект Time, 
представляющий собой сумму t2 и t3. Этот объект затем передается вызову
t1.operator+ () и этот вызов возвращает сумму t1 и объекта Time, который 
представляет сумму t2 и t3. Финальное возвращаемое значение является
суммой t1, t2 и t3, что и ожидалось.
	Ограничения перегрузки
• Перегруженные операции должны иметь как минимум один операнд типа, 
определяемого пользователем. Это предотвращает перегрузку операций, 
работающих со стандартными типами. То есть переопределить операцию "минус" (-)
так, чтобы она вычисляла сумму двух вещественных чисел вместо разности, не
получится. Это ограничение сохраняет здравый смысл, заложенный в 
программу, хотя и несколько препятствует полету творчества.
• Вы не можете использовать операцию в такой манере, которая нарушает 
правила синтаксиса исходной операции.
Например, нельзя перегрузить операцию взятия модуля (%) так, чтобы она 
применялась с одним операндом: */
int x;
Time shiva;
% х; //не допускается для операции взятия модуля
% shiva; //не допускается для перегруженной операции
/* Аналогично, не допускается изменение приоритетов операций. Поэтому, если
вы перегрузите операцию сложения для класса, то новая операция будет иметь
тот же приоритет, что и обычное сложение.
• Вы не можете определять новые символы операций. Например, определить
функцию operator** () для создания операции возведения в степень не 
получится.
• Нельзя перегружать следующие операции:
Операция:		Описание: */
sizeof	// Операция sizeof
	.	// Операция членства
	.*	// Операция указателя на член
	::	// Операция разрешения контекста
	:?	// Условная операция
typeid	// Операция RTTI (runtime type identification — определение типа во время выполнения)
const_cast 	// Операция приведения типа
dynamic_cast // Операция приведения типа
reinterpret_cast // Операция приведения типа
static_cast // Операция приведения типа
/* Тем не менее, операции, перечисленные в табл. 11.1, по-прежнему доступны для
перегрузки.
• Большинство операций из табл. 11.1 допускают перегрузку за счет 
использования как функций-членов, так и функций, не являющихся членами. Однако для
перегрузки перечисленных ниже операций можно использовать только функции-члены: 
Операция:		Описание: */
	= 	// Операция присваивания
	() 	// Операция вызова функции
	[]	// Операция индексации
	->	// Операция доступа к членам класса через указатель
	
// mytime.h -- Time class before operator overloading
#ifndef MYTIME_H_
#define MYTIME_H_
class Time
{
private:
    int hours;
    int minutes;
public:
    Time();
    Time(int h, int m = 0);
    void AddMin(int m);
    void AddHr(int h);
    void Reset(int h = 0, int m = 0);
    //const Time Sum(const Time & t) const;
    Time operator+(const Time & t) const;
    Time operator-(const Time & t) const;
    Time operator*(double n) const;
    void Show() const;
};
#endif

// mytime.cpp  -- implementing Time methods
#include <iostream>
#include "mytime.h"
Time::Time()
{
    hours = minutes = 0;
}
Time::Time(int h, int m )
{
    hours = h;
    minutes = m;
}
void Time::AddMin(int m)
{
    minutes += m;
    hours += minutes / 60;
    minutes %= 60;
}
void Time::AddHr(int h)
{
    hours += h;
}
void Time::Reset(int h, int m)
{
    hours = h;
    minutes = m;
}
//const Time Time::Sum(const Time & t) const
Time Time::operator+(const Time & t) const
{
    Time sum;
    sum.minutes = (minutes + t.minutes) % 60;
    sum.hours = hours + t.hours + (minutes + t.minutes) / 60;
    return sum;
}
Time Time::operator-(const Time & t) const
{
    Time diff;
    diff.minutes = ((minutes + 60 * hours) - (t.minutes + 60 * t.hours)) % 60;
    diff.hours = ((minutes + 60 * hours) - (t.minutes + 60 * t.hours)) / 60;
    return diff;
}
Time Time::operator*(double mult) const
{
    Time result;
    long totalminutes = hours * mult * 60 + minutes * mult;
    result.hours = totalminutes / 60;
    result.minutes = totalminutes % 60;
    return result;
}
void Time::Show() const
{
    std::cout << hours << " hours, " << minutes << " minutes\n";
}

// usetime.cpp -- using the first draft of the Time class
// compile usetime0.cpp and mytime0.cpp together
#include <iostream>
#include "mytime.h"
int main()
{
    Time planning;
    Time coding(2, 40);
    Time fixing(5, 55);
    Time total;

    std::cout << "planning time =\t"; // время на планирование
    planning.Show();
 
    std::cout << "coding time =\t";   // время на кодирование
    coding.Show();
    
    std::cout << "fixing time =\t";   // время на исправление
    fixing.Show();

    // total = coding.Sum(fixing);  // кодирование + исправление
    total = coding + fixing;  // нотация с операцией; можно заменить нотацией с функцией:
    // total = coding.operator+(fixing);
    // std::cout << "coding.Sum(fixing) = ";
    std::cout << "coding + fixing = ";
  	total.Show();

    Time morefixing(3, 28);   // дополнительное время на исправление
    std::cout << "more fixing time = ";
    morefixing.Show();

    total = morefixing.operator+(total);  // нотацией с функцией
    std::cout << "morefixing.operator+(total) =\t";
    total.Show();
    std::cout << std::endl;

    Time weeding(4, 35);
    Time waxing(2, 47);
    Time diff;
    Time adjusted;
    std::cout << "weeding time =\t";   // время на подготовку
    weeding.Show();

    std::cout << "waxing time =\t";    // полезное время
    waxing.Show ();

    std::cout << "total work time = ";
    total = weeding + waxing;
    total.Show();

    diff = weeding - waxing;           // используется operator- ()
    std::cout << "weeding time - waxing time = ";
    diff.Show();

    adjusted = total * 1.5;
    std::cout << "adjusted work time =\t";
    adjusted.Show ();
    // std::cin.get();
    return 0;
}
/*	Друзья
 Существует три разновидности друзей:
• дружественные функции;
• дружественные классы;
• дружественные функции-члены.
 Объявляя функцию другом класса, вы позволяете ей иметь те же привилегии 
доступа, что и у функций-членов класса.
 Функция, не являющаяся членом, не вызывается через объект. Вместо этого 
 все значения, которые она использует, включая объекты, передаются в виде 
 явных аргументов. Таким образом, компилятор может представить выражение */
А = 2.75 * В; //не соответствует функции-члену
// в виде вызова функции, не являющейся членом:
А = operator* (2.75, В);
//Эта функция должна иметь следующий прототип:
Time operator* (double m, const Time & t) ;
/* Благодаря этой функции, не являющейся членом, которая перегружает операцию,
левый операнд выражения соответствует первому аргументу функции, а правый —
второму. Между тем, исходная функция-член имеет дело с операндами в обратном 
порядке — т.е. значение типа Time умножается на значение типа double.
 Существует специальная категория функций, не являющихся членами,
называемая друзьями, которая имеет доступ к закрытым данным класса: */
friend Time operator* (double m, const Time & t); // размещается в объявлении класса
/* На основе этого прототипа можно сделать два вывода.
• Несмотря на то что функция operator* () присутствует в объявлении класса,
она не является функцией-членом класса. Поэтому она не вызывается через 
операцию членства (.).
• Несмотря на то что функция operator* () не является функцией-членом класса,
она имеет те же права доступа, что и функции-члены.
 Определения функции: */
Time operator*(double m, const Time & t) // friend в определении не используется
{
	Time result;
	long totalminutes = t.hours * mult * 60 +t. minutes * mult;
	result.hours   = totalminutes / 60;
	result.minutes = totalminutes % 60;
	return result;
}
// С таким объявлением и определением оператор:
А = 2.75 * В;
/* транслируется в следующий вызов только что определенной дружественной функции,
не являющейся членом: */
А = operator*(2.75, В);
/* Дружественная функция класса — это функция, не являющаяся членом, но которая 
имеет те же права доступа, что и функция-член.
 Используя и дружественную функцию, и функцию-член, обе операции можно выразить в 
одном пользовательском интерфейсе. Следует помнить, что только объявление 
класса определяет, какие функции являются дружественными, т.е. объявление класса 
по-прежнему управляет тем, каким функциям разрешен доступ к закрытым данным. 
Методы класса и друзья — это просто два разных механизма выражения интерфейса класса.
 Эту конкретную дружественную функцию можно реализовать через вызов функции-члена, 
изменив ее определение так, чтобы перед умножением она сначала меняла местами 
переданные операнды: */
Time operator* (double m, const Time & t)
{
	return t * m; // используется t.operator*(m)
}
/* Исходная версия имеет явный доступ к t.minutes и t.hours, поэтому должна
быть другом. Показанная выше версия только использует объект t типа Time как 
единое целое, позволяя функции-члену работать с закрытыми значениями, поэтому 
такая функция не обязана быть другом. Однако, несмотря на это, все же имеет смысл
сделать эту версию также дружественной. Самое главное, что это делает ее частью
официального интерфейса класса. И второе: если вы позже столкнетесь с 
необходимостью иметь прямой доступ к закрытым данным, то должны будете изменить 
только определение функции, не затрагивая прототип класса.
	Общий вид друга: перегрузка операции <<
	Первая версия перегрузки операции <<
 За счет использования дружественной функции операцию можно перегрузить, 
как показано ниже: */
void operator<<(ostream & os, const Time & t)
{
	os << t.hours << " hours, " << t.minutes << " minutes";
}
// Это позволит написать следующий код:
cout << trip;
// который отобразит данные в таком формате:
4 hours, 23 minutes
/* В новом объявлении класса Time функция operator<< () сделана дружественной функцией 
класса Time. Однако эта функция, хотя и не "враждебна" классу ostream, дружественной
по отношению к нему не является, функция operator<< () принимает аргументы ostream
и Time, поэтому может показаться, что она должна быть дружественной по отношению к
обоим классам. Но если вы посмотрите на код этой функции, то увидите, что она получает
доступ к индивидуальным членам объекта Time, но использует объект ostream только как
единое целое. Поскольку operator<< () обращается к закрытым членам Time напрямую,
она должна быть другом класса Time. Так как она не имеет доступа к закрытым членам клас-
са ostream, то другом этого класса ей быть не нужно. И это замечательно, поскольку озна-
чает, что изменять определение ostream не понадобится.
 Обратите внимание, что новое определение operator<< () принимает ссылку на 
объект os типа ostream в качестве первого аргумента. Обычно os является ссылкой на 
объект cout, как это имеет место в выражении cout << trip. Однако эту операцию можно
использовать с другими объектами ostream; в этом случае os будет ссылаться на них.	
	Вторая версия перегрузки операции <<
С представленной выше реализацией связана одна проблема. Операторы вроде 
показанного ниже работают хорошо: */
cout << trip;
/* Но данная реализация не позволяет применять переопределенную операцию <<
так, как это обычно делается при работе с cout: */
cout << "Trip time: " << trip << " (Tuesday) \n"; // так не получится
// Предположим, что есть следующие операторы:
int х = 5;
int у = 8;
cout << х << у;
// C++ читает выражение вывода слева направо, подразумевая следующий эквивалент:
(cout << х) << у; /* Оператор вывода требует, чтобы все выражение (cout << х) 
было типа ostream, поскольку оно расположено слева от << у. Следовательно, 
класс ostream реализует функцию operator<< () так, что она возвращает ссылку 
на объект ostream. В частности, в данном случае она возвращает ссылку на 
вызывающий объект cout. Таким образом, выражение (cout << х) само по себе является 
объектом cout типа ostream и может находиться в левой части операции <<.
 Тот же самый подход можно применить с дружественной функцией. Понадобится лишь 
изменить функцию operator<< () так, чтобы она возвращала ссылку на объект ostream: */
ostream & operator << (ostream & os, const Time & t)
{
	os << t.hours << "hours, " << t.minutes << "minutes";
	return os;
}
/* Типом возврата является */ ostream &. /* Вспомните, что это означает возврат 
функцией ссылки на объект ostream. Поскольку программа передает ссылку на объект 
функции в первом аргументе, общий эффект состоит в том, что функция возвращает тот 
самый объект, который ей передан. То есть оператор: */
cout << trip;
// превращается в следующий вызов функции:
operator<<(cout, trip);
// И такой вызов возвращает объект cout. Поэтому теперь работает такой оператор:
cout << "Trip time: " << trip << " (Tuesday)\n"; // теперь работает
/* Первый шаг вызывает конкретное определение операции << из ostream, которое 
отображает строку и возвращает объект cout: */
cout << "Trip time: "
// Поэтому выражение 
cout << "Trip time: "
/* отображает строку и затем заменяется типом возврата — cout. Это превращает 
исходный оператор в следующий: */
cout << trip << " (Tuesday)\n";
/* Далее программа использует определение операции << из класса Time для того,
чтобы отобразить значения trip и снова возвратить объект cout. Оператор 
приобретет такой вид: */
cout << " (Tuesday)\n";
/* Программа завершается использованием определения операции << из ostream
для строк, чтобы отобразить результирующую строку.
Интересно, что эта версия operator<< () также может быть применена для вывода в файл:*/
#include <fstream>
ofstream fout;
fout.open("savetime.txt");
Time trip(12, 40);
fout << trip;
// Последний оператор становится таким:
operator<< (fout, trip);
/* Механизм наследования классов позволяет ссылке на ostream обращаться и к объектам 
ostream, и к объектам of stream.
В общем случае для перегрузки операции << с целью отображения объекта класса c_name
используется дружественная функция со следующим определением: */
ostream & operator<<(ostream & os, const c_name & obj)
{
	os << ... ; // отображение содержимого объекта
	return os;
}
/* Ключевое слово friend используется только в прототипе, представленном в объявлении
класса. В определении функции оно указывается, только если не присутствует в самом прототипе.*/
// mytime3.h -- Time class with friends
#ifndef MYTIME3_H_
#define MYTIME3_H_
#include <iostream>

class Time
{
private:
    int hours;
    int minutes;
public:
    Time();
    Time(int h, int m = 0);
    void AddMin(int m);
    void AddHr(int h);
    void Reset(int h = 0, int m = 0);
    Time operator+(const Time & t) const;
    Time operator-(const Time & t) const;
    Time operator*(double n) const;
    friend Time operator*(double m, const Time & t) { return t * m; }  // встроенное определение
    friend std::ostream & operator<<(std::ostream & os, const Time & t);

};
#endif
/* Методы используют квалификатор Time::, тогда как дружественные функции — нет. 
Поскольку mytime3.h включает iostream и предоставляет объявление 
using std::ostream, включение файла mytime3.h в mytime3.срр предоставляет поддержку 
ostream в файле реализации. */
// mytime3.cpp  -- implementing Time methods
#include "mytime3.h"

Time::Time()
{
    hours = minutes = 0;
}
Time::Time(int h, int m )
{
    hours = h;
    minutes = m;
}
void Time::AddMin(int m)
{
    minutes += m;
    hours += minutes / 60;
    minutes %= 60;
}
void Time::AddHr(int h)
{
    hours += h;
}
void Time::Reset(int h, int m)
{
    hours = h;
    minutes = m;
}
Time Time::operator+(const Time & t) const
{
    Time sum;
    sum.minutes = minutes + t.minutes;
    sum.hours = hours + t.hours + sum.minutes / 60;
    sum.minutes %= 60;
    return sum;
}
Time Time::operator-(const Time & t) const
{
    Time diff;
    int tot1, tot2;
    tot1 = t.minutes + 60 * t.hours;
    tot2 = minutes + 60 * hours;
    diff.minutes = (tot2 - tot1) % 60;
    diff.hours = (tot2 - tot1) / 60;
    return diff;
}
Time Time::operator*(double mult) const
{
    Time result;
    long totalminutes = hours * mult * 60 + minutes * mult;
    result.hours = totalminutes / 60;
    result.minutes = totalminutes % 60;
    return result;
}
std::ostream & operator<<(std::ostream & os, const Time & t)
{
    os << t.hours << " hours, " << t.minutes << " minutes";
    return os; 
}
/* Формально файл usetime3.срр не должен включать заголовочный файл iostream,
поскольку mytime3.h уже включает его. Однако, как пользователь класса Time, Вы не
обязаны знать, какие заголовочные файлы включены в код класса, поэтому в вашей
ответственности включать эти файлы, если код в них нуждается. */
// usetime3.cpp -- using the fourth draft of the Time class
// compile usetime3.cpp and mytime3.cpp together
#include <iostream>
#include "mytime3.h"

int main()
{
    using std::cout;
    using std::endl;
    Time aida(3, 35);
    Time tosca(2, 48);
    Time temp;

    cout << "Aida and Tosca:\n";
    cout << aida << "; " << tosca << endl;
    temp = aida + tosca;	// operator+()
    cout << "Aida + Tosca: " << temp << endl;
    temp = aida* 1.17;		// member operator*()
    cout << "Aida * 1.17: " << temp << endl;
    cout << "10.0 * Tosca: " << 10.0 * tosca << endl;
	// std::cin.get();
    return 0; 
}













