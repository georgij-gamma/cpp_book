/*	Перегрузка операций — это пример полиморфизма C++.
Для перегрузки операции используется специальная форма функции, называемая
функцией операции. */
operator op (список-аргументов) // ор — это символ перегружаемой операции
operator+ () // перегружает операцию +, а
operator* () // операцию *.
// Операция ор должна быть допустимой операцией C++, а не произвольным символом.
operator@ () // не получится, т.к. в C++ нет операции @
operator[]() // перегружает операцию [], поскольку [] — операция индексации массивов.

/* Предположим, что имеется класс Salesperson, в котором определена функция-член 
operator+ () для перегрузки операции +. Тогда если district2, sid и sara —
объекты класса Salesperson, можно написать следующее выражение: */
district2 = sid + sara;
/* Компилятор, распознав операцию как относящуюся к классу Salesperson, 
заменит ее вызовом соответствующей функции операции: */
district2 = sid.operator+(sara);
/* Функция затем использует объект sid неявно (поскольку она вызывает метод), а
объект sara — явно (т.к. он передается в виде аргумента) для вычисления суммы, 
возвращаемой в результате. 
/* Имя функции operator* () позволяет вызывать ее как в нотации
с функцией, так и в нотации с операцией. Компилятор использует тип операнда для
определения того, что необходимо делать: */
int a, b, с;
Time А, В, С;
с = а + b; // используется сложение значений int
С = А + В; // используется сложение, определенное для объектов Time
/* А можно ли складывать более двух объектов? Например, если t1, t2, t3 и t4 
являются объектами класса Time, будет ли допустимым следующий оператор: */
t4 = t1 + t2 + t3; // правильно ли это?
/* Чтобы ответить на этот вопрос, нужно посмотреть, как это выражение 
транслируется в вызовы функций. Поскольку сложение —
операция, выполняемая слева 
направо, первая трансляция дает: */
t4 = t1.operator+ (t2 + t3) ; // правильно ли это?
// Затем аргумент функции также транслируется в вызов функции, и мы получаем:
t4 = t1.operator+(t2.operator+ (t3)); // правильно ли это?
/* Да, верно. Вызов функции t2.operator* (t3) возвращает объект Time, 
представляющий собой сумму t2 и t3. Этот объект затем передается вызову
t1.operator+ () и этот вызов возвращает сумму t1 и объекта Time, который 
представляет сумму t2 и t3. Финальное возвращаемое значение является
суммой t1, t2 и t3, что и ожидалось.
	Ограничения перегрузки
• Перегруженные операции должны иметь как минимум один операнд типа, 
определяемого пользователем. Это предотвращает перегрузку операций, 
работающих со стандартными типами. То есть переопределить операцию "минус" (-)
так, чтобы она вычисляла сумму двух вещественных чисел вместо разности, не
получится. Это ограничение сохраняет здравый смысл, заложенный в 
программу, хотя и несколько препятствует полету творчества.
• Вы не можете использовать операцию в такой манере, которая нарушает 
правила синтаксиса исходной операции.
Например, нельзя перегрузить операцию взятия модуля (%) так, чтобы она 
применялась с одним операндом: */
int x;
Time shiva;
% х; //не допускается для операции взятия модуля
% shiva; //не допускается для перегруженной операции
/* Аналогично, не допускается изменение приоритетов операций. Поэтому, если
вы перегрузите операцию сложения для класса, то новая операция будет иметь
тот же приоритет, что и обычное сложение.
• Вы не можете определять новые символы операций. Например, определить
функцию operator** () для создания операции возведения в степень не 
получится.
• Нельзя перегружать следующие операции:
Операция:		Описание: */
sizeof	// Операция sizeof
	.	// Операция членства
	.*	// Операция указателя на член
	::	// Операция разрешения контекста
	:?	// Условная операция
typeid	// Операция RTTI (runtime type identification — определение типа во время выполнения)
const_cast 	// Операция приведения типа
dynamic_cast // Операция приведения типа
reinterpret_cast // Операция приведения типа
static_cast // Операция приведения типа
/* Тем не менее, операции, перечисленные в табл. 11.1, по-прежнему доступны для
перегрузки.
• Большинство операций из табл. 11.1 допускают перегрузку за счет 
использования как функций-членов, так и функций, не являющихся членами. Однако для
перегрузки перечисленных ниже операций можно использовать только функции-члены: 
Операция:		Описание: */
	= 	// Операция присваивания
	() 	// Операция вызова функции
	[]	// Операция индексации
	->	// Операция доступа к членам класса через указатель
	
// mytime.h -- Time class before operator overloading
#ifndef MYTIME_H_
#define MYTIME_H_
class Time
{
private:
    int hours;
    int minutes;
public:
    Time();
    Time(int h, int m = 0);
    void AddMin(int m);
    void AddHr(int h);
    void Reset(int h = 0, int m = 0);
    //const Time Sum(const Time & t) const;
    Time operator+(const Time & t) const;
    Time operator-(const Time & t) const;
    Time operator*(double n) const;
    void Show() const;
};
#endif

// mytime.cpp  -- implementing Time methods
#include <iostream>
#include "mytime.h"
Time::Time()
{
    hours = minutes = 0;
}
Time::Time(int h, int m )
{
    hours = h;
    minutes = m;
}
void Time::AddMin(int m)
{
    minutes += m;
    hours += minutes / 60;
    minutes %= 60;
}
void Time::AddHr(int h)
{
    hours += h;
}
void Time::Reset(int h, int m)
{
    hours = h;
    minutes = m;
}
//const Time Time::Sum(const Time & t) const
Time Time::operator+(const Time & t) const
{
    Time sum;
    sum.minutes = (minutes + t.minutes) % 60;
    sum.hours = hours + t.hours + (minutes + t.minutes) / 60;
    return sum;
}
Time Time::operator-(const Time & t) const
{
    Time diff;
    diff.minutes = ((minutes + 60 * hours) - (t.minutes + 60 * t.hours)) % 60;
    diff.hours = ((minutes + 60 * hours) - (t.minutes + 60 * t.hours)) / 60;
    return diff;
}
Time Time::operator*(double mult) const
{
    Time result;
    long totalminutes = hours * mult * 60 + minutes * mult;
    result.hours = totalminutes / 60;
    result.minutes = totalminutes % 60;
    return result;
}
void Time::Show() const
{
    std::cout << hours << " hours, " << minutes << " minutes\n";
}

// usetime.cpp -- using the first draft of the Time class
// compile usetime0.cpp and mytime0.cpp together
#include <iostream>
#include "mytime.h"
int main()
{
    Time planning;
    Time coding(2, 40);
    Time fixing(5, 55);
    Time total;

    std::cout << "planning time =\t"; // время на планирование
    planning.Show();
 
    std::cout << "coding time =\t";   // время на кодирование
    coding.Show();
    
    std::cout << "fixing time =\t";   // время на исправление
    fixing.Show();

    // total = coding.Sum(fixing);  // кодирование + исправление
    total = coding + fixing;  // нотация с операцией; можно заменить нотацией с функцией:
    // total = coding.operator+(fixing);
    // std::cout << "coding.Sum(fixing) = ";
    std::cout << "coding + fixing = ";
  	total.Show();

    Time morefixing(3, 28);   // дополнительное время на исправление
    std::cout << "more fixing time = ";
    morefixing.Show();

    total = morefixing.operator+(total);  // нотацией с функцией
    std::cout << "morefixing.operator+(total) =\t";
    total.Show();
    std::cout << std::endl;

    Time weeding(4, 35);
    Time waxing(2, 47);
    Time diff;
    Time adjusted;
    std::cout << "weeding time =\t";   // время на подготовку
    weeding.Show();

    std::cout << "waxing time =\t";    // полезное время
    waxing.Show ();

    std::cout << "total work time = ";
    total = weeding + waxing;
    total.Show();

    diff = weeding - waxing;           // используется operator- ()
    std::cout << "weeding time - waxing time = ";
    diff.Show();

    adjusted = total * 1.5;
    std::cout << "adjusted work time =\t";
    adjusted.Show ();
    // std::cin.get();
    return 0;
}
/*	Друзья
 Существует три разновидности друзей:
• дружественные функции;
• дружественные классы;
• дружественные функции-члены.
 Объявляя функцию другом класса, вы позволяете ей иметь те же привилегии 
доступа, что и у функций-членов класса.
 Функция, не являющаяся членом, не вызывается через объект. Вместо этого 
все значения, которые она использует, включая объекты, передаются в виде 
явных аргументов. Таким образом, компилятор может представить выражение */
А = 2.75 * В; // не соответствует функции-члену
// в виде вызова функции, не являющейся членом:
А = operator*(2.75, В);
// Эта функция должна иметь следующий прототип:
Time operator*(double m, const Time & t) ;
/* Благодаря этой функции, не являющейся членом, которая перегружает операцию,
левый операнд выражения соответствует первому аргументу функции, а правый —
второму. Между тем, исходная функция-член имеет дело с операндами в обратном 
порядке — т.е. значение типа Time умножается на значение типа double.
 Существует специальная категория функций, не являющихся членами,
называемая друзьями, которая имеет доступ к закрытым данным класса: */
friend Time operator*(double m, const Time & t); // размещается в объявлении класса
/* На основе этого прототипа можно сделать два вывода.
• Несмотря на то что функция operator* () присутствует в объявлении класса,
она не является функцией-членом класса. Поэтому она не вызывается через 
операцию членства (.).
• Несмотря на то что функция operator* () не является функцией-членом класса,
она имеет те же права доступа, что и функции-члены.
 Определения функции: */
Time operator*(double m, const Time & t) // friend в определении не используется
{
	Time result;
	long totalminutes = t.hours * mult * 60 +t. minutes * mult;
	result.hours   = totalminutes / 60;
	result.minutes = totalminutes % 60;
	return result;
}
// С таким объявлением и определением оператор:
А = 2.75 * В;
/* транслируется в следующий вызов только что определенной дружественной функции,
не являющейся членом: */
А = operator*(2.75, В);
/* Дружественная функция класса — это функция, не являющаяся членом, но которая 
имеет те же права доступа, что и функция-член.
 Используя и дружественную функцию, и функцию-член, обе операции можно выразить в 
одном пользовательском интерфейсе. Следует помнить, что только объявление 
класса определяет, какие функции являются дружественными, т.е. объявление класса 
по-прежнему управляет тем, каким функциям разрешен доступ к закрытым данным. 
Методы класса и друзья — это просто два разных механизма выражения интерфейса класса.
 Эту конкретную дружественную функцию можно реализовать через вызов функции-члена, 
изменив ее определение так, чтобы перед умножением она сначала меняла местами 
переданные операнды: */
Time operator*(double m, const Time & t)
{
	return t * m; // используется t.operator*(m)
}
/* Исходная версия имеет явный доступ к t.minutes и t.hours, поэтому должна
быть другом. Показанная выше версия только использует объект t типа Time как 
единое целое, позволяя функции-члену работать с закрытыми значениями, поэтому 
такая функция не обязана быть другом. Однако, несмотря на это, все же имеет смысл
сделать эту версию также дружественной. Самое главное, что это делает ее частью
официального интерфейса класса. И второе: если вы позже столкнетесь с 
необходимостью иметь прямой доступ к закрытым данным, то должны будете изменить 
только определение функции, не затрагивая прототип класса.
	Общий вид друга: перегрузка операции <<
	Первая версия перегрузки операции <<
 За счет использования дружественной функции операцию можно перегрузить, 
как показано ниже: */
void operator<<(ostream & os, const Time & t)
{
	os << t.hours << " hours, " << t.minutes << " minutes";
}
// Это позволит написать следующий код:
cout << trip;
// который отобразит данные в таком формате:
4 hours, 23 minutes
/* В новом объявлении класса Time функция operator<< () сделана дружественной функцией 
класса Time. Однако эта функция, хотя и не "враждебна" классу ostream, дружественной
по отношению к нему не является, функция operator<< () принимает аргументы ostream
и Time, поэтому может показаться, что она должна быть дружественной по отношению к
обоим классам. Но если вы посмотрите на код этой функции, то увидите, что она получает
доступ к индивидуальным членам объекта Time, но использует объект ostream только как
единое целое. Поскольку operator<< () обращается к закрытым членам Time напрямую,
она должна быть другом класса Time. Так как она не имеет доступа к закрытым членам клас-
са ostream, то другом этого класса ей быть не нужно. И это замечательно, поскольку озна-
чает, что изменять определение ostream не понадобится.
 Обратите внимание, что новое определение operator<< () принимает ссылку на 
объект os типа ostream в качестве первого аргумента. Обычно os является ссылкой на 
объект cout, как это имеет место в выражении cout << trip. Однако эту операцию можно
использовать с другими объектами ostream; в этом случае os будет ссылаться на них.	
 Вызов cout << trip должен использовать сам объект cout, а не его копию, поэтому 
 функция передает данный объект по ссылке, а не по значению. То есть выражение
cout << trip делает os псевдонимом cout.
	Вторая версия перегрузки операции <<
С представленной выше реализацией связана одна проблема. Операторы вроде 
показанного ниже работают хорошо: */
cout << trip;
/* Но данная реализация не позволяет применять переопределенную операцию <<
так, как это обычно делается при работе с cout: */
cout << "Trip time: " << trip << " (Tuesday) \n"; // так не получится
// Предположим, что есть следующие операторы:
int х = 5;
int у = 8;
cout << х << у;
// C++ читает выражение вывода слева направо, подразумевая следующий эквивалент:
(cout << х) << у; /* Оператор вывода требует, чтобы все выражение (cout << х) 
было типа ostream, поскольку оно расположено слева от << у. Следовательно, 
класс ostream реализует функцию operator<<() так, что она возвращает ссылку 
на объект ostream. В частности, в данном случае она возвращает ссылку на 
вызывающий объект cout. Таким образом, выражение (cout << х) само по себе является 
объектом cout типа ostream и может находиться в левой части операции <<.
 Тот же самый подход можно применить с дружественной функцией. Понадобится лишь 
изменить функцию operator<< () так, чтобы она возвращала ссылку на объект ostream: */
ostream & operator << (ostream & os, const Time & t)
{
	os << t.hours << "hours, " << t.minutes << "minutes";
	return os;
}
/* Типом возврата является */ ostream &. /* Это означает возврат 
функцией ссылки на объект ostream. Поскольку программа передает ссылку на объект 
функции в первом аргументе, общий эффект состоит в том, что функция возвращает тот 
самый объект, который ей передан. То есть оператор: */
cout << trip;
// превращается в следующий вызов функции:
operator<<(cout, trip);
// И такой вызов возвращает объект cout. Поэтому теперь работает такой оператор:
cout << "Trip time: " << trip << " (Tuesday)\n"; // теперь работает
/* Первый шаг вызывает конкретное определение операции << из ostream, которое 
отображает строку и возвращает объект cout: */
cout << "Trip time: "
// Поэтому выражение:
cout << "Trip time: " /* отображает строку и затем заменяется типом возврата — 
cout. Это превращает исходный оператор в следующий: */
cout << trip << " (Tuesday)\n";
/* Далее программа использует определение операции << из класса Time для того,
чтобы отобразить значения trip и снова возвратить объект cout. Оператор 
приобретет такой вид: */
cout << " (Tuesday)\n";
/* Программа завершается использованием определения операции << из ostream
для строк, чтобы отобразить результирующую строку.
Интересно, что эта версия operator<< () также может быть применена для вывода в файл:*/
#include <fstream>
ofstream fout;
fout.open("savetime.txt");
Time trip(12, 40);
fout << trip;
// Последний оператор становится таким:
operator<< (fout, trip);
/* Механизм наследования классов позволяет ссылке на ostream обращаться и к объектам 
ostream, и к объектам ofstream.
 В общем случае для перегрузки операции << с целью отображения объекта класса c_name
используется дружественная функция со следующим определением: */
ostream & operator<<(ostream & os, const c_name & obj)
{
	os << ... ; // отображение содержимого объекта
	return os;
}
/* Ключевое слово friend используется только в прототипе, представленном в объявлении
класса. В определении функции оно указывается, только если не присутствует в самом прототипе.*/
// mytime3.h -- Time class with friends
#ifndef MYTIME3_H_
#define MYTIME3_H_
#include <iostream>

class Time
{
private:
    int hours;
    int minutes;
public:
    Time();
    Time(int h, int m = 0);
    void AddMin(int m);
    void AddHr(int h);
    void Reset(int h = 0, int m = 0);
    Time operator+(const Time & t) const;
    Time operator-(const Time & t) const;
    Time operator*(double n) const;
    friend Time operator*(double m, const Time & t) { return t * m; }  // встроенное определение
    friend std::ostream & operator<<(std::ostream & os, const Time & t);

};
#endif
/* В файле реализации методы используют квалификатор Time::, тогда как 
дружественные функции — нет: */
// mytime3.cpp  -- implementing Time methods
#include "mytime3.h"

Time::Time()
{
    hours = minutes = 0;
}
Time::Time(int h, int m )
{
    hours = h;
    minutes = m;
}
void Time::AddMin(int m)
{
    minutes += m;
    hours += minutes / 60;
    minutes %= 60;
}
void Time::AddHr(int h)
{
    hours += h;
}
void Time::Reset(int h, int m)
{
    hours = h;
    minutes = m;
}
Time Time::operator+(const Time & t) const
{
    Time sum;
    sum.minutes = minutes + t.minutes;
    sum.hours = hours + t.hours + sum.minutes / 60;
    sum.minutes %= 60;
    return sum;
}
Time Time::operator-(const Time & t) const
{
    Time diff;
    int tot1, tot2;
    tot1 = t.minutes + 60 * t.hours;
    tot2 = minutes + 60 * hours;
    diff.minutes = (tot2 - tot1) % 60;
    diff.hours = (tot2 - tot1) / 60;
    return diff;
}
Time Time::operator*(double mult) const
{
    Time result;
    long totalminutes = hours * mult * 60 + minutes * mult;
    result.hours = totalminutes / 60;
    result.minutes = totalminutes % 60;
    return result;
}
std::ostream & operator<<(std::ostream & os, const Time & t)
{
    os << t.hours << " hours, " << t.minutes << " minutes";
    return os; 
}
/* Формально файл usetime3.срр не должен включать заголовочный файл iostream,
поскольку mytime3.h уже включает его. Однако, как пользователь класса Time, Вы не
обязаны знать, какие заголовочные файлы включены в код класса, поэтому в вашей
ответственности включать эти файлы, если код в них нуждается. */
// usetime3.cpp -- using the fourth draft of the Time class
// compile usetime3.cpp and mytime3.cpp together
#include <iostream>
#include "mytime3.h"

int main()
{
    using std::cout;
    using std::endl;
    Time aida(3, 35);
    Time tosca(2, 48);
    Time temp;

    cout << "Aida and Tosca:\n";
    cout << aida << "; " << tosca << endl;
    temp = aida + tosca;	// operator+()
    cout << "Aida + Tosca: " << temp << endl;
    temp = aida* 1.17;		// member operator*()
    cout << "Aida * 1.17: " << temp << endl;
    cout << "10.0 * Tosca: " << 10.0 * tosca << endl;
	// std::cin.get();
    return 0; 
}
/*	Перегруженные операции:
	сравнение функций-членов и функций, не являющихся членами.
 При реализации перегрузки многих операций имеется выбор между функциями-членами 
и функциями, не являющимися членами. */
Time operator+ (const Time & t) const;	// Вариант с функцией-членом
// Вместо этого класс может использовать такой прототип:
friend Time operator+(const Time & tl, const Time & t2); /* Вариант с функцией, не 
являющейся членом.
 Операция сложения требует два операнда. В версии с функцией-членом один 
операнд передается неявно, через указатель this, а второй — явно, как аргумент функции.
В версии с дружественной функцией оба параметра передаются в качестве аргументов
функции. Версия перегруженной операции с функцией, не являющейся членом, требует столько 
формальных параметров, сколько операндов есть у данной операции. Версия с использованием
функции-члена требует на один параметр меньше, поскольку один операнд передается 
неявно как вызывающий объект.
 Оба прототипа соответствуют выражению Т2 + ТЗ, где Т2 и ТЗ — объекты типа Time. 
To есть компилятор может преобразовать оператор */
Т1 = Т2 + Т3;
// в один из следующих:
Т1 = T2.operator+(Т3);	// функция-член
Т1 = operator+(T2, Т3);	// функция, не являющаяся членом
/* Помните, что при определении этой операции Вы должны выбрать одну или 
другую форму, но не обе сразу. Поскольку обеим формам соответствует одно и то же 
выражение, определение обеих форм одновременно ведет к неоднозначности и ошибке
компиляции.
	Класс Vector
 Во-первых, вектор нельзя представить одиночным числом, поэтому имеет смысл 
создать для этого класс. Во-вторых, векторы поддерживают аналоги обычных 
арифметических операций, таких как сложение и вычитание. 
 Для описания двумерного вектора понадобятся два числа, однако есть выбор — 
что именно будут означать эти два числа:
• вектор можно представить модулем (длиной) и направлением (углом);
• вектор можно представить с помощью компонент х и у.
 Иногда удобнее одна форма, иногда — другая, поэтому включим в описание 
класса оба представления. Спроектируем класс так, что если Вы измените одно из 
представлений вектора, то второе будет изменяться автоматически. Возможность 
обеспечить такое интеллектуальное поведение объекта — еще одно преимущество 
классов C++. */
// vect.h -- Vector class with <<, mode state
#ifndef VECTOR_H_
#define VECTOR_H_
#include <iostream>
namespace VECTOR
{
    class Vector
    {
    public:
        enum Mode {RECT, POL};  // RECT — для режима прямоугольных координат, 
    private:                    // POL  — для режима полярных координат.
        // Закрытые данные-члены
        double x;   // горизонтальное значение
        double y;   // вертикальное значение
        double mag; // длина вектора
        double ang; // направление вектора в градусах
        Mode mode;  // RECT или POL
        // Закрытые методы для установки значений:
        void set_mag() { mag = sqrt(x * x + y * y); }; // Вычисляет модуль из х и у
        void set_ang() {if (x == 0.0 && y == 0.0) ang = 0.0;
                        else ang = atan2(y, x); };  
        void set_x() { x = mag * cos(ang); };       // Устанавливает х по полярным координатам
        void set_y() { y = mag * sin(ang); };       // Устанавливает у по полярным координатам
    public:
        Vector();
        Vector(double n1, double n2, Mode form = RECT);
        void reset(double n1, double n2, Mode form = RECT);
        ~Vector();
        double xval()   const {return x; }    // сообщает значение х
        double yval()   const {return y; }    // сообщает значение у
        double magval() const {return mag; }  // сообщает модуль
        double angval() const {return ang; }  // сообщает угол
        void polar_mode();  // устанавливает режим в POL
        void rect_mode();   // устанавливает режим в RECT
    // Перегрузка операций
        Vector operator+(const Vector & b) const;
        Vector operator-(const Vector & b) const;
        Vector operator-() const;
        Vector operator*(double n) const;
    // Друзья
        friend Vector operator*(double n, const Vector & a);
        friend std::ostream & operator<<(std::ostream & os, const Vector & v);
    };
}   // end namespace VECTOR
#endif
/* Код в листинге использует открытую природу пространств имен для
добавления объявлений методов к пространству имен VECTOR. Следует отметить, что
конструкторы и функция reset() устанавливают значения как для прямоугольного,
так и для полярного представления вектора. Таким образом, оба набора значений
становятся доступными немедленно, без дополнительных вычислений. */
// vect.cpp -- methods for the Vector class
#include <cmath>
#include "vect.h"   // включает <iostream>
using std::sqrt;
using std::sin;
using std::cos;
using std::atan;
using std::atan2;
using std::cout;

namespace VECTOR
{
    // Вычисляет количество градусов в одном радиане:
    const double Rad_to_deg = 45.0 / atan(1.0); // приблизительно 57.2957795130823
    // public methods
    Vector::Vector()    // конструктор по умолчанию
    {
        x = y = mag = ang = 0.0;
        mode = RECT;
    }
/* Конструирует вектор по прямоугольным координатам, если form равно RECT
        (по умолчанию), или по полярным координатам, если form равно POL: */
    Vector::Vector(double n1, double n2, Mode form)
    {
        mode = form;
        if (form == RECT)
         {
            x = n1;
            y = n2;
            set_mag();
            set_ang();
        }
        else if (form == POL)
        {
            mag = n1;
            ang = n2 / Rad_to_deg;
            set_x();
            set_y();
        }
        else
        {   // Некорректный третий аргумент Vector(); вектор устанавливается в 0
            cout << "Incorrect 3rd argument to Vector() -- ";
            cout << "vector set to 0\n";
            x = y = mag = ang = 0.0;
            mode = RECT;
        }
    }
    /* Устанавливает вектор по прямоугольным координатам, если form равно RECT
        (по умолчанию), или по полярным координатам, если если form равно POL: */
    void Vector:: reset(double n1, double n2, Mode form)
    {
        mode = form;
        if (form == RECT)
        {
            x = n1;
            y = n2;
            set_mag();
            set_ang();
        }
        else if (form == POL)
        {
            mag = n1;
            ang = n2 / Rad_to_deg;
            set_x();
            set_y();
        }
        else
        {
            cout << "Incorrect 3rd argument to Vector() -- ";
            cout << "vector set to 0\n";
            x = y = mag = ang = 0.0;
            mode = RECT;
        }
    }
    Vector::~Vector() {}        // деструктор
    void Vector::polar_mode()   // устанавливает режим полярных координат
    {
        mode = POL;
    }
    void Vector::rect_mode()    // устанавливает режим прямоугольных координат
    {
        mode = RECT;
    }
    // Перегрузка операций.
    // Сложение двух векторов:
    Vector Vector::operator+(const Vector & b) const
    {
        return Vector(x + b.x, y + b.y);
    }
    // Вычитание вектора b из a:
    Vector Vector::operator-(const Vector & b) const
    {
        return Vector(x - b.x, y - b.y);
    }
    // Смена знака вектора на противоположный:
    Vector Vector::operator-() const
    {
        return Vector(-x, -y);
    }
    // Умножение вектора на n:
    Vector Vector::operator*(double n) const
    {
        return Vector(n * x, n * y);
    }
    // Дружественные методы.
    // Умножение n на вектор a:
    Vector operator*(double n, const Vector & a)
    {
        return a * n;
    }
    /* Отображает прямоугольные координаты, если mode равно RECT,
        или отображает полярные координаты, если mode равно POL: */
    std::ostream & operator<<(std::ostream & os, const Vector & v)
    {
        if (v.mode == Vector::RECT)
            os << "(x,y) = (" << v.x << ", " << v.y << ")";
        else if (v.mode == Vector::POL)
        {
            os << "(m,a) = (" << v.mag << ", "
               << v.ang * Rad_to_deg   << ")";
        }
        else
             os << "Vector object mode is invalid";
        return os; 
    }
}  // end namespace VECTOR
/* Спроектировать класс Vector можно по-разному. Например, объект может 
хранить прямоугольные координаты и не хранить полярные. В этом случае вычисление
полярных координат может быть помещено в методы magval() и angval(). Метод reset() 
в этом случае не нужен.
 Предположим, что shove — это объект типа Vector, и есть такой код: */
shove.reset(100, 300);
// Тот же самый результат можно получить с помощью следующего конструктора:
shove = Vector (100, 300);
/* Однако метод reset() изменяет содержимое shove напрямую, в то время как 
применение конструктора добавляет несколько дополнительных шагов по созданию 
временного объекта и присваиванию его shove. Такое проектное решение следует традиции 
ООП, которая заключается в том, чтобы иметь интерфейс класса, сконцентрированный на 
сущностях (абстрактную модель), при этом скрывая детали. 












