/*	Перегрузка операций — это пример полиморфизма C++.
Для перегрузки операции используется специальная форма функции, называемая
функцией операции. */
operator op (список-аргументов) // ор — это символ перегружаемой операции
operator+ () // перегружает операцию +, а
operator* () // операцию *.
// Операция ор должна быть допустимой операцией C++, а не произвольным символом.
operator@ () // не получится, т.к. в C++ нет операции @
operator[]() // перегружает операцию [], поскольку [] — операция индексации массивов.

/* Предположим, что имеется класс Salesperson, в котором определена функция-член 
operator+ () для перегрузки операции +. Тогда если district2, sid и sara —
объекты класса Salesperson, можно написать следующее выражение: */
district2 = sid + sara;
/* Компилятор, распознав операцию как относящуюся к классу Salesperson, 
заменит ее вызовом соответствующей функции операции: */
district2 = sid.operator+(sara);
/* Функция затем использует объект sid неявно (поскольку она вызывает метод), а
объект sara — явно (т.к. он передается в виде аргумента) для вычисления суммы, 
возвращаемой в результате. 
/* Имя функции operator* () позволяет вызывать ее как в нотации
с функцией, так и в нотации с операцией. Компилятор использует тип операнда для
определения того, что необходимо делать: */
int a, b, с;
Time А, В, С;
с = а + b; // используется сложение значений int
С = А + В; // используется сложение, определенное для объектов Time
/* А можно ли складывать более двух объектов? Например, если t1, t2, t3 и t4 
являются объектами класса Time, будет ли допустимым следующий оператор: */
t4 = t1 + t2 + t3; // правильно ли это?
/* Чтобы ответить на этот вопрос, нужно посмотреть, как это выражение 
транслируется в вызовы функций. Поскольку сложение —
операция, выполняемая слева 
направо, первая трансляция дает: */
t4 = t1.operator+ (t2 + t3) ; // правильно ли это?
// Затем аргумент функции также транслируется в вызов функции, и мы получаем:
t4 = t1.operator+(t2.operator+ (t3)); // правильно ли это?
/* Да, верно. Вызов функции t2.operator* (t3) возвращает объект Time, 
представляющий собой сумму t2 и t3. Этот объект затем передается вызову
t1.operator+ () и этот вызов возвращает сумму t1 и объекта Time, который 
представляет сумму t2 и t3. Финальное возвращаемое значение является
суммой t1, t2 и t3, что и ожидалось.
	Ограничения перегрузки
• Перегруженные операции должны иметь как минимум один операнд типа, 
определяемого пользователем. Это предотвращает перегрузку операций, 
работающих со стандартными типами. То есть переопределить операцию "минус" (-)
так, чтобы она вычисляла сумму двух вещественных чисел вместо разности, не
получится. Это ограничение сохраняет здравый смысл, заложенный в 
программу, хотя и несколько препятствует полету творчества.
• Вы не можете использовать операцию в такой манере, которая нарушает 
правила синтаксиса исходной операции.
Например, нельзя перегрузить операцию взятия модуля (%) так, чтобы она 
применялась с одним операндом: */
int x;
Time shiva;
% х; //не допускается для операции взятия модуля
% shiva; //не допускается для перегруженной операции
/* Аналогично, не допускается изменение приоритетов операций. Поэтому, если
вы перегрузите операцию сложения для класса, то новая операция будет иметь
тот же приоритет, что и обычное сложение.
• Вы не можете определять новые символы операций. Например, определить
функцию operator** () для создания операции возведения в степень не 
получится.
• Нельзя перегружать следующие операции:
Операция:		Описание: */
sizeof	// Операция sizeof
	.	// Операция членства
	.*	// Операция указателя на член
	::	// Операция разрешения контекста
	:?	// Условная операция
typeid	// Операция RTTI (runtime type identification — определение типа во время выполнения)
const_cast 	// Операция приведения типа
dynamic_cast // Операция приведения типа
reinterpret_cast // Операция приведения типа
static_cast // Операция приведения типа
/* Тем не менее, операции, перечисленные в табл. 11.1, по-прежнему доступны для
перегрузки.
• Большинство операций из табл. 11.1 допускают перегрузку за счет 
использования как функций-членов, так и функций, не являющихся членами. Однако для
перегрузки перечисленных ниже операций можно использовать только функции-члены: 
Операция:		Описание: */
	= 	// Операция присваивания
	() 	// Операция вызова функции
	[]	// Операция индексации
	->	// Операция доступа к членам класса через указатель
	
// mytime.h -- Time class before operator overloading
#ifndef MYTIME_H_
#define MYTIME_H_
class Time
{
private:
    int hours;
    int minutes;
public:
    Time();
    Time(int h, int m = 0);
    void AddMin(int m);
    void AddHr(int h);
    void Reset(int h = 0, int m = 0);
    //const Time Sum(const Time & t) const;
    Time operator+(const Time & t) const;
    Time operator-(const Time & t) const;
    Time operator*(double n) const;
    void Show() const;
};
#endif

// mytime.cpp  -- implementing Time methods
#include <iostream>
#include "mytime.h"
Time::Time()
{
    hours = minutes = 0;
}
Time::Time(int h, int m )
{
    hours = h;
    minutes = m;
}
void Time::AddMin(int m)
{
    minutes += m;
    hours += minutes / 60;
    minutes %= 60;
}
void Time::AddHr(int h)
{
    hours += h;
}
void Time::Reset(int h, int m)
{
    hours = h;
    minutes = m;
}
//const Time Time::Sum(const Time & t) const
Time Time::operator+(const Time & t) const
{
    Time sum;
    sum.minutes = (minutes + t.minutes) % 60;
    sum.hours = hours + t.hours + (minutes + t.minutes) / 60;
    return sum;
}
Time Time::operator-(const Time & t) const
{
    Time diff;
    diff.minutes = ((minutes + 60 * hours) - (t.minutes + 60 * t.hours)) % 60;
    diff.hours = ((minutes + 60 * hours) - (t.minutes + 60 * t.hours)) / 60;
    return diff;
}
Time Time::operator*(double mult) const
{
    Time result;
    long totalminutes = hours * mult * 60 + minutes * mult;
    result.hours = totalminutes / 60;
    result.minutes = totalminutes % 60;
    return result;
}
void Time::Show() const
{
    std::cout << hours << " hours, " << minutes << " minutes\n";
}

// usetime.cpp -- using the first draft of the Time class
// compile usetime0.cpp and mytime0.cpp together
#include <iostream>
#include "mytime.h"
int main()
{
    Time planning;
    Time coding(2, 40);
    Time fixing(5, 55);
    Time total;

    std::cout << "planning time =\t"; // время на планирование
    planning.Show();
 
    std::cout << "coding time =\t";   // время на кодирование
    coding.Show();
    
    std::cout << "fixing time =\t";   // время на исправление
    fixing.Show();

    // total = coding.Sum(fixing);  // кодирование + исправление
    total = coding + fixing;  // нотация с операцией; можно заменить нотацией с функцией:
    // total = coding.operator+(fixing);
    // std::cout << "coding.Sum(fixing) = ";
    std::cout << "coding + fixing = ";
  	total.Show();

    Time morefixing(3, 28);   // дополнительное время на исправление
    std::cout << "more fixing time = ";
    morefixing.Show();

    total = morefixing.operator+(total);  // нотацией с функцией
    std::cout << "morefixing.operator+(total) =\t";
    total.Show();
    std::cout << std::endl;

    Time weeding(4, 35);
    Time waxing(2, 47);
    Time diff;
    Time adjusted;
    std::cout << "weeding time =\t";   // время на подготовку
    weeding.Show();

    std::cout << "waxing time =\t";    // полезное время
    waxing.Show ();

    std::cout << "total work time = ";
    total = weeding + waxing;
    total.Show();

    diff = weeding - waxing;           // используется operator- ()
    std::cout << "weeding time - waxing time = ";
    diff.Show();

    adjusted = total * 1.5;
    std::cout << "adjusted work time =\t";
    adjusted.Show ();
    // std::cin.get();
    return 0;
}
/*	Друзья
 Существует три разновидности друзей:
• дружественные функции;
• дружественные классы;
• дружественные функции-члены.
 Объявляя функцию другом класса, вы позволяете ей иметь те же привилегии 
доступа, что и у функций-членов класса.
 Функция, не являющаяся членом, не вызывается через объект. Вместо этого 
все значения, которые она использует, включая объекты, передаются в виде 
явных аргументов. Таким образом, компилятор может представить выражение */
А = 2.75 * В; // не соответствует функции-члену
// в виде вызова функции, не являющейся членом:
А = operator*(2.75, В);
// Эта функция должна иметь следующий прототип:
Time operator*(double m, const Time & t) ;
/* Благодаря этой функции, не являющейся членом, которая перегружает операцию,
левый операнд выражения соответствует первому аргументу функции, а правый —
второму. Между тем, исходная функция-член имеет дело с операндами в обратном 
порядке — т.е. значение типа Time умножается на значение типа double.
 Существует специальная категория функций, не являющихся членами,
называемая друзьями, которая имеет доступ к закрытым данным класса: */
friend Time operator*(double m, const Time & t); // размещается в объявлении класса
/* На основе этого прототипа можно сделать два вывода.
• Несмотря на то что функция operator* () присутствует в объявлении класса,
она не является функцией-членом класса. Поэтому она не вызывается через 
операцию членства (.).
• Несмотря на то что функция operator* () не является функцией-членом класса,
она имеет те же права доступа, что и функции-члены.
 Определения функции: */
Time operator*(double m, const Time & t) // friend в определении не используется
{
	Time result;
	long totalminutes = t.hours * mult * 60 +t. minutes * mult;
	result.hours   = totalminutes / 60;
	result.minutes = totalminutes % 60;
	return result;
}
// С таким объявлением и определением оператор:
А = 2.75 * В;
/* транслируется в следующий вызов только что определенной дружественной функции,
не являющейся членом: */
А = operator*(2.75, В);
/* Дружественная функция класса — это функция, не являющаяся членом, но которая 
имеет те же права доступа, что и функция-член.
 Используя и дружественную функцию, и функцию-член, обе операции можно выразить в 
одном пользовательском интерфейсе. Следует помнить, что только объявление 
класса определяет, какие функции являются дружественными, т.е. объявление класса 
по-прежнему управляет тем, каким функциям разрешен доступ к закрытым данным. 
Методы класса и друзья — это просто два разных механизма выражения интерфейса класса.
 Эту конкретную дружественную функцию можно реализовать через вызов функции-члена, 
изменив ее определение так, чтобы перед умножением она сначала меняла местами 
переданные операнды: */
Time operator*(double m, const Time & t)
{
	return t * m; // используется t.operator*(m)
}
/* Исходная версия имеет явный доступ к t.minutes и t.hours, поэтому должна
быть другом. Показанная выше версия только использует объект t типа Time как 
единое целое, позволяя функции-члену работать с закрытыми значениями, поэтому 
такая функция не обязана быть другом. Однако, несмотря на это, все же имеет смысл
сделать эту версию также дружественной. Самое главное, что это делает ее частью
официального интерфейса класса. И второе: если вы позже столкнетесь с 
необходимостью иметь прямой доступ к закрытым данным, то должны будете изменить 
только определение функции, не затрагивая прототип класса.
	Общий вид друга: перегрузка операции <<
	Первая версия перегрузки операции <<
 За счет использования дружественной функции операцию можно перегрузить, 
как показано ниже: */
void operator<<(ostream & os, const Time & t)
{
	os << t.hours << " hours, " << t.minutes << " minutes";
}
// Это позволит написать следующий код:
cout << trip;
// который отобразит данные в таком формате:
4 hours, 23 minutes
/* В новом объявлении класса Time функция operator<< () сделана дружественной функцией 
класса Time. Однако эта функция, хотя и не "враждебна" классу ostream, дружественной
по отношению к нему не является, функция operator<< () принимает аргументы ostream
и Time, поэтому может показаться, что она должна быть дружественной по отношению к
обоим классам. Но если вы посмотрите на код этой функции, то увидите, что она получает
доступ к индивидуальным членам объекта Time, но использует объект ostream только как
единое целое. Поскольку operator<< () обращается к закрытым членам Time напрямую,
она должна быть другом класса Time. Так как она не имеет доступа к закрытым членам клас-
са ostream, то другом этого класса ей быть не нужно. И это замечательно, поскольку озна-
чает, что изменять определение ostream не понадобится.
 Обратите внимание, что новое определение operator<< () принимает ссылку на 
объект os типа ostream в качестве первого аргумента. Обычно os является ссылкой на 
объект cout, как это имеет место в выражении cout << trip. Однако эту операцию можно
использовать с другими объектами ostream; в этом случае os будет ссылаться на них.	
 Вызов cout << trip должен использовать сам объект cout, а не его копию, поэтому 
 функция передает данный объект по ссылке, а не по значению. То есть выражение
cout << trip делает os псевдонимом cout.
	Вторая версия перегрузки операции <<
С представленной выше реализацией связана одна проблема. Операторы вроде 
показанного ниже работают хорошо: */
cout << trip;
/* Но данная реализация не позволяет применять переопределенную операцию <<
так, как это обычно делается при работе с cout: */
cout << "Trip time: " << trip << " (Tuesday) \n"; // так не получится
// Предположим, что есть следующие операторы:
int х = 5;
int у = 8;
cout << х << у;
// C++ читает выражение вывода слева направо, подразумевая следующий эквивалент:
(cout << х) << у; /* Оператор вывода требует, чтобы все выражение (cout << х) 
было типа ostream, поскольку оно расположено слева от << у. Следовательно, 
класс ostream реализует функцию operator<<() так, что она возвращает ссылку 
на объект ostream. В частности, в данном случае она возвращает ссылку на 
вызывающий объект cout. Таким образом, выражение (cout << х) само по себе является 
объектом cout типа ostream и может находиться в левой части операции <<.
 Тот же самый подход можно применить с дружественной функцией. Понадобится лишь 
изменить функцию operator<< () так, чтобы она возвращала ссылку на объект ostream: */
ostream & operator << (ostream & os, const Time & t)
{
	os << t.hours << "hours, " << t.minutes << "minutes";
	return os;
}
/* Типом возврата является */ ostream &. /* Это означает возврат 
функцией ссылки на объект ostream. Поскольку программа передает ссылку на объект 
функции в первом аргументе, общий эффект состоит в том, что функция возвращает тот 
самый объект, который ей передан. То есть оператор: */
cout << trip;
// превращается в следующий вызов функции:
operator<<(cout, trip);
// И такой вызов возвращает объект cout. Поэтому теперь работает такой оператор:
cout << "Trip time: " << trip << " (Tuesday)\n"; // теперь работает
/* Первый шаг вызывает конкретное определение операции << из ostream, которое 
отображает строку и возвращает объект cout: */
cout << "Trip time: "
// Поэтому выражение:
cout << "Trip time: " /* отображает строку и затем заменяется типом возврата — 
cout. Это превращает исходный оператор в следующий: */
cout << trip << " (Tuesday)\n";
/* Далее программа использует определение операции << из класса Time для того,
чтобы отобразить значения trip и снова возвратить объект cout. Оператор 
приобретет такой вид: */
cout << " (Tuesday)\n";
/* Программа завершается использованием определения операции << из ostream
для строк, чтобы отобразить результирующую строку.
Интересно, что эта версия operator<< () также может быть применена для вывода в файл:*/
#include <fstream>
ofstream fout;
fout.open("savetime.txt");
Time trip(12, 40);
fout << trip;
// Последний оператор становится таким:
operator<< (fout, trip);
/* Механизм наследования классов позволяет ссылке на ostream обращаться и к объектам 
ostream, и к объектам ofstream.
 В общем случае для перегрузки операции << с целью отображения объекта класса c_name
используется дружественная функция со следующим определением: */
ostream & operator<<(ostream & os, const c_name & obj)
{
	os << ... ; // отображение содержимого объекта
	return os;
}
/* Ключевое слово friend используется только в прототипе, представленном в объявлении
класса. В определении функции оно указывается, только если не присутствует в самом прототипе.*/
// mytime3.h -- Time class with friends
#ifndef MYTIME3_H_
#define MYTIME3_H_
#include <iostream>

class Time
{
private:
    int hours;
    int minutes;
public:
    Time();
    Time(int h, int m = 0);
    void AddMin(int m);
    void AddHr(int h);
    void Reset(int h = 0, int m = 0);
    Time operator+(const Time & t) const;
    Time operator-(const Time & t) const;
    Time operator*(double n) const;
    friend Time operator*(double m, const Time & t) { return t * m; }  // встроенное определение
    friend std::ostream & operator<<(std::ostream & os, const Time & t);

};
#endif
/* В файле реализации методы используют квалификатор Time::, тогда как 
дружественные функции — нет: */
// mytime3.cpp  -- implementing Time methods
#include "mytime3.h"

Time::Time()
{
    hours = minutes = 0;
}
Time::Time(int h, int m )
{
    hours = h;
    minutes = m;
}
void Time::AddMin(int m)
{
    minutes += m;
    hours += minutes / 60;
    minutes %= 60;
}
void Time::AddHr(int h)
{
    hours += h;
}
void Time::Reset(int h, int m)
{
    hours = h;
    minutes = m;
}
Time Time::operator+(const Time & t) const
{
    Time sum;
    sum.minutes = minutes + t.minutes;
    sum.hours = hours + t.hours + sum.minutes / 60;
    sum.minutes %= 60;
    return sum;
}
Time Time::operator-(const Time & t) const
{
    Time diff;
    int tot1, tot2;
    tot1 = t.minutes + 60 * t.hours;
    tot2 = minutes + 60 * hours;
    diff.minutes = (tot2 - tot1) % 60;
    diff.hours = (tot2 - tot1) / 60;
    return diff;
}
Time Time::operator*(double mult) const
{
    Time result;
    long totalminutes = hours * mult * 60 + minutes * mult;
    result.hours = totalminutes / 60;
    result.minutes = totalminutes % 60;
    return result;
}
std::ostream & operator<<(std::ostream & os, const Time & t)
{
    os << t.hours << " hours, " << t.minutes << " minutes";
    return os; 
}
/* Формально файл usetime3.срр не должен включать заголовочный файл iostream,
поскольку mytime3.h уже включает его. Однако, как пользователь класса Time, Вы не
обязаны знать, какие заголовочные файлы включены в код класса, поэтому в вашей
ответственности включать эти файлы, если код в них нуждается. */
// usetime3.cpp -- using the fourth draft of the Time class
// compile usetime3.cpp and mytime3.cpp together
#include <iostream>
#include "mytime3.h"

int main()
{
    using std::cout;
    using std::endl;
    Time aida(3, 35);
    Time tosca(2, 48);
    Time temp;

    cout << "Aida and Tosca:\n";
    cout << aida << "; " << tosca << endl;
    temp = aida + tosca;	// operator+()
    cout << "Aida + Tosca: " << temp << endl;
    temp = aida* 1.17;		// member operator*()
    cout << "Aida * 1.17: " << temp << endl;
    cout << "10.0 * Tosca: " << 10.0 * tosca << endl;
	// std::cin.get();
    return 0; 
}
/*	Перегруженные операции:
	сравнение функций-членов и функций, не являющихся членами.
 При реализации перегрузки многих операций имеется выбор между функциями-членами 
и функциями, не являющимися членами. */
Time operator+ (const Time & t) const;	// Вариант с функцией-членом
// Вместо этого класс может использовать такой прототип:
friend Time operator+(const Time & tl, const Time & t2); /* Вариант с функцией, не 
являющейся членом.
 Операция сложения требует два операнда. В версии с функцией-членом один 
операнд передается неявно, через указатель this, а второй — явно, как аргумент функции.
В версии с дружественной функцией оба параметра передаются в качестве аргументов
функции. Версия перегруженной операции с функцией, не являющейся членом, требует столько 
формальных параметров, сколько операндов есть у данной операции. Версия с использованием
функции-члена требует на один параметр меньше, поскольку один операнд передается 
неявно как вызывающий объект.
 Оба прототипа соответствуют выражению Т2 + ТЗ, где Т2 и ТЗ — объекты типа Time. 
To есть компилятор может преобразовать оператор */
Т1 = Т2 + Т3;
// в один из следующих:
Т1 = T2.operator+(Т3);	// функция-член
Т1 = operator+(T2, Т3);	// функция, не являющаяся членом
/* Помните, что при определении этой операции Вы должны выбрать одну или 
другую форму, но не обе сразу. Поскольку обеим формам соответствует одно и то же 
выражение, определение обеих форм одновременно ведет к неоднозначности и ошибке
компиляции.
	Класс Vector
 Во-первых, вектор нельзя представить одиночным числом, поэтому имеет смысл 
создать для этого класс. Во-вторых, векторы поддерживают аналоги обычных 
арифметических операций, таких как сложение и вычитание. 
 Для описания двумерного вектора понадобятся два числа, однако есть выбор — 
что именно будут означать эти два числа:
• вектор можно представить модулем (длиной) и направлением (углом);
• вектор можно представить с помощью компонент х и у.
 Иногда удобнее одна форма, иногда — другая, поэтому включим в описание 
класса оба представления. Спроектируем класс так, что если Вы измените одно из 
представлений вектора, то второе будет изменяться автоматически. Возможность 
обеспечить такое интеллектуальное поведение объекта — еще одно преимущество 
классов C++. */
// vect.h -- Vector class with <<, mode state // Хидер
// vect.h -- Vector class with <<, mode state
#ifndef VECTOR_H_
#define VECTOR_H_
#include <iostream>
#include <cmath>
using std::sqrt;
using std::sin;
using std::cos;
using std::atan;
using std::atan2;

namespace VECTOR
{
    class Vector
    {
    public:
        enum Mode {RECT, POL};  // RECT — для режима прямоугольных координат, 
    private:                    // POL  — для режима полярных координат.
    // Закрытые данные-члены
        double x;   // горизонтальное значение
        double y;   // вертикальное значение
        double mag; // длина вектора (модуль)
        double ang; // отклонение вектора в градусах (угол)
        Mode mode;  // RECT или POL
    // Закрытые методы для установки значений:
        void set_mag() { mag = sqrt(x * x + y * y); }; // Вычисляет модуль из х и у
        void set_ang() {if (x == 0.0 && y == 0.0) ang = 0.0; // Вычисляет отклонение вектора в
                        else ang = atan2(y, x); };           // градусах (угол) между х и у
        void set_x()   { x = mag * cos(ang); };        // Устанавливает х по полярным координатам
        void set_y()   { y = mag * sin(ang); };        // Устанавливает у по полярным координатам
    public:
        Vector();
        Vector    (double n1, double n2, Mode form = RECT);
        void reset(double n1, double n2, Mode form = RECT);
        ~Vector();
    // Встроенные функции:
        double xval()   const { return x; }   // сообщает значение х
        double yval()   const { return y; }   // сообщает значение у
        double magval() const { return mag; } // сообщает модуль (расстояние)
        double angval() const { return ang; } // сообщает угол
		
        void polar_mode();  // устанавливает режим в POL
        void rect_mode();   // устанавливает режим в RECT
    // Перегрузка операций
        Vector operator+(const Vector & b) const;
        Vector operator-(const Vector & b) const;
        Vector operator-() const;
        Vector operator*(double n) const;
    // Друзья
        friend Vector operator*(double n, const Vector & a);
        friend std::ostream & operator<<(std::ostream & os, const Vector & v);
    };
}   // end namespace VECTOR
#endif
/* Код использует открытую природу пространств имен для добавления объявлений 
методов к пространству имен VECTOR. Следует отметить, что конструкторы и функция 
reset() устанавливают значения как для прямоугольного, так и для полярного 
представления вектора. Таким образом, оба набора значений становятся доступными 
немедленно, без дополнительных вычислений. */
// vect.cpp -- methods for the Vector class // Файл реализации класса
// vect.cpp -- methods for the Vector class
#include "vect.h"   // включает <iostream>
namespace VECTOR
{
    // Вычисляет количество градусов в одном радиане:
    const double Rad_to_deg = 45.0 / atan(1.0); // приблизительно 57.2957795130823

    // public methods
    Vector::Vector()    // конструктор по умолчанию
    {
        x = y = mag = ang = 0.0;
        mode = RECT;
    }
/* Конструирует вектор по прямоугольным координатам, если form равно RECT
        (по умолчанию), или по полярным координатам, если form равно POL: */
    Vector::Vector(double n1, double n2, Mode form)
    {
        mode = form;
        if (form == RECT)
         {
            x = n1;
            y = n2;
            set_mag();
            set_ang();
        }
        else if (form == POL)
        {
            mag = n1;
            ang = n2 / Rad_to_deg;  // перевод в градусы
            set_x();
            set_y();
        }
        else
        {   // Некорректный третий аргумент Vector(); вектор устанавливается в 0
            std::cout << "Incorrect 3rd argument to Vector() -- ";
            std::cout << "vector set to 0\n";
            x = y = mag = ang = 0.0;
            mode = RECT;
        }
    }
    /* Устанавливает вектор по прямоугольным координатам, если form равно RECT
        (по умолчанию), или по полярным координатам, если если form равно POL: */
    void Vector:: reset(double n1, double n2, Mode form)
    {
        mode = form;
        if (form == RECT)
         {
            x = n1;
            y = n2;
            set_mag();
            set_ang();
        }
        else if (form == POL)
        {
            mag = n1;
            ang = n2 / Rad_to_deg;  // перевод в градусы
            set_x();
            set_y();
        }
        else
        {   // Некорректный третий аргумент Vector(); вектор устанавливается в 0
            std::cout << "Incorrect 3rd argument to Vector() -- ";
            std::cout << "vector set to 0\n";
            x = y = mag = ang = 0.0;
            mode = RECT;
        }
    }
    Vector::~Vector() {}        // деструктор

    void Vector::polar_mode()   // устанавливает режим полярных координат
    {
        mode = POL;
    }
    void Vector::rect_mode()    // устанавливает режим прямоугольных координат
    {
        mode = RECT;
    }

    // Перегрузка операций.
    // Сложение двух векторов:
    Vector Vector::operator+(const Vector & b) const
    {
        return Vector(x + b.x, y + b.y); // возвращает сконструированный объект Vector
    }
    // Вычитание вектора b из a:
    Vector Vector::operator-(const Vector & b) const
    {
        return Vector(x - b.x, y - b.y);
    }
    // Смена знака вектора на противоположный:
    Vector Vector::operator-() const
    {
        return Vector(-x, -y);
    }
    // Умножение вектора на n:
    Vector Vector::operator*(double n) const
    {
        return Vector(n * x, n * y);
    }

    // Дружественные методы.
    // Умножение n на вектор a:
    Vector operator*(double n, const Vector & a)
    {
        return a * n;
    }
    /* Отображает прямоугольные координаты, если mode равно RECT,
        или отображает полярные координаты, если mode равно POL: */
    std::ostream & operator<<(std::ostream & os, const Vector & v)
    {
        if (v.mode == Vector::RECT)
            os << "(x,y) = (" << v.x << ", " << v.y << ")";
        else if (v.mode == Vector::POL)
        {
            os << "(m,a) = (" << v.mag << ", "
               << v.ang * Rad_to_deg   << ")";
        }
        else
            os << "Vector object mode is invalid"; // недопустимый режим объекта Vector
        return os; 
    }
}  // end namespace VECTOR
/* Спроектировать класс Vector можно по-разному. Например, объект может 
хранить прямоугольные координаты и не хранить полярные. В этом случае вычисление
полярных координат может быть помещено в методы magval() и angval(). Метод reset() 
в этом случае не нужен.
 Предположим, что shove — это объект типа Vector, и есть такой код: */
shove.reset(100, 300);
// Тот же самый результат можно получить с помощью следующего конструктора:
shove = Vector (100, 300);
/* Однако метод reset() изменяет содержимое shove напрямую, в то время как 
применение конструктора добавляет несколько дополнительных шагов по созданию 
временного объекта и присваиванию его shove. Такое проектное решение следует традиции 
ООП, которая заключается в том, чтобы иметь интерфейс класса, сконцентрированный на 
сущностях (абстрактную модель), при этом скрывая детали. Когда вектор выражается в 
компонентной нотации либо в нотации модуля и направления, вторая нотация 
синхронизируется автоматически, и можно в любой момент устанавливать значение вектора 
и опрашивать его в любом из двух форматов.
 Член по имени mode, который управляет тем, какая форма конструктора, метода reset()
и перегруженной операции << будет использоваться. Значение перечисления RECT 
представляет режим прямоугольных координат (режим по умолчанию), a POL — полярных.
Такая переменная-член называется членом состояния, поскольку описывает состояние
объекта. */
Vector folly(3.0, 4.0); // установить х = 3, у = 4
Vector foolery(20.0, 30.0, VECTOR::Vector::POL); // установить mag = 20, ang = 30
/* Поскольку operator<<() — это дружественная функция, не относящаяся к области 
видимости класса, необходимо использовать Vector::RECT, а не просто RECT. Но
функция находится в пространстве имен VECTOR, поэтому применять полностью уточненное 
имя VECTOR::Vector::RECT не нужно.
	Множественные представления и классы.
 Классы хорошо приспосабливаются для представления разных аспектов существования в одном 
объекте. Во-первых, в одном объекте можно сохранять множество представлений. Во-вторых, 
функции класса могут быть написаны так, что присваивание значений для одного 
представления автоматически установит значения для других представлений. За счет 
внутренней поддержки преобразований класс поможет думать о величине в терминах ее 
природы, а не в терминах представления.
	Перегрузка арифметических операций для класса vector. */
Vector Vector::operator+(const Vector & b) const
{
	Vector sum;
	sum.x = x + b.x;
	sum.у = у + b.y;
	sum.set_ang(sum.x, sum.y);
	sum.set_mag(sum.x, sum.y);
	return sum; // в этой версии присутствует ненужное дублирование
}
// Проще и удобнее позволить выполнять эту работу конструктору:
Vector Vector::operator+(const Vector & b) const
{
	return Vector(x + b.x, у + b.y); // возвращает сконструированный объект Vector
}
/* Если метод должен вычислять новый объект класса, Вы должны посмотреть, нельзя ли для
выполнения этой работы воспользоваться конструктором класса. Это не только избавит от
забот, но также гарантирует, что новый объект будет сконструирован должным образом.
	Умножение.
Этот код позволяет конструктору создать корректный объект Vector на основе новых 
компонентов х и у. */
Vector Vector::operator*(double n) const
{
	return Vector (n * x, n * y);
}
// Для умножения Vector на double можно использовать встроенную дружественную функцию:
Vector operator*(double n, const Vector & a) // дружественная функция
{
	return a * n; // преобразует умножение double на Vector в умножение Vector на double
}
/*	Дополнительное усовершенствование: перегрузка перегруженной операции.
 Арифметические операции называются бинарными операциями, поскольку они работают с 
двумя операндами. Когда операция — применяется с одним операндом, как в (-х), она 
является операцией смены знака. Такая форма называется унарной операцией, что 
означает наличие только одного операнда. Как вычитание, так и смена знака имеют 
смысл и для вектора, поэтому в классе Vector присутствуют они обе.
 Чтобы вычесть вектор В из вектора А, необходимо просто обеспечить вычитание
компонентов, поэтому определение перегруженного вычитания очень похоже на сложение: */
Vector operator-(const Vector & b) const;		 // прототип
Vector Vector::operator-(const Vector & b) const // определение
{
	return Vector (x - b.x, y - b.y); // возвращает сконструированный объект Vector
}
// Здесь важно правильно указать порядок. Рассмотрим следующий оператор:
diff = v1 - v2;
// Он преобразуется в такой вызов функции-члена:
diff = v1.operator-(v2);
/* Это означает, что вектор, который передается как явный аргумент, вычитается
из вектора, переданного неявным аргументом, поэтому необходимо использовать */
x - b.x, /*а не*/ b.x - x
/* Унарная операция (-), принимает только один операнд. Применение этой операции к 
обычному числу, как в (-х), меняет знак значения. Таким образом, применение этой 
операции к вектору должно менять знак каждого компонента. Функция должна возвращать 
новый вектор, противоположный исходному. (В терминах полярных координат отрицание 
оставляет модуль вектора без изменений, но меняет направление на противоположное.) 
Ниже представлен прототип и определение перегруженного отрицания: */
Vector operator-() const;
Vector Vector::operator-() const
{
	return Vector (-x, -y);
}
/* Теперь есть два разных определения operator-(). И это нормально, поскольку эти 
два определения имеют разные сигнатуры. Определить унарную и бинарную версии 
операции — можно потому, что в C++ изначально представлены две версии. Каждая функция 
операции поддерживает то же количество операндов, что и соответствующая встроенная 
операция C++. Операция, которая имеет только бинарную форму, такая как деление (/), 
может быть перегружена только как бинарная. */
// randwalk.cpp -- using the Vector class
#include <iostream>
#include <cstdlib>      // rand(), srand() prototypes
#include <ctime>        // time() prototype
#include "vect.h"
#include <fstream>
int main()
{
    using std::cout;
    using VECTOR::Vector;
/* time(0) возвращает текущее время, часто реализованное в виде количества секунд, прошедших с 
    определенной специфической даты. srand() позволяет изменить начальное значение и получить другую 
    последовательность случайных чисел.  */
    srand(time(0));             // начальное значение для генератора случайных чисел
    double direction;
    Vector step;
    Vector result(0.0, 0.0);    // для того, чтобы отслеживать случайное движение (суммирует степы)
    unsigned long steps = 0;
    double target;
    double dstep;
    cout << "Enter target distance: ";   // Ввод заданного расстояния (q для завершения)
    while (std::cin >> target)
    {
        cout << "Enter step length:\t";  // ввод длины шага
        if ( !(std::cin >> dstep) )
            break;
        while (result.magval() < target) // Когда величина вектора result превысит заданную дистанцию, цикл завершается.
        { // rand() возвращает случайное целое число в диапазоне от нуля до определенного значения, 
          // зависящего от реализации: 
            direction = rand() % 360; // операция взятия модуля для выбора угла направления шага в диапазоне от 0 до 359.
        /* Устанавливает вектор по прямоугольным координатам, если form равно RECT
            (по умолчанию), или по полярным координатам, если если form равно POL: */
            step.reset(dstep, direction, Vector::POL);
            result = result + step;
            steps++;
        }
        cout << "After " << steps << " steps, the subject is in rectangular coordinates:\n";
        cout << result   << std::endl;                  // вывод позиции после steps шагов
        std::ofstream fout;
        fout.open("thewalk.txt");       // сохранение в файле
        fout << result << std::endl;    // вызывает дружественную функцию operator<<(fout, result)
        fout.close(); // done with file
        result.polar_mode();
        cout << "Or polar coordinates:\n" << result << std::endl;
        cout << "Average outward distance per step = "
             << result.magval() / steps << std::endl;   // вывод среднего расстояния на один шаг
        steps = 0;
        result.reset(0.0, 0.0);
        cout << "Enter target distance (q to quit): ";  // Ввод заданного расстояния (q для завершения)
    }
    cout << "Bye!\n";
/*  keep window open
    cin.clear();
    while (cin.get() != '\n')
        continue;
    cin.get();
*/
    return 0;
}
/* Согласно теории вероятностей, среднее количество шагов (N) длиной s,
которое понадобится для преодоления суммарного расстояния Д вычисляется по 
следующей формуле: N = (D/s)^2. Это среднее значение, которое будет существенно 
варьироваться от попытки к попытке. 
 За счет установки режима вектора программа отображает конечную позицию в
прямоугольных и полярных координатах. Cледующий оператор переключает result в 
режим RECT, независимо от начальных режимов result и step: */
result = result + step;
/* Сначала функция операции сложения создает и возвращает новый вектор, 
представляющий сумму двух аргументов. Функция создает вектор, используя 
конструктор по умолчанию, который порождает новый вектор в режиме RECT. Поэтому вектор, 
присваиваемый result, находится в режиме RECT. По умолчанию присваивание каждой 
переменной-члена выполняется индивидуально, поэтому result.mode получает значение 
RECT. Чтобы result сохранял свой предыдущий режим, можно перегрузить операцию 
присваивания по умолчанию, определив для класса функцию операции присваивания.
	Сохранение в файле.
Необходимо включить <fstream>, объявить объект of stream и ассоциировать его с файлом: */
#include <fstream>
ofstream fout;
fout.open("thewalk.txt");
// Затем в цикл, вычисляющий результат, можно вставить такой оператор:
fout << result << std::endl;
fout.close();	// done with file
/* Это вызывает дружественную функцию operator<<(fout, result), подставляя
в качестве первого аргумента ссылку на fout и, таким образом, направляя вывод в
файл. Объект fout можно также использовать для вывода в этот файл другой 
информации, такой как итоговые сведения, отображаемые cout.
	Автоматические преобразования и приведения типов в классах.
 В C++ любой конструктор, который принимает единственный аргумент, действует как 
инструмент копирования для преобразования значения типа аргумента в тип класса. */
Stonewt(double lbs); // шаблон преобразования double в Stonewt
// То есть можно записать такой код:
Stonewt myCat;	// создание объекта Stonewt
myCat = 19.6;	// использование Stonewt(double) для неявного преобразования 19.6 в Stonewt
/* В качестве функции преобразования может использоваться только конструктор с
одним аргументом. */
Stonewt(int stn, double lbs); // не является функцией преобразования
/* Однако если предусмотреть в нем значение по умолчанию для второго параметра,
он сможет действовать как руководство для преобразования int: */
Stonewt(int stn, double lbs = 0); // преобразование int в Stonewt
explicit // - для отключения автоматического неявного преобразования
explicit Stonewt (double lbs);	 // неявное преобразование не разрешено
/* Это отключает неявное преобразование, но по-прежнему позволяет использовать 
явное преобразование, т.е. с явными приведениями типов: */
Stonewt myCat;	// создание объекта Stonewt
myCat = 19.6;	// не допускается, если Stonewt(double) объявлен как explicit
mycat = Stonewt(19.6);	// так можно, явное преобразование
mycat = (Stonewt) 19.6;	// так можно, это старая форма приведения типов
/* Конструктор C++, который принимает один аргумент, определяет преобразование типа 
аргумента в тип класса. Если ключевое слово explicit присутствует в объявлении, 
Stonewt(double) применяется только с явным приведением типов, а в противном случае 
его можно использовать для следующих неявных преобразований:
• когда объект Stonewt инициализируется значением типа double;
• когда объекту Stonewt присваивается значение типа double;
• когда функции, ожидающей аргумент типа Stonewt, передается значение типа double;
• когда функция, объявленная как возвращающая значение Stonewt, пытается
  вернуть значение double;
• когда в любой из описанных выше ситуаций используется встроенный тип, 
  который может быть однозначно преобразован в тип double. */
Stonewt Jumbo(7000); // использует Stonewt(double), преобразуя int в double
Jumbo = 7300;		// использует Stonewt(double), преобразуя int в double
/*	Функции преобразования.
 Специальная функция-член операции, называемая функцией преобразования, — это 
определяемый пользователем способ приведения типов, служит инструкцией для 
преобразования объекта класса в другой тип, и его можно применять таким же 
способом, как и обычное приведение типов. Например, если определена функция 
преобразования Stonewt в double, то можно выполнять следующие преобразования: */
Stonewt wolfe(285.7);
double host = double (wolfe);	 // синтаксис #1
double thinker = (double) wolfe; // синтаксис #2
// Либо можно предоставить компилятору решить, что делать:
Stonewt wells(20, 3);
double star = wells; // неявное применение функции преобразования
// Для преобразования в тип имяТипа используется функция такого вида:
operator имяТипа();
/* При этом нужно помнить о следующих моментах:
• функция преобразования должна быть методом класса;
• в функции преобразования не должен быть указан возвращаемый тип;
• функция преобразования не должна иметь аргументов.
Например, функция для преобразования в тип double должна иметь следующий прототип: */
operator double();
/* Тот факт, что функция является методом класса, означает, что она должна вызываться 
конкретным объектом класса, и сообщает ей, какое значение необходимо преобразовать. 
Поэтому такая функция не нуждается в аргументах. */
operator int() const;
operator double() const;
/* Обе функции возвращают значение нужного типа, даже несмотря на то, что не имеют
объявленного типа возврата. Кроме того, определение преобразования в int округляет 
возвращаемое значение к ближайшему целому, а не усекает его. Например, если pounds 
равно 114.4, то pounds + 0.5 равно 114.9, a int (114.9) равен 114.  Но если pounds 
равно 114.6, то pounds + 0.5 равно 115.1, a int (115.1) равно 115. */
double p_wt = poppins; // неявное преобразование
cout << "Poppins: " << int (poppins) << "   pounds.\n"; // явное преобразование
long gone = poppins;   // ошибка - неоднозначность
long gone = (double) poppins; // использовать преобразование в double
long gone = int(poppins);	  // использовать преобразование в int
/* Лучше использовать явные преобразования, запретив неявные: */
explicit:
	class Stonewt
	{	...
		// Функции преобразования
		explicit operator int() const;
		explicit operator double() const;
	};
/* Другой подход состоит в том, чтобы заменить преобразующую функцию непреобразующей, 
которая решает ту же задачу, но только при явном вызове. То есть следующий код: */
Stonewt::operator int() { return int (pounds + 0.5); }
// можно заменить таким:
int Stonewt::Stone_to_Int() { return int (pounds + 0.5); }
// Это запретит применение показанного ниже присваивания:
int plb = poppins;
// Но если действительно нужно преобразование, будет разрешен следующий код:
int plb = poppins.Stone_to_Int() ;






