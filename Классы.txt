	/* Абстракция — это ключевой шаг в представлении информации в
терминах ее интерфейса с пользователем. То есть вы абстрагируете основные 
операционные характеристики проблемы и выражаете решение в этих терминах.
	Спецификация базового типа выполняет три вещи.
• Определяет, сколько памяти нужно объекту.
• Определяет, как интерпретируются биты памяти. (Типы long и float могут 
занимать одинаковое количество бит памяти, но транслируются в числовые 
значения по-разному.)
• Определяет, какие операции, или методы, могут быть применены с 
использованием этого объекта данных.
	Классы — это типы, определяемые пользователем и реализующие абстрактный интерфейс.
Класс — предназначен для трансляции абстракций в пользовательские типы.
Он комбинирует представление данных и методов для манипулирования 
этими данными в пределах одного аккуратного пакета.
	Спецификация класса состоит из двух частей.
• Объявление класса, описывающее компоненты данных в терминах членов 
данных, а также открытый интерфейс в терминах функций-членов, называемых
методами.
• Определения методов класса, которые описывают, как реализованы определенные
функции-члены.
	Интерфейс программы управляет преобразованием ваших намерений в специфическую
информацию, сохраняемую в компьютере. В отношении классов мы говорим об открытом
интерфейсе. В этом случае потребителем его является программа, использующая класс,
система взаимодействия состоит из объектов класса, а интерфейс состоит из методов, 
предоставленных тем, кто написал этот класс. Интерфейс позволяет вам, как программисту,
написать код, взаимодействующий с объектами класса, и таким образом, дает программе
возможность взаимодействовать с объектами класса.
Например, чтобы определить количество символов в объекте string, вам не нужно открывать 
этот объект и смотреть что у него внутри. Вы просто используете метод size() класса, 
предоставленный его разработчиком. Таким образом, метод size() является частью открытого 
интерфейса между пользователем и объектом класса string. Аналогичным образом метод
getline() является частью открытого интерфейса класса istream. Программа, использующая
сіn, не обращается напрямую к внутренностям объекта сіn для чтения строки ввода; 
вместо этого всю работу выполняет getline().*/
// Пример:
// stock00.h -- Stock class interface
#ifndef STOCK00_H_
#define STOCK00_H_

#include <string>  
	class Stock // Данный синтаксис идентифицирует Stock
	{			// в качестве имени типа для нового класса.
				// Это позволяет объявлять переменные, которые 
				// называются объектами или экземплярами типа Stock.
	private:    //  Инкапсуляция - сокрытие данных. Доступ к членам объекта из раздела private программа
    //  может получить только через открытые функции-члены из раздела public (или через дружественные функции).
    std::string company; // член класса Stock
    long shares;		 // член класса Stock..
    double share_val;
    double total_val;
    void set_tot() { total_val = shares * share_val; } // встроенная функция-член класса Stock определена на месте и
    // поскольку эта функция представляет собой просто реализацию внутреннего кода,
    // а не является частью открытого интерфейса, в классе она объявлена как закрытая функция-член.
	public:     // Любая программа, которая использует объект определенного класса,
    // может иметь непосредственный доступ к членам из раздела public.
    void acquire(const std::string & co, long n, double pr); // прототип функции-члена, определится в программе
    void buy(long num, double price);
    void sell(long num, double price);
    void update(double price);
    void show();
	}; // 
/*	
	Связывание данных и методов в единое целое — наиболее замечательное
свойство класса. При таком проектном решении создание объекта типа Stock 
автоматически устанавливает правила, регулирующие его использование.
	Прототипы функций в определении класса Stock демонстрируют 
установку функций-членов. 
	Открытые функции-члены public действуют в качестве посредников между 
программой и закрытыми членами private объекта; они предоставляют
интерфейс между объектом и программой. Эта изоляция данных от прямого доступа
со стороны программы называется сокрытием данных. (В C++ имеется третье 
ключевое слово для управления доступом — protected, которое объясняется при 
обсуждении наследовании в главе 13.).
	Проектное решение класса пытается отделить открытый интерфейс от специфики
реализации. Открытый интерфейс представляет абстрактный компонент проектного
решения. Собрание деталей реализации в одном месте и отделение их от абстракции
называется инкапсуляцией. Сокрытие данных (помещение данных в раздел private
класса) является примером инкапсуляции, и поэтому оно скрывает функциональные
детали реализации в разделе private, как это сделано в классе Stock с функцией
set_tot (). Другим примером инкапсуляции может служить обычная практика 
помещения определений функций класса в файл, отдельный от объявления класса.
	• Размещение прототипов функций в едином объявлении класса вместо того, чтобы 
держать их раздельно, унифицирует описание за счет размещения его в одном месте.
	• Объявление данных с закрытым доступом разрешает доступ к ним только для
авторизованных функций.
	Поскольку одним из главных принципов ООП является сокрытие данных, то единицы
данных обычно размещаются в разделе private. Функции-члены, которые образуют
интерфейс класса, размещаются в разделе public; в противном случае вызвать эти
функции из программы не удастся. 
	• При определении функции-члена для идентификации класса, которому 
принадлежит функция, используется операция разрешения контекста (::).
	• Методы класса имеют доступ к private-компонентам класса.
	Операция разрешения контекста идентифицирует класс, к 
которому данный метод относится. 
	Единственный способ однозначного разрешения имен методов — использовать
полное имя, включающее имя класса. Stock::update() называется уточненным именем
функции. Простое имя update(), с другой стороны, является сокращением 
(неуточненным именем) полного имени и может применяться только в контексте класса.
	Специальной характеристикой методов является то, что метод может
иметь доступ к закрытым членам класса.
	Любая функция с определением внутри объявления класса автоматически 
становится встроенной.
	Можно определить функцию-член вне объявления класса и, тем не
менее, сделать ее встроенной. Чтобы это сделать, просто используйте квалификатор
inline при определении функции в разделе реализации класса:*/
class Stock
  {
  private:
	void set_tot(); // определение оставлено отдельным
  ...
  public:
  ...
  };
  
inline void Stock::set_tot() // использование inline в определении
  {
  total_val = shares * hare_val;
  }
// Объявления переменных:
	Stock kate, joe; // создает два объекта класса Stock.
	kate.show(); 	 // объект kate вызывает функцию-член
	joe.show(); 	 // объект joe вызывает функцию-член
/* Это значит, что метод интерпретирует shares как kate.shares, a share_val —
как kate.share_val. В этом случае kate.shares занимает один фрагмент
памяти, a joe.shares — другой. Но kate. show () и joe. show () представляют собой
один и тот же метод, т.е. оба выполняют один и тот же блок кода, только применяют
этот код к разным данным. Вызов функции-члена — это то, что в некоторых объектно-
ориентированных языках называется отправкой сообщния. Таким образом, отправка
сообщения двум разным объектам вызывает один и тот же метод, который 
применяется к двум разным объектам.
	Когда вы вызываете функцию-член, она использует данные-члены конкретного
объекта, примененного для ее вызова.
	Создавать объект класса можно за счет объявления переменной этого класса либо 
использования операция new для размещения в памяти объекта этого класса. Объекты 
можно передавать в аргументах, возвращать их из функций, присваивать один объект другому.
	Важнейшим моментом для использования нового типа является понимание того, что 
	делают функции-члены; Вы недолжны задумываться о деталях реализации.
	Клиент-серверная модель:
	Клиентом является программа, которая использует класс. Объявление класса, включая 
его методы, образует сервер, который является ресурсом, доступным нуждающейся в нем 
программе. Клиент взаимодействует с сервером только через открытый (public) интерфейс. 
Это означает, что единственной ответственностью клиента и, как следствие — программиста, 
является знание интерфейса. Ответственностью сервера и, как следствие — его 
разработчика, является обеспечение того, чтобы его реализация надежно и точно 
соответствовала интерфейсу. Любые изменения, вносимые разработчиком сервера в класс, 
должны касаться деталей реализации, но не интерфейса. Это позволяет программистам 
разрабатывать клиент и сервер независимо друг от друга.*/
class имяКласса
	{
	private:
		объявления данных-членов
	public:
		прототипы функций-членов
	};
/*	Содержимое открытого раздела включает абстрактную часть проектного 
решения — открытый интерфейс.
	Класс Bozo имеет функцию-член Retort(), которая 
возвращает указатель на тип char:*/
char * Bozo::Retort();
/*	Retort() — не только функция типа char *, это функция типа
char *, принадлежащая классу Bozo. Полное, или уточненное, имя функции будет 
выглядеть как Bozo::Retort(). Retort имеет область видимости класса, поэтому 
необходима операция разрешения контекста для уточнения имени, когда оно встречается 
вне объявления и вне методов класса. Для создания объекта, который является частным 
примером класса, применяется имя класса, как если бы оно было именем типа:*/
Bozo bozetta;
/* Это работает потому, что класс является типом, определенным пользователем.
Функция-член класса, или метод, вызывается с использованием объекта класса. Это
делается с помощью операции членства (точки):*/
cout << bozetta.Retort();
/*
	Конструкторы класса предназначены для создания новых объектов и присваивания 
значений их членам-данным. Имя метода конструктора совпадает с именем класса. Например, 
возможный конструктор для класса Stock — это функция-член Stock(). Конструкторы не 
имеют возвращаемого значения, они не объявляются с типом void и не имеют объявленного 
типа. 
	Как использовать конструктор вместе с new:*/
Stock *pstock = new Stock("Electroshock Games",18,19.0);
/* Оператор, создающий объект Stock, инициализирует его значениями, 
переданными в аргументах, и присваивает адрес нового объекта указателю pstock. В этом 
случае объект не имеет имени, но для управления объектом можно применять указатель.
	Конструктор по умолчанию — это конструктор, который используется для создания
объекта, когда не предоставлены явные инициализирующие значения.*/
Stock fluffy_the_cat;
//	Для класса Stock конструктор по умолчанию будет таким:
Stock::Stock() { }
/* В результате создается объект fluffy_the_cat с инициализированными членами,
как в следующем операторе создается х без указания его значения: int x;
	Конструктор по умолчанию можно создать двумя способами. Один из них предусматривает 
указание значений по умолчанию для всех аргументов в существующем конструкторе:*/
Stock (const string & со = "Error", long n = 0, double pr = 0.0)
/* Второй способ — использование возможности перегрузки функций для 
определения второго конструктора без аргументов: Stock();
Допускается наличие только одного конструктора по умолчанию.*/
Stock:: Stock() // конструктор по умолчанию
{
company = "no name";
shares = 0;
share_val = 0.0;
total_val = 0.0;
}

Stock first("Concrete Conglomerate"); // вызывает конструктор
Stock secondO;	// объявляет функцию
Stock third;	// вызывает конструктор по умолчанию
/*Первое объявление из приведенных выше вызывает конструктор не по 
умолчанию — т.е. такой, который принимает аргументы. Второе объявление устанавливает,
что second() — это функция, возвращающая объект Stock. При неявном вызове 
конструктора по умолчанию круглые скобки указываться не должны.
	Деструктор имеет специальное имя. Оно формируется из имени класса и предваряющего 
его символа тильды (~). То есть деструктор для класса Stock называется ~Stock(). 
Подобно конструктору, деструктор не имеет ни возвращаемого значения, ни объявляемого типа. 
Но в отличие от конструктора, деструктор не должен иметь аргументы.
	C++ использует конструктор класса, когда вы создаете объект класса,
даже если применяется операция new для динамического выделения памяти.*/
Stock *pstock = new Stock("Electroshock Games",18,19.0);
/* Оператор, создающий объект Stock, инициализирует его значениями, 
переданными в аргументах, и присваивает адрес нового объекта указателю pstock. В этом 
случае объект не имеет имени, но для управления объектом можно применять указатель.*/
Stock stock2 = Stock ("Boffo Objects", 2, 2.0); // оператор вызывает инициализацию; он 
// создает объект с указанным значением, и может создавать либо не создавать временный объект.
stockl = Stock("Nifty Foods", 10, 50.0); // оператор вызывает присваивание. Использование 
// конструктора в операции присваивания в таком виде всегда служит причиной создания 
// временного объекта перед выполнением собственно присваивания.
/*
	Вариант инициализации более эффективен.
	Конструктор, который принимает один аргумент, позволяет использовать синтаксис 
присваивания для инициализации объекта значением:*/
имяКласса объект = значение;

String * favorite = new String(sayings[choice]);
/* Здесь указатель favorite обеспечивает доступ к безымянному объекту, созданному
операцией new. Этот синтаксис означает инициализацию нового объекта String с 
помощью объекта sayings [choice]. При этом вызывается конструктор копирования,
поскольку тип аргумента для конструктора копирования (const String &) 
соответствует инициализирующему значению (sayings [choice] ).
 
*/
