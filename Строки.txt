/* Функцию, которая добавляет заданную строку к обеим сторонам другой строки. 
Функция version () не создает временную строку, вместо этого она напрямую 
изменяет исходную строку: */
const string & version(string & s1, const string & s2) // имеет побочный эффект
{
si = s2 + s1 + s2;
// Возврат ссылки, переданной функции, безопасен
return s1;
}
/* Эта функция может изменять значение s1, т.к. переменная s1, в отличие от s2,
объявлена без const.

	Способ установки размера новой строки состоит в том, чтобы присвоить
переменной n меньшую величину из переданного значения и длины строки: */
int len = strlen(str);
n = (n < len) ? n : len; // меньшее из n и len
char *p = new char[n+l];
/* Это гарантирует, что new не выделит больше пространства, чем необходимо для
хранения строки.
Если время, затраченное на вызов функции strlen() неприемлемо, можно позволить 
непосредственно выбрать меньшее из значений n и длины строки. Приведенный ниже 
цикл завершается, когда m достигает значения п или длины строки, что бы ни 
случилось первым: */
int m = 0;
while ( m <= n && str[m] != '\0')
	m++;
char *p = new char[m+l];
/* В остальном коде будет использоваться m вместо n
Выражение */ str[m] != '\0' /* вычисляется как true, когда str[m] не
является нулевым символом, и как false — в противном случае. Поскольку в 
выражении && ненулевые значения преобразуются в true, а нулевые —
в false, проверочное условие while может быть также записано следующим образом: */
while (m <= n && str[m])

/*	Подсчет цифр в числе: */
unsigned digits = 1;
while (n /= 10)
	digits++;
/* Деление числа на 10 уменьшает его запись на одну цифру.
В этом цикле подсчитывается, сколько раз можно удалить цифру из числа п до
того, как не останется ни одной цифры.
	Предположим, что исходное число содержит пять цифр и нужно 
возвратить первые три цифры. Чтобы получить данное трехзначное число, можно два раза
разделить исходное число на 10. При каждом делении числа на 10 в записи числа 
удаляется одна цифра справа. Чтобы узнать, какое количество цифр нужно удалить, 
следует просто вычислить количество цифр, которые требуется отобразить, из общего
количества цифр в представлении исходного числа. Например, чтобы отобразить 
четыре цифры числа, представленного девятью цифрами, удалите последние пять цифр:*/
unsigned long left(unsigned long num, unsigned ct) // Возвращает первых ct цифр числа num
{
unsigned digits = 1;
unsigned long n = num;
if (ct == 0 | | num == 0)
	return 0; // возврат О в случае отсутствия цифр
while (n /= 10)
	digits++;
if (digits > ct)
{
	ct = digits - ct;
	while (ct--)
		num /= 10;
	return num; // возврат ct знаков слева
}
else // если ct >= количества цифр
	return num; // возврат числа целиком
}

// Возвращает указатель на новую строку, состоящую
// из n первых символов строки str
char *left (const char *str, int n)
{
if (n < 0)
    n = 0;
char *p = new char[n+1];
int i;
for (i = 0; i < n && str[i]; i++ )
    p[i] = str[i]; // копирование символов
while (i <= n)
    p[i++] = '\0'; // установка остальных символов строки в '\0'
return p;
}

