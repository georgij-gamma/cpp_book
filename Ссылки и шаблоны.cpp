/*Ссылки используются в качестве параметров функции, при этом имя 
переменной в функции становится псевдонимом переменной в вызывающей программе.*/
void swapr(int & a, int & b);
void swapp (int *p, int *q);
/*Различие состоит в том, что вариант с указателем требует применения 
операции разыменования (*) во всех случаях, когда функция использует переменные р и q.
Ссылочную переменную необходимо инициализировать при ее определении.
	При условии, что ссылочный параметр является const, компилятор генерирует временную 
переменную в двух ситуациях:
• когда тип фактического аргумента выбран правильно, но сам параметр не 
является lvalue;
• когда тип фактического параметра выбран неправильно, но может быть 
преобразован в правильный тип.
	lvalue, представляет собой объект 
данных, на который можно ссылаться по адресу. Например, переменная, элемент 
массива, член структуры, ссылка и разыменованный указатель —
все они являются lvalue.
К lvalue не относятся литеральные константы (кроме строк в двойных кавычках, 
которые представлены своими адресами) и выражения, состоящие из нескольких 
элементов.
	Если передаваемый функции аргумент не является lvalue или не совместим по типу с 
соответствующим ссылочным параметром const, C++ создает анонимную переменную требуемого 
типа, присваивает ей значение передаваемого функции аргумента, и делает так, чтобы 
параметр ссылался на эту переменную.
	Причины объявлять ссылочные аргументы как ссылки на констатные данные:
• Использование const защищает от внесения в программы ошибок, приводящих к 
непреднамеренному изменению данных.
• Использование const позволяет функции обрабатывать фактические аргументы как с 
const, так и без const. При этом функция, в прототипе которой квалификатор const 
опущен, может принимать только неконстантные данные.
• Использование ссылки const позволяет функции генерировать и использовать временные 
переменные по мере необходимости.
Исходный ссылочный тип (объявленный с использованием &) называется ссылкой lvalue.
	Для отображения содержимого структуры, не изменяя её, в 
функциях применяется ссылочный параметр const. В таком случае структуру можно
было бы передать по значению, однако использование ссылки более экономично с
точки зрения времени и памяти, чем создание копии исходной структуры.
	Причины использовать ссылочные аргументы:
• чтобы позволить изменять объект данных в вызывающей функции;
• чтобы ускорить работу программы за счет передачи ссылки вместо полной 
копии объекта данных.
	***
	В каких случаях следует использовать ссылку, указатель или передачу по значению? 
	1. Функция использует передаваемые данные без их изменения в перечисленных
ниже ситуациях:
• Если объект данных небольшой, например, такой как встроенный тип данных
или некрупная структура, передавайте его по значению.
• Если объект данных представляет собой массив, используйте указатель, 
поскольку это единственный вариант. Объявите указатель с квалификатором const.
• Если объект данных является структурой приемлемого размера, используйте
const-указатель или const-ссылку для увеличения эффективности программы.
В этом случае удастся сохранить время и пространство, необходимое для 
копирования структуры или строения класса. Объявите указатель или ссылку с 
квалификатором const.
• Если объект данных является объектом класса, используйте ссылку с 
квалификатором const. Семантика строения класса часто требует применения ссылки.
Эта главная причина добавления этого новшества в язык C++. Таким образом,
стандартом является передача объектов класса по ссылке.
	2. Функция изменяет данные вызывающей функции в следующих ситуациях:
• Если объект данных относится к одному из встроенных типов, используйте 
указатель. Если в коде встретилось выражение вида fixit (&х), где х имеет тип int,
это явно означает, что функция должна изменять значение х.
• Если объект данных представляет собой массив, остается один выбор — указатель.
• Если объект данных является структурой, можно использовать ссылку или указатель.
• Когда объект данных представляет собой объект класса, следует применять ссылку.
	Могут существовать причины для других решений. Например, объект сіn 
	использует ссылки на базовые типы данных, поэтому
вместо записи сіn » &n можно применять запись сіn » n.
	***
	Аргументы по умолчанию
	Аргумент по умолчанию представляет собой значение, которое
используется автоматически, если соответствующий фактический параметр в вызове
функции не указан.*/
char * left (const char * str, int n = 1) // функция должна возвращать новую строку,
{										  // т.к. нужно сохранить исходную строку неизменной,
										  // использовать квалификатор const для первого аргумента.
if (n < 0)
	n = 0;
char *p = new char[n+l];
int i;
for (i = 0; i < n && str[i]; i++ )
	p[i] = str[i]; // копирование символов
while (i <= n)
	p[i++] = '\0'; // установка остальных символов строки в '\0'
return p;
}
/*	Перегрузка функций
	Полиморфизм функций, или перегрузка функций, 
предоставляет возможность использовать несколько функций с одним
и тем же именем. Ключевую роль в перегрузке функций играет список аргументов, который 
называется сигнатурой функции.
	Значение без const можно присвоить переменной const, но не наоборот.
	Именно сигнатура, а не тип функции, делает возможным ее 
перегрузку: */
long gronk(int n, float m); // одинаковые сигнатуры, поэтому
double gronk(int n, float m); // объявления не допускаются
/*В C++ нельзя перегружать функцию gronk () подобным образом. Можно иметь 
различные возвращаемые типы, но только при условии, что сигнатуры функций 
отличаются: */
long gronk(int n, float m) ; // различные сигнатуры, поэтому
double gronk(float n, float m) ; // объявления допустимы

/* Перегрузка ссылочных параметров */
void sink(double & rl); // соответствует изменяемому lvalue
void sank(const double & r2) ; // соответствует изменяемому
// или константному lvalue, rvalue
void sunk(double && r3); // соответствует rvalue
/*Ссылочный параметр lvalue по имени rl соответствует изменяемому аргументу lvalue, 
такому как переменная double. Константный ссылочный параметр lvalue по имени r2 
соответствует изменяемому аргументу, константному аргументу lvalue и аргументу rvalue, такому как
сумма двух значений double. И, наконец, ссылка rvalue по имени гЗ соответствует rvalue.
Обратите внимание, что r2 может соответствовать той же разновидности аргументов, как
rl и rЗ. Возникает вопрос, а что случится, если перегрузить функцию с этими тремя типами
параметров? Ответ заключается в том, что будет предпринят поиск более точного 
соответствия:*/
void staff(double & rs); // соответствует изменяемому lvalue
voit staff(const double & res); // соответствует rvalue,
// константному lvalue
void stove(double & rl); // соответствует изменяемому lvalue
void stove(const double & r2); // соответствует константному lvalue
void stove(double && r3); // соответствует rvalue
/* Это позволяет настраивать поведение функции на основе того, каковой является природа
аргумента — lvalue, const или rvalue:*/
double x = 55.5;
const double у = 32.0;
stove(x); // вызывает stove(double &)
stove(у); // вызывает stove(const double &)
stove(x+y); // вызывает stove(double &&)
/* Если, скажем, опустить функцию stove (double &&), то stove (x+y) взамен 
приведет к вызову stove(const double &).
	Перегрузку целесообразно использовать для функций, которые выполняют в 
основном одни и те же действия, но с различными типами данных.
	Декорированием имен или искажением имен - это когда имя каждой функции 
шифруется на основе типов формальных параметров, указанных в прототипе функции.
Например:*/
long MyFunctionFoo(int, float);
// будет декодировано:
?MyFunctionFoo@@YAXH // может отличаться в разных компиляторах

/*	Шаблон функции — это обобщенное описание функции; т.е. шаблон
определяет функцию в терминах обобщенного типа, вместо которого может быть
подставлен определенный тип данных, такой как int или double. Передавая шаблону 
тип в качестве параметра, можно заставить компилятор сгенерировать функцию для 
этого конкретного типа.
	Шаблон для осуществления обмена значениями: */
template <typename AnyType>
void Swap(AnyType &a, AnyType &b)
{
AnyType temp;
temp = а;
а = b;
b = temp;
}
/* Первая строка указывает, что устанавливается шаблон, а произвольный тип 
данных получает имя AnyType. Ключевые слова template и typename являются 
обязательными; при этом вместо typename можно использовать ключевое слово class. 
Кроме того, должны присутствовать угловые скобки. Имя типа может быть любым 
(в этом примере — AnyType).
 Шаблоны должны использоваться в тех случаях, когда необходимы функции, 
 применяющие один и тот же алгоритм к различным типам данных. 
 Шаблоны функций не сокращают размеры исполняемых файлов.
 Преимущество шаблонов состоит в упрощении процесса генерации нескольких
определений функции, а также в увеличении его надежности.
	Перегруженные шаблоны
Не все аргументы шаблонов обязательно должны иметь обобщенный тип.
Не для всех типов в шаблоне алгоритм выглядит совершенно одинаково.*/
template <typename T>
void Swap(T &a, T &b) 
{
    T temp;
    temp = a;
    a = b;
    b = temp;
}

template <typename T>
void Swap(T a[], T b[], int n)
{
    T temp;
    for (int i = 0; i < n; i++)
    {
        temp = a[i];
        a[i] = b[i];
        b[i] = temp;
    }
}
/* Ограничения шаблонов
В приведенном ниже операторе предполагается, что для типа Т определена 
операция умножения, а это не так в случае, когда Т —
массив, указатель или структура: */
Т с = а*b;
/* Легко получить шаблон функции, который не может обрабатывать 
определенные типы. Иногда обобщение имеет смысл, даже если обычный 
синтаксис C++ не допускает его. Например, сложение структур, содержащих
координаты позиции, вполне оправдано, несмотря на то, что операция + 
для структур не определена.
Аргументы по умолчанию и шаблоны функции
	Пример: */

template< class T >
void PrintNumbers(T array[], int array_size, T filter = T())
{
   for(int nIndex = 0; nIndex < array_size; ++nIndex)
   {
       if ( array[nIndex] != filter) // Печать, если не отфильтровано
           cout << array[nIndex];
   }
}
/* Этот шаблон функции печатает, как Вы можете догадаться, все числа за 
исключением тех, которые были отфильтрованы третьим аргументом filter. 
Последний, необязательный аргумент функции сделан по умолчанию на 
значение по умолчанию для типа T. Это для всех базовых типов означает 0. 
Таким образом, если при вызове функции мы пропустим последний аргумент: */
int Array[10] = {1,2,0,3,4,2,5,6,0,7};
PrintNumbers(Array, 10);
//то он будет инициирован как:
void PrintNumbers(int array[], int array_size, int filter = int())
{}
/*Аргумент filter будет вычислен как int filter = 0.
Само собой, когда Вы делаете вызов: */
PrintNumbers(Array, 10, 2);
/* то третий элемент получит значение 2, не значение по умолчанию 0. Вы 
должны четко усвоить:
• Тип T должен иметь доступный конструктор по умолчанию. И конечно, все 
операторы, которые нужны для вычислений в теле функции для типа T.
• Аргумент по умолчанию должен быть выводим от других, не умолчательных 
типов аргументов, которые получает шаблон. В примере PrintNumbers на 
основе типа массива упростится вывод типа для filter. Если же нет, то 
Вы должны использовать явное указание типа аргумента (explicit template 
argument specification), чтобы задать тип аргумента по умолчанию.
Аргумент по умолчанию не обязательно может быть значением по умолчанию 
для типа T. Это означает, что аргумент по умолчанию не всегда может 
нуждаться в зависимости от конструктора по умолчанию для типа T: */
template< class T >
void PrintNumbers(T array[], int array_size, T filter = T(60))
/* Здесь аргумент функции по умолчанию не использует значение по 
умолчанию для типа T. Вместо этого используется значение 60. Это требует 
для типа T наличие copy-конструктора, который принимает int (для числа 60).

	Явные специализации
 Можно предоставить специализированное определение функции, 
называемое явной специализацией, которое содержит требуемый код.
• Одно и то же имя может применяться для нешаблонной функции, шаблонной
функции и явной специализации шаблона, а также всех перегруженных версий
всего перечисленного.
• Прототип и определение явной специализации должно быть предварено
template <>, а также указывать имя обобщенного типа данных.
• Специализация переопределяет обычный шаблон, а нешаблонная функция 
переопределяет и специализацию, и шаблон.*/
struct job // например структура
{
	char name[40] ;
	double salary;
	int floor;
};

void Swap(job &, job &); // Прототип нешаблонной функции

template <typename T> // Прототип шаблона обобщенной функции
void Swap(T &, T &);

template <> void Swap<job> (job &, job &); // Явная специализация для типа job

/* Если существует более одного из перечисленных прототипов, компилятор отдает 
предпочтение нешаблонной версии перед явными специализациями и шаблонными 
версиями, и предпочитает явную специализацию перед версией, сгенерированной 
из шаблона.
	Конструкция <job> в выражении Swap<job> необязательна, поскольку типы 
аргументов функции указывают, что это специализация для структуры job.
Поэтому прототип может иметь и такой вид: */
template <> void Swap(job &, job &) ; // упрощенная форма

/*	Создание экземпляров и специализация
	Включение шаблона функции в код само по себе не приводит к генерации 
определения функции. Когда компилятор использует шаблон при генерации 
определения функции для определенного типа данных, результат называется 
созданием экземпляра шаблона. Шаблон — это не определение функции, но 
определенный экземпляр шаблона, например использующий int, является определением 
функции. Такой вид создания экземпляров шаблонов называется неявным созданием 
экземпляров, поскольку компилятор выясняет необходимость в построении 
определения, обнаруживая тот факт, что в программе используется функция 
Swap() с параметрами int.
	Явное создание экземпляров означает возможность дать компилятору прямую 
команду создать определенный экземпляр, например, Swap<int>(). Синтаксис 
предусматривает объявление с использованием нотации <> для указания типа и 
предварение объявления ключевым словом template: */
template void Swap<int>(int, int); // явное создание экземпляра

/* Два объявления ниже означают следующее: "не применять шаблон функции 
Swap(), чтобы сгенерировать определение функции; вместо этого воспользоваться 
отдельным специализированным определением функции, явно сформулированным 
для типа int". */
template <> Swap<int>(int &, int &); // явная специализация
template <> Swap(int &, int &) ; // эквивалентная явная специализация
/* Эти прототипы должны быть ассоциированы с собственными определениями 
функций. В объявлении явной специализации после ключевого слова template 
следует конструкция <>. В объявлении явного создания экземпляра она опускается.
	Попытка одновременного использования в одном файле или, в более общем 
случае — в компилируемом модуле, как явного создания экземпляра, так и 
явной специализации для одного и того же типа (типов) приведет к ошибке!
	Пример: шаблон */
template <class T>
Т Add(T а, Т b) // передача по значению
{
	return a + b;
}

int m = 6;
double x = 10.2;
/* не даст соответствия с вызовом функции Add(x, m), поскольку 
шаблон ожидает, что оба аргумента функции относятся к одному и тому же 
типу.*/
cout << Add<double>(x, m) << endl; // явное создание экземпляра
/* Но использование Add<double>(x, m) приводит к созданию экземпляра для 
типа double, и тип аргумента m приводится к double для соответствия второму 
параметру функции Add<double>(double, double).*/
// Пример:
template <typename T> // Прототип шаблона обобщенной функции
void Swap(T &, T &) ;
// Вызов:
Swap<double>(m, x) ; // не работает
/* В данном случае код работать не будет, т.к. первый формальный параметр, 
имея тип double &, не может ссылаться на переменную m типа int.
	Неявное и явное создание экземпляров, а также явная специализация, 
вместе называются специализацией, они представляют определение функции, в 
основу которого положены специфические типы данных.
	Пример: */
template <class T>		// прототип шаблона обобщенной функции
void Swap (T &, Т &) ;  // (для неявных экземпляров шаблона)

template <> void Swap<int>(job &, job &); // явная специализация для job

int main(void)
{
template void Swap<char> (char &, char &); // явное создание экземпляра для char
short a, b;
Swap(a,b); // неявное создание экземпляра шаблона для short
job n, m
swap (n, m) ; // использование явной специализации для job
char g, h
swap (g, h) ; // использование явного создания экземпляра шаблона для char
}
/* Когда компилятор обнаруживает явное создание экземпляра для char, он 
использует определение шаблона, чтобы сгенерировать версию функции Swap(), 
предназначенную для типа char. В остальных вызовах Swap() компилятор 
сопоставляет шаблон с используемыми в вызове фактическими аргументами. 
Например, когда компилятор обнаруживает вызов функции Swap(a,b), он генерирует 
версию этой функции для типа short, поскольку оба аргумента принадлежат этому 
типу. Когда компилятор обнаруживает вызов функции Swap(n, m), он использует 
отдельное определение (явную специализацию), предоставленное для типа job. 
Когда компилятор достигает вызова функции Swap(g, h), он применяет 
специализацию шаблона, которая уже была сгенерирована во время обработки 
явного создания экземпляра.
	Разрешение перегрузки.
• Фаза 1. Составьте список функций-кандидатов. Таковыми являются функции и
шаблоны функций с таким же именем, как у вызываемой функции.
• Фаза 2. Беря за основу список функций-кандидатов, составьте список 
подходящих функций. Таковыми являются функции с корректным количеством 
аргументов, для которых существует неявная последовательность преобразований
типов. Она включает случай точного совпадения типа каждого фактического
аргумента с типом соответствующего формального аргумента. Например, при
вызове функции с аргументом типа float это значение может быть приведено
к типу double для соответствия типу double формального параметра, а шаблон
может сгенерировать экземпляр функции для типа float.
• Фаза 3. Проверьте наличие наиболее подходящей функции. Если она есть, 
используйте ее. В противном случае вызов функции является ошибочным.
	Пример вызова функции с единственным аргументом: */
may('В'); // фактический аргумент имеет тип char
/* Прежде всего, компилятор отмечает все кандидаты, каковыми являются функции
и шаблоны функций с именем may(). Затем он находит среди них те, которые могут
быть вызваны с одним аргументом. Например, в этом случае проверку пройдут 
следующие функции, поскольку они имеют одно и то же имя и могут использоваться с
одним аргументом: */
void may(int); // #1
float may (float, float = 3); // #2
void may(char); // #3
char * may(const char *) ; // #4
char may (const char &) ; // #5
template<class T> void may (const T &) ; // #6
template<class T> void may(T *); // #7
/* При этом учитываются только сигнатуры, а не типы возвращаемых значений. 
Два кандидата (#4 и #7) из списка не подходят, поскольку целочисленный тип 
данных не может быть преобразован неявно (т.е. без явного приведения типов) 
в тип указателя. Оставшийся шаблон подходит, т.к. может быть использован для 
генерирования специализации, где в качестве Т принимается тип char. В итоге 
остается пять функций-кандидатов, каждая из которых может использоваться, так 
как если бы она была единственной объявленной функцией. Далее компилятор 
должен определить, какая из функций-кандидатов в наибольшей степени 
соответствует критерию отбора. Он анализирует преобразования, необходимые 
для того, чтобы аргумент обращения к функции соответствовал аргументу наиболее 
подходящего кандидата. В общем случае порядок следования от наилучшего к
наихудшему варианту можно представить следующим образом:
1. Точное соответствие, при этом обычные функции имеют приоритет перед 
шаблонами.
2. Преобразование за счет расширения (например, автоматические 
преобразования char и short в int и float в double).
3. Преобразование с помощью стандартных преобразований (например, 
преобразование int в char или long в double).
4. Преобразования, определяемые пользователем, такие как те, что определены в
объявлениях классов.
Например, функция #1 предпочтительнее функции #2, поскольку преобразование
char в int является расширением (см. главу 3), в то время как char в float —
это стандартное преобразование (также описанное в главе 3). Функции #3, #5 и #6 
предпочтительнее функций #1 и #2, т.к. они являются точными соответствиями. 
Функции #3 и #5 предпочтительнее варианта #6, потому что последний 
представляет собой шаблон.
	Точные соответствия и наилучшие соответствия
 Тривиальные преобразования, допустимые при точном соответствии:
 
Из фактического аргумента		В формальный аргумент
	Туре								Туре &
	Туре &								Туре
	Туре[]								*Туре
Туре(список-аргументов)			Туре(*)(список-аргументов)
	Type							const Type
	Type							volatile Type
	Туре *							const Type *
	Туре *							volatile Type *

Например, фактический аргумент int является точным соответствием 
формальному параметру int &. Туре может быть чем-то подобным char &,
так что эти правила включают преобразование char & в const char &. Запись 
Туре(список-аргументов) означает, что имя функции как фактический аргумент 
соответствует указателю на функцию, переданному в качестве формального 
параметра, при условии, что оба они имеют один и тот же возвращаемый тип и 
список аргументов.
	Пример: */
struct blot { int a; char b[10]; };
blot ink = { 25, "spots" };
recycle(ink);
// В этом случае все перечисленные ниже прототипы будут точными соответствиями:
void recycle (blot); // #1 blot в blot
void recycle (const blot); // #2 blot в const blot
void recycle (blot &); // #3 blot в blot &
void recycle (const blot &); // #4 blot в const blot &
/* Результатом наличия множества подходящих прототипов является то, что 
компилятор не в состоянии завершить процесс 
разрешения перегрузки. Наиболее подходящей функции не существует, и компилятор 
сгенерирует сообщение об ошибке, в котором будет присутствовать слово 
"ambiguous" (неоднозначный).
 Разрешение перегрузки иногда возможно даже в случае, когда две 
функции являются точным соответствием. Прежде всего, указатели и ссылки на 
данные не const сопоставляются преимущественно с указателями не const и 
ссылочными параметрами. То есть, если бы в примере с recycle() существовали 
только функции #3 и #4, то был бы выбран вариант #3, поскольку переменная ink 
не объявлена как const. Тем не менее, такое различение между const и не const 
применимо только к данным, на которые имеются ссылки и указатели. Если бы 
доступными были только функции #1 и #2, то возникла бы ошибка, связанная с 
неопределенностью.
 Другой случай, при котором одно точное соответствие оказывается лучше другого,
касается ситуации, когда одна функция является нешаблонной, а другая —
нет. Тогда нешаблонная функция рассматривается как более подходящая, чем шаблон, 
включая явные специализации.
 Если, в конечном счете, оказалось два точных соответствия, и оба представляют
собой шаблонные функции, то предпочитаемым вариантом будет шаблонная 
функция, являющаяся более специализированной (при наличии таковой). Это означает,
например, что явная специализация получает преимущество перед функцией, неявно
сгенерированной из шаблона: */
struct blot { int a; char b[10]; };			  // обьявление структуры
template <class Type> void recycle (Type t) ; // шаблон
template <> void recycle<blot> (blot & t) ;   // специализация для blot
blot ink = { 25, "spots" };
recycle(ink); // используется специализация
/* Понятие наиболее специализированная не всегда означает явную специализацию; 
оно отражает то, что при выборе компилятором используемого типа выполняется 
меньшее количество преобразований.
	Пример: два прототипа шаблона: */
template <class Type> void recycle (Type t);  // #1
template <class Type> void recycle (Type *t); // #2
// обьявление структуры
struct blot { int a; char b[10]; };
// её инициализация
blot ink = { 25, "spots" };
// и вызов шаблона
recycle(&ink); // адрес структуры
/* Вызов recycle(&ink) соответствует шаблону #1, в котором Туре 
интерпретируется как blot *. Тот же вызов соответствует и шаблону #2, но на 
этот раз Туре будет ink. Это сочетание передает два неявных экземпляра, 
recycle<blot *>(blot *) и recycle<blot>(blot *), в пул подходящих функций.
 Из этих двух вариантов шаблон recycle<blot *>(blot *) является более 
специализированным, поскольку он предполагает меньшее количество преобразований в 
процессе генерирования. Другими словами, шаблон #2 уже явно заявил, что аргументом
функции является указатель на Туре, так что Туре может прямо идентифицироваться
как blot. Однако шаблон #1 имеет Туре как аргумент функции, поэтому Туре должен
интерпретироваться как указатель на blot. To есть в шаблоне #2 Туре уже 
специализирован как указатель, отсюда происходит выражение "более специализированный".
 Правила для нахождения наиболее специализированного шаблона называются 
"правилами частичного упорядочивания" для шаблонов функций.*/
// tempover.срр — пример перегрузки шаблонов
#include <iostream>

template <typename T> // шаблон А
void ShowArray(T arr[], int n) ;

template <typename T> // шаблон В
void ShowArray(T *arr[], int n);

struct debts
{
    char name[50];
    double amount;
};

int main()
{
using namespace std;
int things[6] = {13, 31, 103, 301, 310, 130};
debts mr_E[3] =
{
    {"Ima Wolfe", 2400.0},
    {"Ura Foxe", 1300.0},
    {"Iby Stout", 1800.0}
};
double *pd[3];
// Установка указателей на члены amount структур в mr_E
for (int i = 0; i < 3; i++ )
pd[i] = &mr_E[i].amount;

cout << "Listing Mr. E's counts of things:\n";
// things - массив значений int
ShowArray(things, 6); // использует шаблон А

cout << "Listing Mr. E's debts:\n";
// pd - массив указателей на double
ShowArray(pd, 3); // использует шаблон В (более специализированный)
return 0;
}
template <typename T>
void ShowArray(T arr[], int n) // шаблон А
{
using namespace std;
cout << "template A\n";
for (int i = 0; i < n; i++)
	cout << arr[i] << ' ';
cout << endl;
}
template <typename T>           // шаблон В
void ShowArray (T *arr[], int n)
{
using namespace std;
cout << "template B\n";
for (int i = 0; i < n; i++ )
	cout << *arr [i] << ' ';
cout << endl;
}
/* При вызове функции ShowArray(things, 6);, идентификатор things 
представляет собой имя массива элементов int, поэтому приведенный 
вызов соответствует шаблону, где Т получает тип int: */
template <typename T> // шаблон А
void ShowArray(T arr[], int n);
/* При вызове функции ShowArray(pd, 3);, pd — это имя массива 
элементов double *. Этот вызов соответствует шаблону А.
Вместо Т подставляется тип double *. В этом случае шаблонная 
функция отобразит содержимое массива pd, т.е. три адреса. 
Приведенный вызов функции также может быть сопоставлен с шаблоном В: */
template <typename T> // шаблон В
void ShowArray(T *arr[], int n);
/* Здесь Т получает тип double, а функция отображает разыменованные 
элементы *аrr[і] — значения типа double, на которые указывают элементы 
массива. Из двух шаблонов более специализированным является шаблон В, 
поскольку он построен исходя из предположения, что массив содержит 
указатели. Поэтому именно шаблон В и будет использоваться. Если 
удалить из программы шаблон В, компилятор будет использовать шаблон А
для вывода содержимого массива pd, поэтому список будет содержать 
адреса, а не значения.
	Процесс разрешения перегрузки ищет функцию, которая будет наилучшим 
соответствием. Если существует лишь одна такая функция, она и 
выбирается. Если вариантов несколько, но только одна функция является 
нешаблонной, она и выбирается. Когда кандидатов несколько, и все они 
являются шаблонными функциями, выбирается наиболее специализированная 
из них. Если существуют две или больше в одинаковой степени 
соответствующих нешаблонных функции, либо две или больше одинаково 
подходящих шаблонных функции с одной и той же степенью специализации, 
вызов функции рассматривается как неоднозначный и приводит к ошибке. 
При отсутствии функций, соответствующих вызову, также возникает ошибка.
	Обеспечение необходимого выбора.
В некоторых обстоятельствах можно заставить компилятор сделать необходимый
нам выбор, правильно написав вызов функции. Как и в случае обычных 
функций, определение шаблонной функции может действовать в качестве своего 
прототипа, если оно находится перед использованием функции. */
// choices.ерр — выбор шаблона
#include <iostream>

template<class T> // или template <typename T>
T lesser(T a, T b)         // #1 - явное создание экземпляра
{
    return a < b ? a : b;
}
int lesser (int a, int b)  // #2 - нешаблонная функция
{
    a = a < 0 ? -a : a;
    b = b < 0 ? -b : b;
    return a < b ? a : b;
}

int main()
{
using namespace std;
int m = 20;
int n = -30;
double x = 15.5;
double y = 25.9;

cout << lesser (m, n) << endl; 	// используется #2
cout << lesser(x, y) << endl; 	// используется #1 с double
cout << lesser<>(m, n) << endl; // используется #1 с int
cout << lesser<int>(x, y) << endl; // используется #1 с int
return 0;
}
/* В последнем вызове функции выполняется преобразование double в int, 
и некоторые компиляторы выдают предупреждение об этом.*/
cout << lesser (m, n) << endl; 	// используется #2
/* Аргументы в этом вызове соответствуют как шаблонной функции, так и 
нешаблонной функции, поэтому выбирается нешаблонная функция, которая 
возвращает значение 20. Следующий вызов функции соответствует шаблону, 
при этом T становится double: */
cout << lesser(x, y) << endl; 	// используется #1 с double
// Теперь такой оператор:
cout << lesser<>(m, n) << endl; // используется #1 с int
/* Наличие угловых скобок в lessero<>(m, n) указывает, что компилятор 
должен выбрать шаблонную функцию вместо нешаблонной, и компилятор, 
отметив, что фактические аргументы имеют тип int, создает экземпляр 
шаблона с использованием int для T.
Cледующий оператор: */
cout << lesser<int>(x, y) << endl; // используется #1 с int
/* Здесь мы имеем запрос на явное создание экземпляра с применением int 
для T, и эта функция будет использоваться. Значения х и у приводятся к 
типу int, и функция возвращает значение int, из-за чего программа 
отображает 15 вместо 15.5.
	Функции с множеством аргументов-типов.
	(Multiple Types) с шаблонами функции */
template< class T1, class T2, ... >
'...' /*означает, что стандарт шаблонов предусматривает возможность 
принять любое количество аргументов во время выполнения. Это просто 
показывает, что при определении шаблона (во время компиляции) можно 
задать любое нужное (определенное!) количество аргументов.
	Пример: */
template< class T1, class T2, class T3 >
T2 DoSomething(const T1 tArray[], T2 tDefaultValue, T3& tResult)
{
   ... 
}
/* Здесь T1 задает тип элементов массива, который был бы передан кодом, 
вызывающим функцию. Если массив (или указатель) не был передан, то 
компилятор выдаст соответствующую ошибку. Тип T2 используется также и 
как тип возвращаемого значения, а также как тип второго аргумента, 
который передается по значению. Тип T3 передается по ссылке (ссылке на 
не константу).
	Когда вызов функции с множеством аргументов сопоставляется с 
прототипами, содержащими несколько аргументов-типов, ситуация значительно 
усложняется. Компилятору приходится проверять соответствия всех аргументов. 
Если удается найти функцию, которая подходит лучше других кандидатов, она 
и будет выбрана. Одна функция имеет приоритет перед другой, если хотя бы 
один ее аргумент имеет приоритет перед аргументом другой функции, а все 
остальные аргументы обладают, по меньшей мере, одинаковыми приоритетами.
	Ключевое СЛОВО decltype. */
template<class T1, class T2>
void ft(Tl x, T2 у)
{
	?тип? хру = х + у;
}
// Каким должен быть тип для хру? 
int x;
decltype(x) y; // !делает тип у тем же, что и у x!
/* Аргументом decltype может быть выражение: */
decltype(x + y) хpy; // делает тип хру тем же, что и у x + у
xpy = x + y;
/* В качестве альтернативы эти два оператора могут быть скомбинированы 
внутри инициализации: */
decltype (x + y) хpy = x + y;
// Таким образом, шаблон ft() можно скорректировать:
template<class T1, class T2>
void ft(Tl x, T2 y)
{
	decltype (x + y) хpy = x + y;
}
/* Средство decltype несколько сложнее, чем может показаться на основе 
приведенных выше примеров. Для выбора типа компилятор должен пройти 
контрольный список. Предположим, что имеется такой код: */
deсltуре(выражение) ѵаr ;
/* Ниже представлена слегка упрощенная версия этого списка.
	Фаза 1. Если (выражение) является идентификатором без дополнительных 
круглых скобок, тогда ѵаr получит тот же самый тип, что у идентификатора, 
включая его квалификаторы, такие как const: */
double x = 5.5;
double у = 7.9;
double &rx = x;
const double * pd;
decltype(x) w; // w имеет тип double
decltype (rx) u = y; // u имеет тип double &
decltype(pd) v; // v имеет тип const double *
/*	Фаза 2. Если выражение является вызовом функции, тогда ѵаr имеет тип 
возвращаемого значения этой функции: */
long indeed(int);
decltype(indeed (3)) m; // m имеет тип int
/* Выражение в форме вызова функции не вычисляется. В этом случае 
компилятор берет возвращаемый тип из прототипа функции; в действительном 
вызове функции необходимости нет.
	Фаза 3. Если выражение является lvalue, тогда ѵаr будет ссылкой на тип 
выражения. Может показаться, что в предыдущих примерах переменная w должна 
была иметь ссылочный тип, учитывая, что w является lvalue. Однако вспомните, 
что этот случай уже был перехвачен на фазе 1. На данной фазе выражение не 
может быть идентификатором без дополнительных круглых скобок. А чем же 
тогда? Одна из очевидных возможностей — идентификатор с дополнительными 
круглыми скобками: */
double хх = 4.4;
decltype ((хх)) r2 = хх; // r2 имеет тип double &
decltype (хх) w = хх; // w имеет тип double (соответствие на фазе 1)
/* Круглые скобки не изменяют обычное значение или значение lvalue 
выражения. Например, следующие два оператора дают один и тот же эффект: */
хх = 98.6;
(хх) = 98.6; // () не влияют на использование хх
/*	Фаза 4. Если ни один из предыдущих специальных случаев не применим, 
тогда ѵаr имеет тот же тип, что и выражение: */
int j = 3;
int &k = j
int &n = j ;
decltype (j + 6) i1;// i1 имеет тип int
decltype(100L) i2;	// i2 имеет тип long
decltype (k+n) i3;	// iЗ имеет тип int;
/* Хотя k и n являются ссылками, выражение k+n — не ссылка; это просто сумма 
двух значений int, т.е. int. Когда необходимо более одного объявления, 
можно воспользоваться typedef с decltype: */
template<class Tl, class T2>
void ft(Tl x, T2 у)
{
	typedef decltype(x + y) xytype;
	xytype xpy = x + y;
	xytype arr[10];
	xytype & rxy = arr[2]; // rxy - ссылка
}
/*	Альтернативный синтаксис для функций
	(хвостовой возвращаемый тип С++11) */
template<class Tl, class T2>
?тип? gt(Tl x, T2 у)
{
	return x + у;
}
// Прототип
double h(int x, float у);
// может быть записан с помощью альтернативного синтаксиса следующим образом:
auto h(int x, float у) -> double;
/* Возвращаемый тип перемещен за объявления параметров. Комбинация
-> double называется хвостовым возвращаемым типом (trailing return type). 
Ключевое слово auto в C++11 является заполнителем для типа, предоставляемого 
хвостовым возвращаемым типом. Та же форма будет
использоваться в определении функции: */
auto h(int x, float у) -> double
{/* тело функции */};
/* Комбинируя новый синтаксис с decltype, указать возвращаемый тип для функции
gt() можно так: */
template<class T1, class T2>
auto gt(T1 х, Т2 у) -> decltype (х + у)
{
	return х + у;
}
/* Теперь decltype находится после объявлений параметров, поэтому х и у являются
видимыми и доступными для использования.

	Шаблоны класса
	В общем Вы используете шаблон класса чтобы определить абстрактный тип, 
поведение которого универсальное, и допускающее повторное и адаптируемое 
использование. */
template< class T >
class Item
{
    T Data;
public:
    Item() : Data( T() )
    {}
    void SetData(T nValue)
    {
        Data = nValue;
    }
    T GetData() const
    {
        return Data;
    }
    void PrintData()
    {
        cout << Data;
    }
};
/* ключевое слово class используется дважды - сначала для указания спецификации 
типа шаблона (T), и второй раз чтобы указать, что это декларация класса C++.
Вызов шаблона класаа: */
Item< int > item1;
item1.SetData(120);
item1.PrintData();
/*	В отличие от инициации функции шаблона, где аргументы вызова функции сами по 
себе помогают компилятору вывести типы аргумента шаблона, с шаблонами класса Вы 
должны явно передать тип шаблона (в угловых скобках).
Когда Вы создаете другой объект с отличающимся типом, то используйте шаблон 
класса Item, например, так: */
Item< float > item2;
float n = item2.GetData();
/*	Это приведет к инициации Item< float >.
Важно знать, что нет абсолютно никакой взаимосвязи между двумя инициациями 
шаблона класса - между Item< int > и Item< float >. Для компилятора и линкера 
это будут две абсолютно разные сущности - или, можно сказать, разные классы.
Первая инициация с типом int создаст следующие методы:
• Конструктор Item< int >::Item()
• Методы SetData и PrintData для типа int
Подобным образом вторая инициация с типом float создаст:
• Конструктор Item< float >::Item()
• Метод GetData для типа float
Как Вы знаете, Item< int > и Item< float > два разных класса / типа, так что 
такой код работать не будет: */
item1 = item2; // ERROR : Item< float > to Item< int >
               // (ошибка присвоения друг другу разных типов)
//В этой точке будет инициирован только следующий набор методов:
• Item< int >::Item() // - конструктор
• void Item< int >::SetData(int) // метод
• void Item< int >::PrintData() const // метод
• Item< float >::Item() // - конструктор
• float Item< float >::GetData() const // метод
//Следующие методы не пройдут вторую фазу компиляции:
• int Item< int >::GetData() const
• void Item< float >::SetData(float)
• void Item< float >::PrintData() const
/* код шаблона будет компилироваться с базовой проверкой синтаксиса, независимо 
от того, был ли он вызван / инициирован или нет. Это и есть так называемая первая 
фаза компиляции. Когда Вы вызываете метод, или как-нибудь вызываете срабатывание 
вызова функции / метода для частного типа (или типов) - только тогда выполняется 
специальная обработка кода метода, называемая второй фазой компиляции. Только 
после второй фазы компиляции код компилируется полностью, с использованием того 
типа, который был инициирован.
	Как Вы узнаете, прошла ли функция вторую фазу компиляции?
	Пример: */
T GetData() const
{ 
  T temp = Data[0]; // доступ по индексу ?
  return Data;
}
/* Теперь скомпилируйте код без вызова GetData для любого типа. Компилятор не 
выдаст ошибку, потому что в этом месте функция не получит обработки на второй 
фазе компиляции. Но как только Вы сделаете вызов: */
Item< double > item3;
item2.GetData();
/* то получите ошибку от компилятора "Data is not an array or pointer" (Data 
не является массивом или указателем), из-за оператора []. Оказывается, что 
только выбранные функции получили бы специальную привилегию на вторую фазу 
компиляции. И эта вторая фаза компиляции будет выполнена отдельно для всех 
уникальных типов, которые Вы инициировали для класса / функции.
	Одна интересная вещь, Вы можете сделать так: */
T GetData() const
{ 
  return Data % 10;
}
// Это успешно скомпилируется для Item< int >, но для Item< float > будет ошибка:
item1.GetData(); // item1 как Item< int >
 // ERROR
item2.GetData(); // item2 как Item< float >
/* Причина в том, что оператор % неприменим для типа float.

	Шаблоны класса с несколькими типами
	Пример:
есть структура Point */
struct Point
{
    int x;
    int y;
};
// в которой 2 поля данных. Потом у Вас может также быть другая структура Money:
struct Money
{
    int Dollars;
    int Cents;
};
/* Обе эти структуры имеют практически одинаковые типы полей данных. Вместо того, 
чтобы писать новые структуры, возможно было бы лучше держать структуру в одном 
месте, которое также упростит:
• У конструктора есть один или два аргумента указанного типа, и copy-конструктор.
• Методы для сравнения двух объектов одинакового типа.
• Перестановка между двумя типами
• И другие операции.
определим шаблон класса для 2 типов, имеющих все требуемые методы. */
template< class Type1, class Type2 >
struct Pair
{
    // Эти поля будут в области public, потому что нам нужно, чтобы
    // клиенты использовали эти поля напрямую.
    Type1 first;
    Type2 second;
};
/* Теперь мы можем использовать шаблон класса Pair, чтобы получить любой тип, в 
котором есть 2 поля. Например:
В качестве структуры Point */
Pair< int, int > point1;
 // Логически то же самое для полей X и Y
point1.first = 10;
point1.second = 20;
/* В этом случае типы первого и второго полей int и int соответственно. Это 
потому, что мы инициировали Pair этими типами.
Когда мы сделаем инициацию так: */
Pair< int, double > SqRoot;
SqRoot.first = 90;
SqRoot.second = 9.4868329;
/* то первое поле будет типа int, и второе поле будет типа double. Понятно, что 
первый и второй поля являются просто полями данных, это не функции, так что нет 
никаких затрат ресурсов во время выполнения вызова исходной функции.
	Следующий конструктор по умолчанию инициировал бы обоих членов их значениями 
по умолчанию согласно типам данных Type1 и Type2: */
Pair() : first(Type1()), second(Type2())
{}
/* Следующий параметризированный конструктор получает Type1 и Type2 для 
инициализации значений для полей first и second: */
Pair(const Type1& t1, const Type2& t2) : 
  first(t1), second(t2)
  {}
/* Далее copy-конструктор, который делает копию объекта Pair из другого объекта 
Pair точно такого же типа: */
Pair(const Pair< Type1, Type2 >& OtherPair) : 
  first(OtherPair.first),
  second(OtherPair.second)
  {}
/* Обратите внимание на то, что нужно обязательно указывать аргументы типа в 
шаблоне Pair< > для аргумента в этом copy-конструкторе. Следующая спецификация 
не была бы целесообразна, поскольку у Pair не шаблонный тип: */
Pair(const Pair& OtherPair) // ERROR: Pair requires template-types
                            // (ошибка: для Pair требуется типы шаблона)
// Вот примеры использования параметризированного конструктора и copy-конструктора:
Pair< int, int > point1(12,40);
Pair< int, int > point2(point1);
/* Важно отметить, что если Вы поменяете любые параметры типа шаблона или объектов 
point2 или point1, Вы не сможете использовать copy-конструктор для объекта point1. 
Здесь возникнет ошибка: */
Pair< int, float > point2(point1);  // ERROR: Different types, no conversion possible.
                                    // (ошибка: разные типы, преобразование невозможно)
/* Хотя компилятор может сделать конверсию при переводе float в int (с выдачей 
предупреждения), однако нет возможности конверсии от Pair< int, float > к 
Pair< int, int >. Конструктор копирования не может взять для источника копирования 
объект другого типа. Есть решение для этой проблемы, которое будет рассмотрена далее.
	Точно таким же образом Вы можете реализовать операторы сравнения, чтобы сравнить 
два объекта одинакового типа Pair. Вот реализация оператора эквивалентности (equal-to):*/
bool operator == (const Pair< Type1, Type2 >& Other) const
{
  return first == Other.first && 
         second == Other.second;
}
/* Обратите внимание, что я использовал атрибут const для самого метода. Как и при 
вызове copy-конструктора, Вы должны передать абсолютно те же самые типы для этого 
оператора сравнения - компилятор не будет пытаться преобразовать разные типы Pair. 
Например: */
if (point1 == point2) // оба сравниваемых объекта должны быть одного типа.
   ...
/* Для полного понимания концепции, рассмотренной здесь, пожалуйста реализуйте 
следующие методы самостоятельно:
• Все остальные 5 операторов отношения
• Оператор присваивания
• Метод перестановки (Swap)
• Модифицируйте оба конструктора (за исключением copy-конструктора), и скомбинируете 
его в один, который взял бы опа параметра по умолчанию. Это означает, что нужно 
реализовать только один конструктор, который может получать 0, 1 или 2 аргумента.

	Аргументы шаблона класса без типа
	позже..
	
/*	Указатели и ссылки с динамическими объектами
Попытки связать указатели с динамическими объектами часто приводят к недоразумениям. 
В сущности, они не имеют друг с другом ничего общего. Вы можете получить адрес 
стекового объекта и выполнить обратное преобразование, то есть разыменование 
(dereferencing) адреса динамического объекта. И на то, и на другое можно создать 
ссылку.*/
{
	foo f;
	foo* p = &f;
	f.MemberFn();	// Использует сам объект
	p->MemberFn();	// Использует его адрес
	p = new foo;
	foo& r = *p;		// Ссылка на объект
	r.MemberFn();	// То же, что и p->MemberFn()
}
/* Как видите, выбор оператора . или -> зависит от типа переменной и не имеет 
отношения к атрибутам самого объекта. Раз уж мы заговорили об этом, правильные 
названия этих операторов (. и ->) — селекторы членов класса (member selectors). 
Если вы назовете их «точкой» или «стрелкой» на семинаре с коктейлями, наступит 
гробовая тишина, все повернутся и презрительно посмотрят на вас, а в дальнем
углу кто-нибудь выронит свой бокал. */