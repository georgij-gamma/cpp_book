/*
1. Программируйте в соответствии с интерфейсом, а не с реализацией.
2. Предпочитайте композицию наследованию класса.
3. Делегирование — особый случай композиции, показывает, что наследование как механизм повторного 
использования всегда можно заменить композицией. При делегировании в процессе обработки запроса 
задействованы два объекта: получатель поручает выполнение операций другому объекту — уполномоченному 
(делегату). Например, вместо того чтобы делать класс Window (окно) подклассом класса Rectangle 
(прямоугольник) — ведь окно является прямоугольником, — мы можем воспользоваться внутри Window 
поведением класса Rectangle, поместив в класс Window переменную экземпляра типа Rectangle и делегируя 
ей операции, специфические для прямоугольников. Другими словами, окно не является прямоугольником, а 
содержит его. Теперь класс Window может явно перенаправлять запросы своей переменной Rectangle, а не 
наследовать ее операции.

	СРАВНЕНИЕ СТРУКТУР ВРЕМЕНИ ВЫПОЛНЕНИЯ И ВРЕМЕНИ КОМПИЛЯЦИИ
•	Агрегирование подразумевает, что один объект владеет другим или несет за него ответственность; объект 
содержит другой объект или является его частью; агрегат и его составляющие имеют одинаковое время жизни; 
на схемах обозначается сплошной линией со стрелкой и ромбиком в начале. Ещё агрегирование не означает, что 
по окончании жизненного цикла внешнего объекта, — автоматически окончится жизненный цикл внутреннего объекта.
Пример: страна агрегирует свои города (они являются её частью), но не уничтожает их при распаде страны: */
class Citizen {};
class Country
{   // используем указатель, чтобы предотвратить копирование сущностей (у нас не может быть
    // одновременно два "экземпляра" одного и того же города), а также владение ими.
    unordered_set<Citizen*> population;		// агрегируем контейнер указателей на города
public:
    void addCitizen(Citizen* pc)				// заносится указатель на город.
    {
        population.insert(pc);
    }
    void removeCitizen(Citizen* pc)			// удаляется указатель на город.
    {
        population.erase(pc);
    }

    ~Country() { /* не удаляем города, уничтожется только страна */ }
};
/* Если бы создавались объекты городов, а не указатели на них, - то при уничтожении страны, уничтожились бы
и города.
•	Осведомленность — это более слабое отношение, чем агрегирование; говорит о том, что объекту известно
о другом объекте; предполагает гораздо менее тесную связь между объектами; на схемах обозначается сплошной 
линией со стрелкой.

	ПРОЕКТИРОВАНИЕ С УЧЕТОМ БУДУЩИХ ИЗМЕНЕНИЙ
•	*/"При создании объекта явно указывается класс."/* Задание имени класса привязывает вас к 
конкретной реализации, а не к конкретному интерфейсу. Это может осложнить изменение объекта 
в будущем. Чтобы уйти от такой проблемы, создавайте объекты косвенно.
Паттерны проектирования: абстрактная фабрика, фабричный метод, прототип;
•	*/"Зависимость от конкретных операций."/* Задавая конкретную операцию, вы ограничиваете себя 
единственным способом выполнения запроса. Если же не включать запросы в код, то будет проще 
изменить способ удовлетворения запроса как на этапе компиляции, так и на этапе выполнения.
Паттерны проектирования: цепочка обязанностей, команда;
•	*/"Зависимость от аппаратной и программной платформ."/* Внешние интерфейсы операционной системы и 
интерфейсы прикладных программ (API) различны на разных программных и аппаратных платформах.
Если программа зависит от конкретной платформы, ее будет труднее перенести на другие. Возможно, 
даже на «родной» платформе такую программу трудно поддерживать. Поэтому при проектировании систем 
так важно ограничивать платформенные зависимости.
Паттерны проектирования: абстрактная фабрика, мост;
•	*/"Зависимость от представления или реализации объекта."/* Если клиент располагает информацией о 
том, как объект представлен, хранится или реализован, то, возможно, при изменении объекта 
придется изменять и клиента. Сокрытие этой информации от клиентов поможет уберечься от 
каскадных изменений.
Паттерны проектирования: абстрактная фабрика, мост, хранитель, заместитель;
•	*/"Зависимость от алгоритмов."/* Во время разработки и последующего использования алгоритмы часто
расширяются, оптимизируются и заменяются. Зависящие от алгоритмов объекты придется переписывать при 
каждом изменении алгоритма. Поэтому алгоритмы, которые с большой вероятностью будут изменяться, 
следует изолировать.
Паттерны проектирования: мост, итератор, стратегия, шаблонный метод, посетитель;
•	*/"Сильная связанность."/* Сильно связанные между собой классы трудно использовать порознь, так 
как они зависят друг от друга. Сильная связанность приводит к появлению монолитных систем, в которых 
нельзя ни изменить, ни удалить класс без знания деталей и модификации других классов. Такую систему 
трудно изучать, переносить на другие платформы и сопровождать.
Паттерны проектирования: абстрактная фабрика, мост, цепочка обязанностей, команда, фасад,
посредник, наблюдатель;
•	*/"Расширение функциональности за счет порождения подклассов."/* Специализация объекта путем 
создания подкласса часто оказывается непростым делом. С каждым новым подклассом связаны 
фиксированные издержки реализации (инициализация, очистка и т. д.). Для определения подкласса 
необходимо так же ясно представлять себе устройство родительского класса. Например, замещение 
одной операции может потребовать замещения и других. Кроме того, порождение подклассов ведет к 
разрастанию количества классов, поскольку даже для реализации простого расширения приходится 
создавать новые подклассы. Композиция объектов и делегирование — гибкие альтернативы наследованию
для комбинирования поведений. Приложению можно добавить новую функциональность, меняя способ 
композиции объектов, а не определяя новые подклассы уже имеющихся классов.
Паттерны проектирования: мост, цепочка обязанностей, компоновщик, декоратор, наблюдатель, стратегия;
•	*/"Неудобства при изменении классов."/* Иногда нужно модифицировать класс, но делать это неудобно.
 Допустим, вам нужен исходный код, а он недоступен (так обстоит дело с коммерческими библиотеками 
классов). Или любое изменение тянет за собой модификации множества существующих подклассов. 
Благодаря паттернам проектирования можно модифицировать классы и при таких условиях.
Паттерны проектирования: адаптер, декоратор, посетитель.

	Инструментальная библиотека — это набор взаимосвязанных, повторно используемых классов, 
спроектированный с целью предоставления полезной функциональности общего назначения. В
инструментальных библиотеках упор делается на повторном использовании кода. Это объектно-
ориентированные эквиваленты библиотек подпрограмм.
	Каркас — это набор взаимодействующих классов, составляющих повторно используемый дизайн для 
конкретного класса программ. Каркас можно адаптировать для конкретного приложения
путем порождения специализированных подклассов от входящих в него абстрактных классов. Каркас 
определяет общую структуру, ее разделение на классы и объекты, ключевые обязанности тех и 
других, методы взаимодействия объектов и классов и потоки управления. Акцент в каркасе делается 
на повторном использовании дизайна, а не кода, хотя обычно он включает и конкретные подклассы, 
которые можно применять непосредственно. Повторное использование на данном уровне означает 
инверсию контроля между приложением и программным обеспечением, лежащим в его основе. При 
использовании инструментальной библиотеки (или, если хотите, обычной библиотеки подпрограмм) 
вы пишете основной код приложения и вызываете из него код, который планируете использовать 
повторно. При работе с каркасом вы, наоборот, повторно используете основной код и пишете код, 
который он вызывает. Вам приходится кодировать операции с предопределенными именами и 
параметрами вызова, но зато число принимаемых вами проектных решений сокращается.
	Если проектировать приложения нелегко, инструментальные библиотеки — еще сложнее, то 
проектирование каркасов — задача самая трудная! Поскольку приложения так сильно зависят от 
каркаса, они особенно чувствительны к изменениям его интерфейсов. По мере усложнения каркаса 
приложения должны эволюционировать вместе с ним. В результате существенно возрастает значение 
слабой связанности, в противном случае малейшее изменение каркаса приведет к целой волне 
модификаций.
	Различия между паттернами и каркасами:
•	*/"Паттерны проектирования более абстрактны, чем каркасы."/* В код могут быть включены целые 
каркасы, но только отдельные воплощения паттернов. Каркасы можно писать на разных языках 
программирования и не только изучать, но и непосредственно исполнять и повторно использовать.
Паттерны проектирования, необходимо реализовывать всякий раз, когда в них возникает 
необходимость. Паттерны объясняют намерения проектировщика, сильные и слабые стороны, а также 
последствия выбранного дизайна;
•	*/"Как архитектурные элементы, паттерны проектирования мельче, чем каркасы."/* Типичный 
каркас содержит несколько паттернов. Обратное утверждение неверно;
•	*/"Паттерны проектирования менее специализированы, чем каркасы."/* Каркас всегда создается 
для конкретной предметной области. В принципе каркас графического редактора можно использовать 
для моделирования работы фабрики, но его никогда не спутаешь с каркасом, предназначенным 
специально для моделирования. Напротив, паттерны могут использоваться в приложениях любого вида.
	
	КАК ВЫБИРАТЬ ПАТТЕРН ПРОЕКТИРОВАНИЯ
	*/"Подумайте, как паттерны решают проблемы проектирования."/*
	*/"Пролистайте разделы каталога, описывающие назначение паттернов."/*
	*/"Изучите взаимосвязи паттернов."/*
	*/"Проанализируйте паттерны со сходными целями."/*
	*/"Разберитесь в причинах, вызывающих перепроектирование."/*
	*/"Посмотрите, какие аспекты вашего дизайна могут измениться."/* Вместо того чтобы думать, 
что могло бы заставить изменить дизайн, подумайте о том, что бы вам хотелось иметь возможность 
изменять без перепроектирования. Акцент здесь делается на инкапсуляции концепций, подверженных 
изменениям — основной теме многих паттернов. Аспекты дизайна, которые могут изменяться при 
применении паттернов проектирования: */
	Назначение			|Паттерн проектирования	|Переменные аспекты
======================================================================================================
Порождающие паттерны	|Абстрактная фабрика	| Семейства порождаемых объектов.
						|Одиночка				| Единственный экземпляр класса.
						|Прототип				| Класс, на основе которого создается объект.
						|Строитель				| Способ создания составного объекта.
						|Фабричный метод		| Подкласс создаваемого объекта.
------------------------------------------------------------------------------------------------------
Структурные паттерны	|Адаптер				| Интерфейс к объекту.
						|Декоратор				| Обязанности объекта без порождения подкласса.
						|Заместитель			| Способ доступа к объекту, его местоположение.
						|Компоновщик			| Структура и состав объекта.
						|Мост					| Реализация объекта.
						|Приспособленец			| Затраты на хранение объектов.
						|Фасад					| Интерфейс к подсистеме.
------------------------------------------------------------------------------------------------------
Паттерны поведения		|Интерпретатор			| Грамматика и интерпретация языка.
						|Итератор				| Способ перебора элементов агрегата.
						|Команда				| Время и способ выполнения запроса.
						|Наблюдатель			| Множество объектов, зависящих от другого 
						|						|объекта; способ, которым зависимые объекты 
						|						|поддерживают себя в актуальном состоянии.
						|Посетитель				| Операции, которые могут применяться к 
						|						|объекту или объектам, не меняя класса.
						|Посредник				| Взаимодействующие объекты и механизм их 
						|						|совместной работы.
						|Состояние				| Состояние объекта.
						|Стратегия				| Алгоритм.
						|Хранитель				| Закрытая информация, хранящаяся вне объекта, 
						|						|и время ее сохранения.
						|Цепочка обязанностей	| Объект, выполняющий запрос.
						|Шаблонный метод		| Шаги алгоритма.
======================================================================================================
/*	Последовательность действий, которая поможет вам эффективно применить паттерн:
1. Прочитайте описание паттерна, чтобы получить о нем общее представление.
2. Изучите разделы «Структура», «Участники» и «Отношения».
3. Просмотрите раздел «Пример кода» с конкретным примером применения паттерна в программе.		
4. Выберите для участников паттерна подходящие имена. Бывает полезно включить имя участника 
как составную часть имени, используемого в программе. Например, если вы пользуетесь паттерном 
стратегия в алгоритме размещения текста, то классы могли бы называться SimpleLayoutStrategy 
или TeXLayoutStrategy.
5. Определите классы. Объявите их интерфейсы, установите отношения наследования и определите 
переменные экземпляра, представляющие данные объекта и ссылки на другие объекты. Выявите в своем 
приложении классы, на которые паттерн оказывает влияние, и соответствующим образом модифицируйте их.
6. Определите имена операций, встречающихся в паттерне. Здесь,  имена обычно зависят от приложения.
Руководствуйтесь теми функциями и взаимодействиями, которые ассоциированы с каждой операцией. 
Кроме того, будьте последовательны при выборе имен. Например, для обозначения фабричного метода 
можно было бы всюду использовать префикс 'Create-'.
7. Реализуйте операции, которые выполняют обязанности и обеспечивают взаимодействия, определенные 
в паттерне.

	ПАТТЕРН Компоновщик
 Назначение:
• Компонует объекты в древовидные структуры для представления иерархий «часть — целое».
Позволяет клиентам единообразно трактовать индивидуальные и составные объекты. Ключом к 
паттерну компоновщик является абстрактный класс, который представляет одновременно и 
примитивы, и контейнеры.

 Применимость:
• Требуется представить иерархию объектов вида «часть — целое»;
• Клиенты должны по единым правилам работать с составными и индивидуальными объектами.

 Результаты:
• */"Определяет иерархии классов, состоящие из примитивных и составных объектов."/* Из примитивных 
объектов можно составлять более сложные, которые, в свою очередь, участвуют в более сложных 
композициях и так далее;
• */"Упрощает архитектуру клиента."/* Клиенты могут единообразно работать с индивидуальными и 
объектами и с составными структурами. Это упрощает код клиента, поскольку нет необходимости 
писать функции, ветвящиеся в зависимости от того, с объектом какого класса они работают;
• */"Облегчает добавление новых видов компонентов."/* Изменять клиент при добавлении новых 
компонентов не нужно;
• */"Способствует созданию общего дизайна."/*

 Реализация:
• */"Явные ссылки на родителей."/* Хранение в компоненте ссылки на своего родителя может упростить обход 
структуры и управление ею. Наличие такой ссылки облегчает передвижение вверх по структуре и удаление
компонента. Кроме того, ссылки на родителей помогают реализовать паттерн цепочка обязанностей. При 
наличии ссылки на родителя важно поддерживать следующий инвариант: для всех потомков в составном 
объекте родителем является составной объект, для которого они в свою очередь являются потомками. 
Простейший способ гарантировать соблюдение этого условия — изменять родителя компонента только тогда, 
когда он добавляется или удаляется из составного объекта. Если это удается один раз реализовать в 
операциях Add и Remove, то реализация будет унаследована всеми подклассами, а следовательно, 
инвариант будет поддерживаться автоматически;
• */"Совместное использование компонентов."/* Возможное решение — позволить компонентам хранить ссылки 
на нескольких родителей. Паттерн приспособленец показывает, как следует изменить дизайн, чтобы 
вовсе отказаться от хранения родителей. Работает он в тех случаях, когда потомки могут избежать 
отправки сообщений своим родителям, вынеся за свои границы часть внутреннего состояния;
• */"Максимизация интерфейса базового (абстрактного) для компоновщика класса (Component)."/* Одна из 
целей паттерна компоновщик — избавить клиентов от необходимости знать, работают ли они с примитивным 
или составным объектом. Для достижения этой цели класс Component должен сделать как можно больше 
операций общими для Composite и примитывных классов. Однако иногда эта цель вступает в конфликт с 
принципом проектирования иерархии классов, согласно которому класс должен определять только логичные 
для всех его подклассов операции. Класс Component поддерживает много операций, не имеющих смысла для
примитывных классов. Как же тогда предоставить для них реализацию по умолчанию? Если рассматривать 
примитывные классы как Component, у которых никогда не бывает потомков, то в классе Component можно 
определить операцию обращения к потомкам как никогда не возвращающую потомков. Тогда примитывные 
подклассы могут использовать эту реализацию по умолчанию, а в подклассах Composite она будет 
переопределена, чтобы возвращать потомков.
• */"Объявление операций для управления потомками."/* Хотя в классе Composite реализованы операции 
Add и Remove для добавления и удаления потомков, но для паттерна компоновщик важно, в каких 
классах эти операции объявлены. Надо ли объявлять их в классе Component и тем самым делать 
доступными в примитывных классах, или их следует объявить и определить только в классе Composite 
и его подклассах? Ответ на этот вопрос подразумевает компромисс между безопасностью и прозрачностью:
1. Если определить интерфейс для управления потомками в корне иерархии классов, мы добиваемся 
прозрачности, так как все компоненты удается трактовать единообразно. Однако за это приходится 
расплачиваться безопасностью, поскольку клиент может попытаться выполнить бессмысленное действие 
вроде добавления или удаления объекта из примитивного узла;
2. Если управление потомками определяется в классе Компоновщике, то безопасность будет обеспечена — 
ведь любая попытка добавить или удалить объекты из примитывных классов в статически типизированном 
языке вроде C++ будет перехвачена на этапе компиляции. Но прозрачность при этом теряется, так как 
примитывные и составные объекты обладают разными интерфейсами.
 В паттерне компоновщик мы придаем особое значение прозрачности, а не безопасности. Если важнее 
безопасность, будьте готовы к тому, что в некоторых случаях вы можете потерять информацию о типе, 
и компонент придется преобразовывать к типу составного объекта. Как это сделать, не прибегая к 
небезопасным приведениям типов? Можно объявить в классе Component операцию Composite* getComposite().
Класс Component реализует ее по умолчанию, возвращая null-указатель. А в классе Composite эта 
операция переопределена, чтобы она возвращала текущий объект в виде указателя this: */
class Composite;					// компоновщик
class Component						// Абстрактный базовый класс
{
public:
	// ...
	virtual Composite * getComposite() { return nullptr; }	// по умолчанию
};
class Composite : public Component	// компоновщик
{
public:
	void Add(Component *);
	// ...
	virtual Composite* getComposite() { return this; }		// переопределен
};
class Leaf : public Component		// примитывный класс
{
	// ...
};
/* Благодаря операции getComposite можно спросить у компонента, является ли он составным. К 
возвращаемому этой операцией составному объекту допустимо безопасно применять операции Add и Remove: */
Composite * aComposite = new Composite;
Leaf * aLeaf = new Leaf;
Component * aComponent;
Composite * test;
aComponent = aComposite;
if (test = aComponent->getComposite())	// aComposite != nullptr
{
	test->Add(new Leaf);					// добавить в менеджер компоновки примитив
}
aComponent = aLeaf;
if (test = aComponent->getComposite())	// aLeaf == nullptr
{
	test->Add(new Leaf);					// лист не добавляется: getComposite() не переопределен в Leaf
}
/* Аналогичные проверки на принадлежность классу Composite в C++ выполняются с помощью оператора dynamic_cast 
и typeid, тогда метод getComposite() не нужен. Если виртуальный метод вызывается через ссылку или 
указатель на объект, то программа использует метод, определенный для типа объекта, а не для типа указателя 
или ссылки. Это называется динамическим (или поздним) связыванием. Такое поведение очень важно, т.к. 
указатель или ссылка на базовый класс всегда может обратиться к объекту производного типа. */
//if( test = dynamic_cast<Composite *>(*aComponent) )	// возвращает true, если aComponent указывает на Composite и его потомков!
#include <typeinfo>		// явное именование каждого класса:
if( typeid(Composite) == typeid(*aComponent) )		// возвращает true, если aComponent указывает на Composite only.
	test->Add(new Leaf);								// добавить в менеджер компоновки примитив
/* Недостаток: снова приходится проверять тип, перед тем как предпринять то или иное действие.
Единственный способ обеспечить прозрачность — это включить в класс Component реализации операций Add и Remove по умолчанию. 
Но тогда появится новая проблема: нельзя реализовать Component::Add так, чтобы не появилась возможность ошибки. Можно, конечно, 
сделать данную операцию пустой, но тогда нарушается важное проектное ограничение: попытка добавить что-то в примитивный объект, 
скорее всего, свидетельствует об ошибке. Допустимо было бы заставить ее удалять свой аргумент, но такое поведение может оказаться 
неожиданным для клиента. Лучшим решением является такая реализация Add и Remove по умолчанию, при которой они завершаются с 
ошибкой (возможно, генерируя исключение), если компоненту не разрешено иметь потомков (для Add) или аргумент не является 
чьим-либо потомком (для Remove). Другая возможность — слегка изменить семантику операции «удаление». Если компонент хранит 
ссылку на родителя, то можно было бы считать, что Component::Remove удаляет самого себя;
• */"Должен ли Component реализовывать список компонентов?"/* Можно определить множество потомков в виде переменной экземпляра 
класса Component, в котором объявлены операции обращения к потомкам и управления ими. Но размещение указателя на потомков в 
базовом классе создает лишние затраты памяти во всех примитивных узлах, хотя у примитива потомков быть не может. Такое решение 
может использоваться только в том случае, если в структуре относительно мало потомков;
• */"Упорядочение потомков."/* Во многих случаях важен порядок следования потомков составного объекта. В примере класса Component 
под порядком может пониматься Z-порядок расположения потомков. В составных объектах, описывающих деревья синтаксического разбора, 
составные операторы могут быть экземплярами класса Composite, порядок следования потомков которых отражает семантику программы.
Если порядок следования потомков важен, необходимо учитывать его при проектировании интерфейсов доступа и управления потомками. 
В этом может помочь паттерн итератор;
• */"Кэширование для повышения производительности."/* Если приходится часто выполнять обход или поиск в композициях, то класс 
Composite может кэшировать либо непосредственно полученные результаты, либо только информацию, достаточную для ускорения обхода 
или поиска. Например, класс Picture(типа Composite), мог бы кэшировать охватывающие прямоугольники своих потомков. При 
рисовании или выделении эта информация позволила бы пропускать тех потомков, которые не видимы в текущем окне.
При любом изменении компонента кэшированная информация всех его родителей должна становиться недействительной. Наиболее 
эффективен такой подход в случае, когда компонентам известно об их родителях. Поэтому, если вы решите воспользоваться 
кэшированием, необходимо определить интерфейс, позволяющий уведомить составные объекты о недействительности содержимого их кэшей;
• */"Кто должен удалять компоненты?"/* В языках, где нет уборщика мусора, лучше всего поручить классу Composite удалять своих потомков 
в момент уничтожения. Исключением из этого правила является случай, когда примитивные объекты постоянны и, следовательно, могут 
использоваться совместно;
• */"Выбор структуры данных для хранения компонентов."/* Составные объекты могут хранить своих потомков в самых разных структурах 
данных, включая связанные списки, деревья, массивы и хеш-таблицы. Выбор структуры данных определяется, как всегда, эффективностью. 
Вовсе не обязательно пользоваться какой-либо из универсальных структур. Иногда в составных объектах каждый потомок представляется 
отдельной переменной. Правда, для этого каждый подкласс Composite должен реализовывать свой собственный интерфейс управления 
памятью. См. пример в описании паттерна интерпретатор. Пример кода:
Класс Equipment определяет интерфейс для всех видов аппаратуры в иерархии вида «часть — целое»: */
class Equipment
{
public:
	virtual ~Equipment();
	const char* Name() { return _name; }
	virtual Watt Power();					// мощность
	virtual Currency NetPrice();				// цена нетто
	virtual Currency DiscountPrice();		// цена со скидкой
	virtual void Add(Equipment*);
	virtual void Remove(Equipment*);
	virtual Iterator* CreateIterator();
protected:
	Equipment(const char*);
private:
	const char* _name;
};
/* В классе Equipment объявлены операции, которые возвращают атрибуты аппаратного блока, например энергопотребление 
и стоимость. Подклассы реализуют эти операции для конкретных видов оборудования. Класс Equipment объявляет также 
операцию CreateIterator, возвращающую итератор Iterator (см. приложение В) для обращения к отдельным частям. Реализация 
этой операции по умолчанию возвращает итератор NullIterator, умеющий обходить только пустое множество.
Среди подклассов Equipment могут быть примитивные классы, представляющие дисковые накопители, микросхемы и переключатели: */
class FloppyDisk : public Equipment
{
public:
	FloppyDisk(const char*);
	virtual ~FloppyDisk();
	virtual Watt Power();
	virtual Currency NetPrice();
	virtual Currency DiscountPrice();
};
/* CompositeEquipment — это базовый класс для оборудования, содержащего другое оборудование. Одновременно это подкласс 
класса Equipment: */
class CompositeEquipment : public Equipment {
public:
	virtual ~CompositeEquipment();
	virtual Watt Power();
	virtual Currency NetPrice();
	virtual Currency DiscountPrice();
	virtual void Add(Equipment*);
	virtual void Remove(Equipment*);
	virtual Iterator* CreateIterator();
protected:
	CompositeEquipment(const char*);
private:
	List _equipment;
};
/* CompositeEquipment определяет операции для доступа и управления внутренними аппаратными блоками. Операции Add и 
Remove добавляют и удаляют оборудование из списка, хранящегося в переменной _equipment. Операция CreateIterator 
возвращает итератор (точнее, экземпляр класса ListIterator), который будет обходить этот список. Реализация по 
умолчанию операции NetPrice могла бы использовать CreateIterator для суммирования цен на отдельные блоки: */
Currency CompositeEquipment::NetPrice()
{
	Iterator * i = CreateIterator();
	Currency total = 0;
	
	for ( i->First(); !i->IsDone(); i->Next() )
		total += i->CurrentItem()->NetPrice();

	delete i;
	return total;
}
/* Теперь мы можем представить аппаратный блок компьютера в виде подкласса к CompositeEquipment под названием Chassis. 
Chassis наследует порожденные операции класса CompositeEquipment: */
class Chassis : public CompositeEquipment
{
public:
	Chassis(const char*);
	virtual ~Chassis();
	virtual Watt Power();
	virtual Currency NetPrice();
	virtual Currency DiscountPrice();
};
/* Аналогичным образом можно определить и другие контейнеры для оборудования, например Cabinet (корпус) и Bus (шина). 
Этого вполне достаточно для сборки из отдельных блоков (довольно простого) персонального компьютера: */
Cabinet	* cabinet = new Cabinet("PC Cabinet");
Chassis	* chassis = new Chassis("PC Chassis");
cabinet	->Add (chassis);
Bus 	* bus = new Bus("MCA Bus");
bus		->Add (new Card("16Mbs Token Ring"));
chassis	->Add (bus);
chassis	->Add (new FloppyDisk("3.5in Floppy"));
cout	<< "The net price is " << chassis->NetPrice() << endl;
/* Родственные паттерны:
 Отношение «компонент — родитель» используется в паттерне цепочка обязанностей.
Паттерн декоратор часто применяется совместно с компоновщиком. Когда декораторы и компоновщики используются вместе, 
у них обычно бывает общий родительский класс. Поэтому декораторам придется поддержать интерфейс компонентов такими 
операциями, как Add, Remove и GetChild.
Паттерн приспособленец позволяет совместно использовать компоненты, но ссылаться на своих родителей они уже не могут.
Итератор можно использовать для обхода составных объектов.
Посетитель локализует операции и поведение, которые в противном случае пришлось бы распределять между классами Composite и Leaf.

	ГЛИФЫ
 Абстрактный класс Glyph (глиф) определяется для всех объектов, которые могут присутствовать в структуре документа. Его 
подклассы определяют как примитивные графические элементы (символы, изображения..), так и структурные элементы 
(строки и колонки). */
class Glyph									// Абстрактный класс Glyph
{
	// Внешнее представление:
	virtual void Draw(Window*)				// перерисовывает текущий объект в окне
	virtual void Bounds(Rect&)				// возвращает прямоугольную область, занимаемую глифом
	
	// Обнаружение точки воздействия:
	virtual bool Intersects(const Point&)	// возвращает признак, показывающий, лежит ли заданная точка в пределах глифа
	
	// Структура:
	virtual void Insert(Glyph*, int)			// вставляет глиф в позицию, заданную целочисленным индексом (или указателем из списка)
	virtual void Remove(Glyph*)				// удаляет глиф
	virtual Glyph* Child(int)				// возвращает потомка с заданным индексом (если таковой существует)
	virtual Glyph* Parent()					// предоставляет стандартный интерфейс для доступа к родителю глифа, если таковой имеется
}
/* Глифы, у которых действительно есть потомки (такие как Row), должны пользоваться операцией Child, а не обращаться к структуре 
данных потомка напрямую. В таком случае при изменении структуры данных, скажем, с массива на связанный список не придется 
модифицировать операции вроде Draw, которые перебирают всех потомков. */
class Rectangle: public Glyph
{
private:
	int _x0, _y0, _x1, _y1;					// определяют два противоположных угла прямоугольника
public:
	void Draw (Window* w);
}
void Rectangle::Draw (Window* w)
{
	w->DrawRect(_x0, _y0, _x1, _y1); 		// DrawRect — операция класса Window, рисующая на экране прямоугольник
}

/*	ФОРМАТИРОВАНИЕ
 Представление и форматирование — это разные аспекты проектирования. По описанию внутренней структуры невозможно определить, 
как добраться до определенной подструктуры. Базовый интерфейс класса Compositor: */
class Compositor: public Glyph
{
public:
	void SetComposition(Composition *);		// что форматировать
	virtual void Compose();					// когда форматировать
}
/* Compositor (специализированный для конкретного алгоритма разбиения на строки) в нужные моменты предписывает 
строить композицию глифов по мере изменения документа пользователем.
	ИНКАПСУЛЯЦИЯ АЛГОРИТМА ФОРМАТИРОВАНИЯ
 Важно выдержать баланс между качеством и скоростью форматирования. Также возможен компромисс между временем и памятью, 
в большей степени ориентированный на реализацию: кэширование в памяти большего объема информации может уменьшить время 
форматирования. Поскольку алгоритмы форматирования обычно оказываются весьма сложными, желательно, чтобы они были 
достаточно замкнутыми, а еще лучше — полностью независимыми от структуры документа. С другой стороны, при добавлении 
нового алгоритма форматирования не должно возникать необходимости в модификации существующих глифов. Мы должны постараться 
спроектировать приложение так, чтобы алгоритм форматирования можно было легко заменить на этапе компиляции, если уж не 
во время выполнения. Алгоритм можно изолировать и обеспечить возможность его простой замены путем инкапсуляции в объекте:
определть отдельную иерархию классов для объектов, инкапсулирующих алгоритмы форматирования. Корнем иерархии станет интерфейс, 
который поддерживает широкий спектр алгоритмов, а каждый подкласс будет реализовывать этот интерфейс в виде конкретного алгоритма 
форматирования. Тогда удастся ввести подкласс класса Glyph, который будет автоматически структурировать своих потомков с помощью  
переданного ему объекта-алгоритма.
	КЛАССЫ COMPOSITOR И COMPOSITION
 Неформатированный объект Composition содержит только видимые глифы, составляющие основное содержание документа. В нем нет глифов,
определяющих физическую структуру документа, например Row и Column. В таком состоянии композиция находится сразу после создания и
инициализации глифами, которые должна отформатировать. Во время форматирования композиция вызывает операцию Compose своего объекта
Compositor. Композитор обходит всех потомков композиции и вставляет новые глифы Row и Column в соответствии со своим алгоритмом 
разбиения на строки (композитор должен получить коды символов глифов Character, чтобы вычислить места разбиения на строки).
Каждый подкласс класса Compositor может реализовывать свой собственный алгоритм разбиения на строки. Например, класс 
SimpleCompositor мог бы осуществлять быстрый проход, не обращая внимания на «цвет» документа (равномерное распределение текста и 
пустого пространства). А класс TeXCompositor мог бы реализовывать полный алгоритм TeX [Knu84], учитывающий наряду со многими 
другими вещами и цвет, но за счет увеличения времени форматирования. Наличие классов Compositor и Composition позволяет отделить 
код, поддерживающий физическую структуру документа, от кода алгоритмов форматирования. Мы можем добавить новые подклассы для 
класса Compositor, не трогая классов глифов, и наоборот. Фактически для замены алгоритма разбиения на строки во время выполнения 
достаточно добавить единственную операцию SetCompositor к базовому интерфейсу класса Composition.

	ПАТТЕРН STRATEGY (СТРАТЕГИЯ) (Policy)
 Название и классификация паттерна:
• */"Стратегия — паттерн поведения объектов."/*
 Назначение:
• */"Определяет семейство алгоритмов, инкапсулирует каждый из них и делает их взаимозаменяемыми"/*. Позволяет изменять 
алгоритмы независимо от клиентов, которые ими пользуются.
 Применение:
• */"Ключ к применению паттерна стратегия — проектирование интерфейсов стратегии и контекста,"/* достаточно общих для поддержки 
широкого диапазона алгоритмов. Поддержка нового алгоритма не должна требовать изменения интерфейса стратегии или контекста.
 Мотивация:
 Существует много алгоритмов для разбиения текста на строки. Жестко «зашивать» все подобные алгоритмы в классы, которые в 
них нуждаются, нежелательно по нескольким причинам:
• */"клиент, которому требуется алгоритм разбиения на строки, усложняется при включении в него соответствующего кода."/* Таким 
образом, клиенты становятся более громоздкими и создают больше сложностей в сопровождении, особенно если нужно поддерживать 
сразу несколько алгоритмов;
• */"В зависимости от обстоятельств могут применяться разные алгоритмы"/*, неэффективно поддерживать несколько алгоритмов разбиения 
на строки, если мы не будем ими пользоваться;
• */"Если разбиение на строки является неотъемлемой частью клиента"/*, то задачи добавления новых и модификации существующих 
алгоритмов усложняются.
 Всех этих проблем можно избежать, если определить классы, инкапсулирующие различные алгоритмы разбиения на строки. 
Инкапсулированный таким образом алгоритм называется стратегией. Допустим, класс Composition отвечает за разбиение на строки 
текста, отображаемого в окне программы просмотра, и его своевременное обновление. Стратегии разбиения на строки определяются 
не в классе Composition, а в подклассах абстрактного класса Compositor. Объект Composition хранит ссылку на объект Compositor. 
Всякий раз, когда объекту Composition требуется переформатировать текст, он делегирует данную обязанность своему объекту 
Compositor. Чтобы указать, какой объект Compositor должен использоваться, клиент встраивает его в объект Composition.
 Применимость:
• */"Наличие множества родственных классов, отличающихся только поведением."/* Стратегия позволяет настроить класс одним из 
многих возможных вариантов поведения;
• */"Наличие нескольких разновидностей алгоритма."/* Стратегии разрешается применять, когда варианты алгоритмов реализованы 
в виде иерархии классов;
• */"В алгоритме содержатся данные, о которых клиент не должен «знать»."/* Используйте паттерн стратегия, чтобы не раскрывать 
сложные, специфичные для алгоритма структуры данных;
• */"В классе определено много вариантов поведения, представленных разветвленными условными операторами."/* В этом случае проще 
перенести код из ветвей в отдельные классы стратегий.
 Участники:
	Strategy (Compositor) — стратегия:
• */"Объявляет общий для всех поддерживаемых алгоритмов интерфейс."/* Класс Context пользуется этим интерфейсом для вызова 
конкретного алгоритма, определенного в классе ConcreteStrategy;
	ConcreteStrategy (SimpleCompositor, TeXCompositor, ArrayCompositor) — конкретная стратегия:
• */"Реализует алгоритм, использующий интерфейс, объявленный в классе Strategy"/* ;
	Context (Composition) — контекст:
• */"Настраивается объектом класса ConcreteStrategy"/*;
• */"Хранит ссылку на объект класса Strategy"/*;
• */"Может определять интерфейс, который позволяет объекту Strategy обращаться к данным контекста."/*
 Отношения:
• */"Классы Strategy и Context взаимодействуют для реализации выбранного алгоритма."/* Контекст может передать стратегии все 
необходимые алгоритму данные в момент его вызова. Вместо этого контекст может позволить обращаться к своим операциям в 
нужные моменты, передавая ссылку на самого себя операциям класса Strategy;
• */"Контекст переадресует запросы своих клиентов объекту-стратегии."/* Обычно клиент создает объект ConcreteStrategy и 
передает его контексту, после чего клиент взаимодействует исключительно с контекстом. Часто в распоряжении клиента находится 
несколько классов ConcreteStrategy, которые он может выбирать.
 Результаты:
• */"Семейства родственных алгоритмов."/* Иерархия классов Strategy определяет семейство алгоритмов или вариантов поведения, 
которые можно повторно использовать в разных контекстах. Наследование позволяет вычленить общую для всех алгоритмов функциональность;
• */"Альтернатива порождению подклассов."/* Наследование поддерживает многообразие алгоритмов или поведений. Можно напрямую породить 
от Context подклассы с различными поведениями. Но при этом поведение жестко «зашивается» в класс Context. Реализации алгоритма и 
контекста смешиваются, что затрудняет понимание, сопровождение и расширение контекста. Кроме того, заменить алгоритм динамически 
уже не удастся. В результате вы получаете множество родственных классов, отличающихся только алгоритмом или поведением. Инкапсуляция 
алгоритма в отдельный класс Strategy позволяет изменять его независимо от контекста;
• */"Стратегии позволяют избавиться от условных конструкций."/* Когда различные поведения помещаются в один класс, трудно выбрать 
нужное без применения условных операторов. Инкапсуляция же каждого поведения в отдельный класс Strategy решает эту проблему.
Так, без использования стратегий код для разбиения текста на строки мог бы выглядеть следующим образом: */
void Composition::Repair()
{
	switch (_breakingStrategy)
	{
		case SimpleStrategy:
			ComposeWithSimpleCompositor();
		break;
		case TeXStrategy:
			ComposeWithTeXCompositor();
		break;
		// ...
	}
	// При необходимости объединить результаты с существующей композицией
}
/* Паттерн стратегия позволяет обойтись без конструкции выбора за счет делегирования задачи разбиения на строки объекту Strategy: */
void Composition::Repair()
{
	_compositor->Compose();
	// При необходимости объединить результаты с существующей композицией
}
/* Если код содержит много условных операторов, то часто это признак того, что нужно применить паттерн стратегия;
• */"Выбор реализации."/* Стратегии могут предлагать различные реализации одного и того же поведения. Клиент вправе выбирать 
подходящую стратегию в зависимости от своих требований к быстродействию и памяти;
• */"Клиенты должны знать о различных стратегиях."/* Потенциальный недостаток этого паттерна в том, что для выбора подходящей 
стратегии клиент должен понимать, чем отличаются разные стратегии. Поэтому наверняка придется раскрыть клиенту некоторые особенности 
реализации. Отсюда следует, что паттерн стратегия стоит применять лишь тогда, когда различия в поведении важны для клиента;
• */"Затраты на передачу информации между стратегией и контекстом."/* Интерфейс Strategy совместно используется всеми подклассам
и ConcreteStrategy — какой бы сложной или тривиальной ни была их реализация. Поэтому вполне вероятно, что некоторые стратегии не 
будут пользоваться всей передаваемой им информацией, особенно простые. Это означает, что в отдельных случаях контекст создаст и 
проинициализирует параметры, которые никому не нужны. Если возникнет проблема, то между классами Strategy и Context придется 
установить более тесную связь;
• */"Увеличение числа объектов."/* Применение стратегий увеличивает число объектов в приложении. Иногда эти издержки можно 
сократить, если реализовать стратегии в виде объектов без состояния, которые могут совместно использоваться несколькими контекстами. 
Остаточное состояние хранится в самом контексте и передается при каждом обращении к объекту-стратегии. Совместно используемые 
стратегии не должны сохранять состояние между вызовами. В описании паттерна приспособленец этот подход обсуждается более подробно.
 Реализация:
• */"Определение интерфейсов классов Strategy и Context."/* Интерфейсы классов Strategy и Context должны предоставить объекту 
класса ConcreteStrategy эффективный доступ к любым данным контекста, и наоборот. Например, Context может передавать данные в 
параметрах операций класса Strategy. Тем самым разрывается тесная связь между контекстом и стратегией. С другой стороны, при 
этом контекст может передавать данные, которые стратегии не нужны. Другой способ — передача самого контекста в аргументе. В таком 
случае стратегия может явно запрашивать у него данные; также стратегия может хранить ссылку на свой контекст, так что передавать 
вообще ничего не придется. И в том, и в другом случаях стратегия может запрашивать только ту информацию, которая реально необходима. 
Но тогда в контексте должен быть определен более развитый интерфейс к своим данным, что несколько усиливает связанность классов 
Strategy и Context.
• */"Стратегии как параметры шаблона"/* Этот способ хорош, только если:
1. Стратегия определяется на этапе компиляции
2. Её не нужно менять во время выполнения. Тогда настраиваемый класс (например, Context) определяется в виде шаблона, 
для которого класс Strategy является параметром: */
template <class AStrategy>
class Context
{
	void Operation() { theStrategy.DoAlgorithm(); }
	// ...
private:
	AStrategy theStrategy;
};
// Затем этот класс настраивается классом Strategy в момент создания экземпляра:
class MyStrategy
{
public:
	void DoAlgorithm();
};

Context<MyStrategy> aContext;
/* При использовании шаблонов отпадает необходимость в абстрактном классе для определения интерфейса Strategy. Кроме того, 
передача стратегии в параметре шаблона позволяет статически связать стратегию с контекстом, вследствие чего повышается 
эффективность программы;
• */"Объекты-стратегии можно не задавать."/* Класс Context можно упростить, если для него нормально не иметь никакой стратегии. 
Прежде чем обращаться к объекту Strategy, объект Context проверяет наличие стратегии. Если да, то работа продолжается как обычно, 
в противном случае контекст реализует некое поведение по умолчанию. Преимущество такого подхода в том, что клиентам вообще не 
нужно иметь дело со стратегиями, если их устраивает поведение по умолчанию.
 Пример кода:
 В классе Composition есть коллекция экземпляров класса Component, представляющих текстовые и графические элементы документа. 
Компоновщик, то есть некоторый подкласс класса Compositor, составляет из объектов-компонентов строки, реализуя ту или иную 
стратегию разбиения на строки. С каждым объектом ассоциирован его естественный размер, а также свойства растягиваемости и 
сжимаемости. Растягиваемость определяет, насколько возможно увеличивать объект по сравнению с его естественным размером, а 
сжимаемость — насколько возможно этот размер уменьшать. Композиция передает эти значения компоновщику, который использует их, 
чтобы найти оптимальное место для разбиения строки: */
class Component{};
class Composition					// Композиция
{
public:
	Composition(Compositor *);		// инициализируется компоновщиком, которым собираетесь пользоваться
	void Repair();
	void Traverse();
private:
	Compositor * _compositor;		// агрегирование компоновщика
	Component  * _components;		// список компонентов (коллекция экземпляров класса Component)
	int   		 _componentCount;	// количество компонентов
	int   		 _lineWidth;		// ширина строки в композиции
	int 	   * _lineBreaks;		// позиции точек разбиения строки (измеренные в компонентах)
	int   		 _lineCount;		// количество строк
};
/* Когда возникает необходимость изменить расположение элементов, композиция запрашивает у компоновщика позиции точек 
разбиения строк. При этом она передает компоновщику три массива, в которых содержатся естественные размеры, величины 
растягиваемости и сжимаемости компонентов. Кроме того, передается число компонентов, ширина строки и массив, в который 
компоновщик должен поместить позиции точек разрыва. Компоновщик возвращает число рассчитанных им точек разбиения.
Интерфейс класса Compositor позволяет композиции передать компоновщику всю необходимую ему информацию: */
class Compositor					// Абстрактный класс (компоновщик)
{
public:
	virtual int Compose(Coord natural[], Coord stretch[], Coord shrink[],		// метод компоновки
						int componentCount, int lineWidth, int breaks[]) = 0;
protected:
	Compositor();
};
/* Композиция вызывает своего компоновщика из операции Repair, которая прежде всего инициализирует массивы, содержащие 
естественные размеры, растягиваемость и сжимаемость каждого компонента. Затем Repair вызывает компоновщика для получения 
позиций точек разбиения и, наконец, отображает документ. */
void Composition::Repair()
{
	Coord * natural;
	Coord * stretchability;
	Coord * shrinkability;
	int 	componentCount;
	int   * breaks;
	// Подготовить массивы с желательными размерами компонентов
	// ...
	// Определить, где должны находиться точки разбиения:
	int breakCount;
	breakCount = _compositor->Compose(natural, stretchability, shrinkability, componentCount, _lineWidth, breaks);
	// Разместить компоненты с учетом точек разбиения
	// ...
}
// Подкласс класса Compositor - SimpleCompositor определяет позиций точек разрыва анализирует компоненты по одному:
class SimpleCompositor	: public Compositor
{
public:
	SimpleCompositor();
	virtual int Compose(Coord natural[], Coord stretch[], Coord shrink[],		// переопределенный метод компоновки
						int componentCount, int lineWidth, int breaks[]);
	// ...
};
/* Класс TeXCompositor использует более глобальную стратегию: он рассматривает абзац целиком, принимая во внимание размеры и 
растягиваемость компонентов. Данный класс также пытается минимизировать ширину пропусков между компонентами: */
class TeXCompositor		: public Compositor
{
public:
	TeXCompositor();
	virtual int Compose(Coord natural[], Coord stretch[], Coord shrink[],		// переопределенный метод компоновки
						int componentCount, int lineWidth, int breaks[]);
	// ...
};
// Класс ArrayCompositor разбивает компоненты на строки, оставляя между ними равные промежутки: 
class ArrayCompositor	: public Compositor
{
public:
	ArrayCompositor(int interval);
	virtual int Compose(Coord natural[], Coord stretch[], Coord shrink[],		// переопределенный метод компоновки
						int componentCount, int lineWidth, int breaks[]);
	// ...
};
/* Не все из этих классов используют в полном объеме информацию, переданную Compose. SimpleCompositor игнорирует растягиваемость 
компонентов, принимая во внимание только их естественную ширину. TeXCompositor использует всю переданную информацию, а 
ArrayCompositor игнорирует ее. При создании экземпляра класса Composition ему передается компоновщик, которым собираетесь пользоваться: */
Composition * quick  = new Composition(new SimpleCompositor);
Composition * slick  = new Composition(new TeXCompositor);
Composition * iconic = new Composition(new ArrayCompositor(100));
/* Интерфейс класса Compositor тщательно спроектирован для поддержки всех алгоритмов размещения, которые могут быть реализованы в 
подклассах. Вряд ли вам захочется изменять данный интерфейс при появлении каждого нового подкласса, поскольку это означало бы 
переписывание уже существующих подклассов. В общем случае именно интерфейсы классов Strategy и Context определяют, насколько 
хорошо паттерн стратегия соответствует своему назначению.
 Известные применения:
В библиотеке ObjectWindows фирмы Borland [Bor94] стратегии используются в диалоговых окнах для проверки правильности введенных
пользователем данных. Для инкапсуляции стратегий проверки в ObjectWindows используются объекты класса Validator — частный случай 
паттерна стратегия. Поля для ввода данных делегируют стратегию контроля необязательному объекту Validator. Клиент при необходимости 
присоединяет таких проверяющих к полю (пример необязательной стратегии). В момент закрытия диалогового окна поля «просят» своих 
контролеров проверить правильность данных. В библиотеке имеются классы контролеров для наиболее распространенных случаев, например 
RangeValidator для проверки принадлежности числа диапазону. Но клиент может легко определить и собственные стратегии проверки, 
порождая подклассы от класса Validator.
 Родственные паттерны:
Приспособленец: объекты-стратегии в большинстве случаев подходят для применения паттерна приспособленец.

	ОФОРМЛЕНИЕ ПОЛЬЗОВАТЕЛЬСКОГО ИНТЕРФЕЙСА
 Рассмотрим два усовершенствования пользовательского интерфейса: 
1. Добавляет рамку вокруг области редактирования текста, чтобы четко обозначить границы страницы текста
2. Добавляет полосы прокрутки, при помощи которых пользователь просматривает разные части страницы.
Чтобы упростить добавление и удаление таких элементов оформления (особенно во время выполнения), для их включения в пользовательский 
интерфейс не должно использоваться наследование. Максимальная гибкость достигается в том случае, если другим объектам 
пользовательского интерфейса даже не будет известно о том, какие еще элементы оформления в нем присутствуют. Это позволит добавлять 
и удалять декоративные элементы без изменения других классов.
	ПРОЗРАЧНОЕ ОКРУЖЕНИЕ
 В программировании улучшение пользовательского интерфейса подразумевает расширение существующего кода. Применение для этой цели 
наследования не дает возможности реорганизовать интерфейс во время выполнения. Не менее серьезной проблемой является комбинаторный 
рост числа классов в случае широкого использования наследования. Можно было бы добавить рамку к классу Composition, породив от него 
новый подкласс BorderedComposition. Точно так же можно было бы добавить и интерфейс прокрутки, породив подкласс ScrollableComposition. 
Если же мы хотим иметь и рамку, и полосу прокрутки, следовало бы создать подкласс BorderedScrollableComposition, и так далее. 
Если довести эту идею до логического завершения, то пришлось бы создавать отдельный подкласс для каждой возможной комбинации 
декоративных элементов. Это решение быстро перестает работать с ростом количества таких декораций. Композиция объектов предоставляет 
куда более приемлемый и гибкий механизм расширения. Но из каких объектов формировать композицию? Поскольку известно, что мы оформляем 
существующий глиф, то и сам элемент оформления могли бы сделать объектом (скажем, экземпляром класса Border). Следовательно, 
композиция может быть составлена из глифа и рамки. На следующем шаге необходимо решить, что во что включается. Можно считать, что 
рамка содержит глиф, и это разумно, так как рамка окружает глиф на экране. Можно принять и противоположное решение — поместить 
рамку внутрь глифа, но тогда пришлось бы модифицировать соответствующий подкласс класса Glyph, чтобы он «знал» о существовании рамки.
Первый вариант — включение глифа в рамку — позволяет поместить весь код для отображения рамки в классе Border, оставив остальные 
классы без изменения. Как выглядит класс Border? Тот факт, что у рамки есть визуальное представление, наталкивает на мысль, что она 
должна быть глифом, то есть подклассом класса Glyph. Но есть и более убедительные причины поступить именно так: клиентов не должно 
интересовать, есть у глифов рамки или нет. Все глифы должны обрабатываться единообразно. Когда клиент приказывает простому глифу без 
рамки нарисовать себя, тот делает это, не добавляя никаких элементов оформления. Если же этот глиф заключен в рамку, то клиент не 
должен как-то специально обрабатывать рамку; он просто предписывает составному глифу выполнить прорисовку точно так же, как и 
простому глифу в предыдущем случае. Отсюда следует, что интерфейс класса Border должен соответствовать интерфейсу класса Glyph. Чтобы 
гарантировать это, мы и делаем Border подклассом Glyph. Все это подводит нас к идее прозрачного окружения (transparent enclosure),
которая объединяет концепции:
1. Композиции с одним потомком (однокомпонентные).
2. Совместимых интерфейсов.
В общем случае клиенту неизвестно, имеет ли он дело с компонентом или его окружением (то есть родителем), особенно если окружение 
просто делегирует все операции своему единственному компоненту. Но окружение может также расширять поведение компонента, выполняя 
дополнительные действия либо до, либо после делегирования (а возможно, и до, и после). Окружение может также добавить компоненту 
состояние.
	МОНОГЛИФ
 Концепцию прозрачного окружения можно применить ко всем глифам, оформляющим другие глифы. Чтобы конкретизировать эту идею, 
определим подкласс класса Glyph, называемый MonoGlyph. Он будет выступать в роли абстрактного класса для глифов-декораций вроде 
рамки. В классе MonoGlyph хранится ссылка на компонент, которому он и переадресует все запросы. При этом MonoGlyph по определению 
становится абсолютно прозрачным для клиентов. Вот как моноглиф реализует операцию Draw: */
void MonoGlyph::Draw(Window* w)
{
	_component->Draw(w);
}
/* Подклассы MonoGlyph замещают по меньшей мере одну из таких операций переадресации. Например, Border::Draw сначала вызывает 
операцию родительского класса MonoGlyph::Draw, чтобы компонент выполнил свою часть работы, то есть нарисовал все, кроме рамки. 
Затем Border::Draw рисует рамку вызовом своей закрытой операции DrawBorder, детали которой мы опустим: */
void Border::Draw(Window* w)
{
	MonoGlyph::Draw(w);
	DrawBorder(w);
}
/* Обратите внимание, что Border::Draw, по сути дела, расширяет операцию родительского класса, чтобы нарисовать рамку. Это не 
то же самое, что простая замена операции: в таком случае MonoGlyph::Draw не вызывалась бы.
 Другой подкласс класса MonoGlyph. Scroller — это MonoGlyph, который рисует свои компоненты на экране в зависимости от положения 
двух полос прокрутки, добавляющихся в качестве элементов оформления. Когда Scroller отображает свой компонент, он приказывает своей 
графической системе обрезать его по границам окна. Отсеченные части компонента, оказавшиеся за пределами видимой части окна, не 
появляются на экране. Мы помещаем имеющийся экземпляр класса Composition в экземпляр класса Scroller, чтобы добавить интерфейс 
прокрутки, а результат композиции еще раз погружаем в экземпляр класса Border. Можно было бы использовать обратный порядок 
композиции, сначала добавив рамку, а потом поместив результат в Scroller. В таком случае рамка прокручивалась бы вместе с текстом. 
Здесь важно то, что прозрачное окружение легко позволяет клиенту экспериментировать с разными вариантами без знания подробностей 
кода, добавляющего декорации. Рамка допускает композицию не более чем с одним глифом. Этим она отличается от рассмотренных выше 
композиций, где родительскому объекту позволялось иметь сколько угодно потомков. Здесь же заключение чего-то в рамку предполагает, 
что это «что-то» имеется в единственном экземпляре. Мы могли бы приписать некоторую семантику декорации более одного объекта, но 
тогда пришлось бы вводить множество видов композиций с оформлением: оформление строки, колонки и т. д. Это не улучшит архитектуру, 
так как у нас уже есть классы для такого рода композиций. Поэтому для композиции лучше использовать уже существующие классы, а новые
добавлять для оформления результата. Отделение декорации от других видов композиции одновременно упрощает классы, реализующие разные
элементы оформления, и уменьшает их количество. Кроме того, мы избавляемся от необходимости дублировать уже имеющуюся  функциональность.

	ПАТТЕРН DECORATOR (ДЕКОРАТОР) (Wrapper (обертка))
 Декоратор — паттерн, структурирующий объекты, абстрагирует отношения между классами и объектами, необходимые для поддержки 
оформления с помощью техники прозрачного окружения.
 Назначение:
 Динамически добавляет объекту новые обязанности. Является гибкой альтернативой порождению подклассов с целью расширения 
функциональности.
 Мотивация:
Иногда бывает нужно возложить дополнительные обязанности на отдельный объект, а не на класс в целом. Так, библиотека для построения
графических интерфейсов пользователя должна «уметь» добавлять новое свойство, скажем, рамку или новое поведение (например, возможность
прокрутки к любому элементу интерфейса). Новые обязанности можно добавить с помощью наследования. При наследовании классу с рамкой 
вокруг каждого экземпляра подкласса будет рисоваться рамка. Однако такое решение недостаточно гибкое из-за того, что рамка будет 
выбираться статически. Клиент не может управлять тем, когда и как компоненты будут декорироваться обрамлением. Другое, более гибкое 
решение — поместить компонент в другой объект, называемый декоратором, который как раз и добавляет рамку. Декоратор следует интерфейсу
декорируемого объекта, поэтому его присутствие прозрачно для клиентов компонента. Декоратор переадресует запросы внутреннему компоненту,
но может выполнять и дополнительные действия (например, рисовать рамку) до или после переадресации. Поскольку декораторы прозрачны,
они могут вкладываться друг в друга, добавляя тем самым неограниченное число новых обязанностей. Предположим, что имеется объект класса
TextView, который отображает текст в окне. По умолчанию TextView не имеет полос прокрутки, поскольку они не всегда нужны. Но при
необходимости их удастся добавить с помощью декоратора ScrollDecorator. Допустим, что еще мы хотим добавить жирную сплошную рамку 
вокруг объекта TextView. Здесь может помочь декоратор BorderDecorator. Мы просто компонуем оба декоратора с BorderDecorator для 
получения искомого результата. Классы ScrollDecorator и BorderDecorator являются подклассами Decorator — абстрактного класса, 
который представляет визуальные компоненты, применяемые для оформления других визуальных компонентов. Класс Decorator просто 
переадресует запросы на рисование своему компоненту, а его подклассы могут расширять эту операцию.
 VisualComponent — это абстрактный класс для представления визуальных объектов. В нем определен интерфейс для рисования и 
обработки событий. Подклассы Decorator могут добавлять любые операции для обеспечения необходимой функциональности. Так, операция 
ScrollTo объекта ScrollDecorator позволяет другим объектам выполнять прокрутку, если им известно о присутствии объекта 
ScrollDecorator в интерфейсе. Важная особенность этого паттерна состоит в том, что декораторы могут употребляться везде, где 
возможно появление самого объекта VisualComponent. При этом клиент не может отличить декорированный объект от недекорированного, 
а значит, и никоим образом не зависит от наличия или отсутствия декоративных элементов.
 Применимость:
• */"Динамическое, прозрачное для клиентов добавление обязанностей объектам (не затрагивающее другие объекты)"/*;
• */"Реализация обязанностей, которые могут быть сняты с объекта"/*;
• */"Расширение путем порождения подклассов по каким-то причинам неудобно или невозможно."/* Иногда приходится реализовывать 
много независимых расширений, так что порождение подклассов для поддержки всех возможных комбинаций приведет к стремительному 
росту их числа. В других случаях определение класса может быть скрыто или почему-либо еще недоступно, так что породить от него 
подкласс нельзя.
 Участники:
• */"Component (VisualComponent) — компонент."/* Определяет интерфейс для объектов, на которые могут быть динамически возложены 
дополнительные обязанности;
• */"ConcreteComponent (TextView) — конкретный компонент."/* Определяет объект, на который возлагаются дополнительные обязанности;
• */"Decorator — декоратор."/* Хранит ссылку на объект Component и определяет интерфейс, соответствующий интерфейсу Component;
• */"ConcreteDecorator (BorderDecorator, ScrollDecorator) — конкретный декоратор."/* Возлагает дополнительные обязанности на компонент.
 Отношения:
• */"Decorator переадресует запросы объекту Component."/* Может выполнять и дополнительные операции до и после переадресации.
 Результаты:
 Плюсы:
• */"Большая гибкость, нежели у статического наследования."/* Паттерн декоратор позволяет более гибко добавлять объекту новые 
обязанности, чем было бы возможно в случае статического (множественного) наследования. Декоратор может добавлять и удалять обязанности 
во время выполнения программы. С другой стороны, при использовании наследования требуется создавать новый класс для каждой 
дополнительной обязанности (например, BorderedScrollableTextView, BorderedTextView), что ведет к увеличению числа классов и, как 
следствие, к возрастанию сложности системы. Кроме того, применение нескольких декораторов к одному компоненту позволяет формировать 
произвольные комбинации обязанностей. Декораторы также позволяют легко добавить одно и то же свойство дважды. Например, чтобы окружить
объект TextView двойной рамкой, нужно просто добавить два декоратора BorderDecorators. Двойное наследование классу Border в лучшем 
случае чревато ошибками;
• */"Позволяет избежать перегруженных функциями классов на верхних уровнях иерархии."/* Декоратор разрешает добавлять новые обязанности 
по мере необходимости. Вместо того чтобы пытаться поддержать все мыслимые возможности в одном сложном, допускающем разностороннюю 
настройку классе, вы можете определить простой класс и постепенно наращивать его функциональность с помощью декораторов. В результате
приложение уже не перегружается неиспользуемыми функциями. Нетрудно также определять новые виды декораторов независимо от классов, 
которые они расширяют, даже если первоначально такие расширения не планировались. При расширении же сложного класса обычно приходится
вникать в детали, не имеющие отношения к добавляемой функции.
 Минусы:
• */"Декоратор и его компонент не идентичны."/* Декоратор действует как прозрачное обрамление. Но декорированный компонент все же 
не идентичен исходному. При использовании декораторов это следует иметь в виду;
• */"Множество мелких объектов."/* При использовании в проекте паттерна декоратор нередко формируется система, составленная из 
большого числа мелких объектов, похожих друг на друга. Такие объекты различаются только способом взаимосвязи, а не классом и не 
значениями своих внутренних переменных. Хотя такие системы легко настраиваются проектировщиком, хорошо разбирающимся в их строении, 
изучать и отлаживать их очень тяжело.

 Реализация:
• */"Соответствие интерфейсов."/* Интерфейс декоратора должен соответствовать интерфейсу декорируемого компонента. Поэтому классы
ConcreteDecorator должны наследовать общему классу;
• */"Отсутствие абстрактного класса Decorator."/* Нет необходимости определять абстрактный класс Decorator, если вы собираетесь 
добавить всего одну обязанность. Так часто происходит, когда вы работаете с уже существующей иерархией классов, а не проектируете 
новую. В таком случае ответственность за переадресацию запросов, которую обычно несет класс Decorator, можно возложить 
непосредственно на ConcreteDecorator;
• */"Облегченные классы Component."/* Чтобы можно было гарантировать соответствие интерфейсов, компоненты и декораторы должны 
наследовать общему классу Component. Важно, чтобы этот класс был настолько легким, насколько возможно. Иными словами, он должен 
определять интерфейс, а не хранить данные. Определение представления данных должно быть передано в подклассы; в противном случае 
декораторы могут стать весьма тяжеловесными, и применять их в большом количестве будет накладно. Включение большого числа функций 
в класс Component также увеличивает вероятность, что конкретным подклассам придется платить за то, что им не нужно;
• */"Изменение облика, а не внутреннего устройства объекта."/* Декоратор можно рассматривать как появившуюся у объекта оболочку, 
которая изменяет его поведение. Альтернатива — изменение внутреннего устройства объекта, хорошим примером чего может служить 
паттерн стратегия.
 Стратегии лучше подходят в ситуациях, когда класс Component уже тяжел так, что применение паттерна декоратор обходится слишком 
дорого. В паттерне стратегия компоненты передают часть своей функциональности отдельному объекту-стратегии, поэтому изменить 
или расширить поведение компонента допустимо, заменив этот объект. Например, мы можем поддержать разные стили рамок, поручив 
рисование рамки специальному объекту Border. Объект Border является примером объекта-стратегии: в данном случае он инкапсулирует 
стратегию рисования рамки. Число стратегий может быть любым, поэтому эффект такой же, как от рекурсивной вложенности декораторов.
Поскольку паттерн декоратор изменяет лишь внешний облик компонента, то компоненту ничего не надо «знать» о своих декораторах, 
то есть декораторы прозрачны для компонента. В случае стратегий самому компоненту известно о возможных расширениях, поэтому он 
должен располагать информацией обо всех стратегиях и ссылаться на них.
 При использовании подхода, основанного на стратегиях, может возникнуть необходимость в модификации компонента, чтобы он 
соответствовал новому расширению. С другой стороны, у стратегии может быть свой собственный специализированный интерфейс, тогда 
как интерфейс декоратора должен повторять интерфейс компонента. Например, стратегии рисования рамки необходимо определить всего 
лишь интерфейс для этой операции (DrawBorder, GetWidth и т. д.), то есть класс стратегии может быть легким, несмотря на 
тяжеловесность компонента.
 Пример кода: */
class VisualComponent						// класс компонента
{
public:
	VisualComponent()
	virtual void Draw();
	virtual void Resize();
	// ...
};

class Decorator : public VisualComponent	// подкласс компонента, декорирует объект VisualComponent
{
public:
	Decorator(VisualComponent * contents);
	virtual void Draw();
	virtual void Resize();
	// ...
private:
	VisualComponent * _component;			// агрегирует базовый компонент
};
/* Объект класса Decorator декорирует объект VisualComponent, на который ссылается переменная экземпляра _component, 
инициализируемая в конструкторе. Для каждой операции в интерфейсе VisualComponent в классе Decorator определена реализация 
по умолчанию, передающая запросы объекту, на который ведет ссылка _component: */
void Decorator::Draw()						// реализация по умолчанию
{
	_component->Draw();
}
void Decorator::Resize()
{
	_component->Resize();
}
/* Подклассы Decorator определяют специализированные операции: класс BorderDecorator добавляет к своему внутреннему компоненту 
рамку. BorderDecorator — это подкласс Decorator, где операция Draw замещена так, что рисует рамку. В этом классе определена 
также закрытая вспомогательная операция DrawBorder, которая, собственно, и изображает рамку. Реализации всех остальных 
операций этот подкласс наследует от Decorator: */
class BorderDecorator : public Decorator	// определяет специализированные операции
{
public:
	BorderDecorator(VisualComponent * contents, int borderWidth);
	virtual void Draw();
private:
	void DrawBorder(int);
private:
	int _width;
};
void BorderDecorator::Draw()
{
	Decorator::Draw();						// применяет операцию по умолчанию
	DrawBorder(_width);						// добавляет к своему внутреннему компоненту рамку
}
/* Подклассы ScrollDecorator и DropShadowDecorator, которые добавят визуальному компоненту возможность прокрутки и оттенения, 
реализуются аналогично. Теперь экземпляры этих классов можно скомпоновать для получения различных оформлений: */
void Window::SetContents(VisualComponent * contents) // поместить визуальный компонент в оконный объект
{
	// ...
}

class TextView : public VisualComponent		// примитив компонента, декорирует объект VisualComponent
{
	// ...
}
// Теперь можно создать поле для ввода текста и окно, в котором будет находиться это поле:
Window	 * window	= new Window;
TextView * textView = new TextView;
window->SetContents(textView);				// TextView является подклассом VisualComponent, значит можно поместить его в окно
// Но нам нужна и возможность прокрутки для поля ввода с рамкой, поэтому перед размещением в окне его необходимо оформить:
window->SetContents( new BorderDecorator( new ScrollDecorator(textView), 1 ) );
/* Поскольку класс Window обращается к своему содержимому только через интерфейс VisualComponent, то ему неизвестно о присутствии 
декоратора. Клиент при желании может сохранить ссылку на само поле ввода, если ему нужно работать с ним непосредственно — например, 
вызывать операции, не входящие в интерфейс VisualComponent. Клиенты, которым важна идентичность объекта, также должны обращаться к 
нему напрямую.
 Поток является фундаментальной абстракцией для большинства средств ввода/вывода. Он может предоставлять интерфейс для преобразования 
объектов в последовательность байтов или символов. Это позволяет записать объект в файл или буфер в памяти и впоследствии извлечь его 
оттуда. Самый очевидный способ сделать это — определить абстрактный класс Stream с подклассами MemoryStream и FileStream. Предположим,
однако, что вам также хотелось бы иметь возможность:
• сжимать данные в потоке с применением различных алгоритмов (кодирование с переменной длиной строки, алгоритм Лемпеля — Зива и т. д.);
• преобразовывать данные в 7-битные символы кода ASCII для передачи по каналу связи.
 Паттерн декоратор позволяет весьма элегантно добавить такие обязанности потокам. */
class Stream								// класс компонента
{
public:
	Stream()
	void putInt();
	void putString();
	virtual void handleBufferFull();
};
/* Абстрактный класс Stream имеет внутренний буфер и предоставляет операции для помещения данных в поток (PutInt, PutString). Как 
только буфер заполняется, Stream вызывает абстрактную операцию HandleBufferFull, которая выполняет реальное перемещение данных. */
class MemoryStream	  : public Stream		// примитив компонента, декорирует объект Stream
{
public:
	void handleBufferFull();					// буфер записывается во flash
}
// В классе FileStream эта операция замещается так, что буфер записывается в файл:
class FileStream	  : public Stream		// примитив компонента, декорирует объект Stream
{
public:
	void handleBufferFull();					// буфер записывается в файл
}
// Ключевую роль здесь играет класс StreamDecorator: 
class StreamDecorator : public Stream		// подкласс компонента, декорирует объект Stream
{
private:
	Stream * _component;
public:
	virtual void handleBufferFull();			// по умолчанию
}
StreamDecorator::handleBufferFull()
{
	_component->handleBufferFull();
}
/* Именно в нем хранится ссылка на тот поток-компонент, которому переадресуются все запросы. Подклассы StreamDecorator замещают операцию
HandleBufferFull и выполняют дополнительные действия, перед тем как вызвать реализацию этой операции в классе StreamDecorator.
Подкласс CompressingStream сжимает данные: */
class CompressingStream	  : public StreamDecorator	// определяет специализированные операции
{
private:
	Vector _data;
	void compressingData(Vector d);
public:
	CompressingStream(Stream * contents, Vector data);
	void handleBufferFull();	
}
CompressingStream::handleBufferFull(Vector d)
{
	compressingData(_data);							// сжимает данные
	StreamDecorator::handleBufferFull();				// применяет операцию по умолчанию
}
// А ASCII7Stream преобразует их в 7-битный код ASCII:
class ASCII7Stream	  : public StreamDecorator		// определяет специализированные операции
{
private:
	Vector _data;
	void dataToASCII7(Vector d);
public:
	ASCII7Stream(Stream * contents, Vector data);
	void handleBufferFull();	
}
ASCII7Stream::handleBufferFull(Vector d)
{
	dataToASCII7(_data);								// преобразует данные в 7-битный код ASCII
	StreamDecorator::handleBufferFull();				// применяет операцию по умолчанию
}
/* Теперь, для того чтобы создать объект FileStream, который одновременно сжимает данные и преобразует результат в 7-битный код,
достаточно просто декорировать FileStream с использованием CompressingStream и ASCII7Stream: */
Stream * aStream = new CompressingStream( new ASCII7Stream( new FileStream("aFileName") ) );
aStream->PutInt(12);
aStream->PutString("aString");
/* Родственные паттерны
 Адаптер: декоратор изменяет только обязанности объекта, не меняя интерфейса, а адаптер придает объекту совершенно новый интерфейс.
 Компоновщик: декоратор можно считать вырожденным случаем составного объекта, у которого есть только один компонент. Однако декоратор
добавляет новые обязанности, агрегирование объектов не является его целью.
 Стратегия: декоратор позволяет изменить внешний облик объекта, стратегия — его внутреннее содержание. Это два взаимодополняющих 
способа изменения объекта.

	ПОДДЕРЖКА НЕСКОЛЬКИХ СТАНДАРТОВ ОФОРМЛЕНИЯ
 Одним из препятствий для переносимости между различными программными и аппаратными платформами является разнообразие стандартов 
оформления, призванных унифицировать работу с приложениями на данной платформе. Эти стандарты определяют, как приложения должны 
выглядеть и реагировать на действия пользователя. Программа, работающая более чем на одной платформе, на всех платформах должна 
соответствовать принятой стилистике пользовательского интерфейса. Одна из целей проектирования — сделать так, чтобы приложение 
поддерживало разные стандарты внешнего облика и чтобы легко можно было добавить поддержку нового стандарта сразу же после его 
появления (а это неизбежно произойдет). Желательно, чтобы дизайн решал и другую задачу: изменение оформления приложения во 
время выполнения.
  АБСТРАГИРОВАНИЕ СОЗДАНИЯ ОБЪЕКТА
 Все, что мы видим и с чем можем взаимодействовать в пользовательском интерфейсе приложения, — это визуальные глифы (или виджеты), 
скомпонованные в другие, уже невидимые глифы вроде строки (Row) и колонки (Column). Невидимые глифы объединяют видимые — скажем, 
кнопку (Button) или символ (Character) — и правильно располагают их на экране. Классы глифов-виджетов, с помощью которых реализуются
стандарты оформления, делятся на два класса:
• */"набор абстрактных подклассов класса Glyph для каждой категории виджетов."/* Например, абстрактный класс ScrollBar будет 
дополнять интерфейс глифа с целью получения операций прокрутки общего вида, а Button — это абстрактный класс, добавляющий операции 
с кнопками;
• */"набор конкретных подклассов для каждого абстрактного подкласса, в которых реализованы стандарты внешнего облика"/* Так, у 
ScrollBar могут быть подклассы MotifScrollBar и PMScrollBar, реализующие полосы прокрутки в стиле Motif и Presentation Manager 
соответственно.
 Приложение должно различать глифы-виджеты для разных стилей внешнего оформления. Например, когда необходимо поместить в интерфейс 
кнопку, редактор должен создать экземпляр подкласса класса Glyph для нужного стиля кнопки (MotifButton, PMButton, MacButton и т. д.).
В реализации приложения этого нельзя сделать непосредственно — например, вызовом конструктора. При этом была бы жестко 
запрограммирована кнопка одного конкретного стиля, а значит, выбрать нужный стиль во время выполнения оказалось бы невозможно. 
Кроме того, мы были бы вынуждены отслеживать и изменять каждый такой вызов конструктора при переносе приложения на другую платформу. 
А ведь кнопки — это лишь один элемент пользовательского интерфейса приложения. Загромождение кода вызовами конструкторов для разных 
классов оформления создает существенные неудобства при сопровождении. Стоит что-нибудь пропустить — и в приложении для Mac появится 
меню в стиле Motif. Приложению необходимо определить нужный стандарт оформления для создания подходящих виджетов. При этом надо не 
только постараться избежать явных вызовов конструкторов, но и уметь без труда заменять весь набор виджетов. Этого можно добиться 
путем абстрагирования процесса создания объекта.
  ФАБРИКИ И ИЗГОТОВЛЕННЫЕ КЛАССЫ
 В обычном случае экземпляр виджета полосы прокрутки в стиле Motif создается следующим кодом на C++: */
ScrollBar * sb = new MotifScrollBar;
// Но если вы хотите свести к минимуму зависимость приложения от стандарта оформления, именно такого кода следует избегать.
ScrollBar * sb = guiFactory->CreateScrollBar(); /* где guiFactory — экземпляр класса MotifFactory. Операция CreateScrollBar()
возвращает новый экземпляр подходящего подкласса ScrollBar, который соответствует нужному варианту оформления, в данном случае 
Motif. С точки зрения клиентов результат тот же, что и при прямом вызове конструктора MotifScrollBar. Но есть и существенное 
отличие: нигде в коде больше не упоминается имя Motif. Объект guiFactory абстрагирует процесс создания полос прокрутки не только 
для Motif, но и для любых стандартов оформления. Более того, guiFactory не ограничивается изготовлением только полос прокрутки и 
может применяться для производства любых виджетов, включая кнопки, поля ввода, меню и т. д. Все это возможно благодаря тому, что
MotifFactory является подклассом GUIFactory — абстрактного класса, который определяет общий интерфейс для создания глифов-виджетов.
В нем есть такие операции, как CreateScrollBar и CreateButton, для создания экземпляров различных видов виджетов. Подклассы 
GUIFactory реализуют эти операции, возвращая глифы вроде MotifScrollBar и PMButton, реализующие конкретное оформление и поведение. 
 Фабрики изготавливают объекты. Все объекты, изготовленные на фабриках, связаны друг с другом; в нашем случае все такие продукты —
это виджеты, имеющие один и тот же внешний облик. Как получить экземпляр GUIFactory? Да как угодно, лишь бы это было удобно. 
Переменная guiFactory может быть глобальной, может быть статическим членом хорошо известного класса или даже локальной, если 
весь пользовательский интерфейс создается внутри одного класса или функции. Существует специальный паттерн проектирования 
одиночка, предназначенный для работы с такого рода объектами, существующими в единственном экземпляре. Важно, чтобы фабрика 
guiFactory была инициализирована */"до того"/*, как начнет использоваться для производства объектов, но */"после того"/*, как 
стало известно, какое оформление требуется. Когда вариант оформления известен на этапе компиляции, то guiFactory можно 
инициализировать простым присваиванием в начале программы: */
GUIFactory * guiFactory = new MotifFactory;
// Если же пользователь может задать нужный вариант оформления с помощью строки-параметра при запуске, то:
GUIFactory * guiFactory;
const char * styleName = getEnv("LOOK_AND_FEEL"); // Задается пользователем или средой при запуске
if ( strcmp(styleName, "Motif") == 0 )			// Далее динамическая идентификация типов во время выполнения
{
	guiFactory = new MotifFactory;
}
else if( strcmp(styleName, "Presentation_Manager") == 0 )
{
	guiFactory = new PMFactory;
}
else
{
	guiFactory = new DefaultGUIFactory;
}
/* Существуют и более сложные способы выбора фабрики во время выполнения: можно было бы вести реестр, в котором символьные 
строки ассоциируются с объектами фабрик. Это позволяет зарегистрировать экземпляр новой фабрики без изменения существующего 
кода, как требуется при предыдущем подходе. И вам не придется связывать с приложением код фабрик для всех конкретных платформ. 
Это существенно, поскольку связать код для MotifFactory с приложением, работающим на платформе, где Motif не поддерживается, 
может оказаться невозможным. Важно лишь то, что после настройки приложения для работы с конкретной фабрикой объектов, мы 
получаем нужный вариант оформления. Если впоследствии мы изменим решение, то сможем инициализировать guiFactory по-другому, 
чтобы изменить внешний облик, а затем динамически перестроим интерфейс. Независимо от того, когда и как будет инициализироваться 
guiFactory, можно быть уверенным в том, что после этого приложение сможет создать необходимый вариант оформления без каких-либо 
изменений.

	ПОРОЖДАЮЩИЕ ПАТТЕРНЫ
 Порождающие паттерны проектирования абстрагируют процесс создания экземпляров. Они позволяют сделать систему независимой от 
способа создания, композиции и представления объектов. Паттерн, порождающий классы, использует наследование, чтобы варьировать 
класс создаваемого экземпляра, а паттерн, порождающий объекты, делегирует создание экземпляров другому объекту. Эти паттерны 
начинают играть более важную роль, когда система эволюционирует и начинает в большей степени зависеть от композиции объектов, 
чем от наследования классов. При этом основной акцент смещается с жесткого кодирования фиксированного набора поведений на 
определение небольшого набора фундаментальных поведений, посредством композиции которых можно получить любое число более 
сложных. Для порождающих паттернов характерны два аспекта. Во-первых, эти паттерны инкапсулируют знания о конкретных классах, 
которые применяются в системе. Во-вторых, они скрывают подробности создания и компоновки экземпляров этих классов. 
Единственная информация об объектах, известная системе, — это их интерфейсы, определенные с помощью абстрактных классов. 
Порождающие паттерны обеспечивают большую гибкость в отношении того, что создается, кто это создает, как и когда.
 Классы Room (комната), Door (дверь) и Wall (стена) определяют компоненты лабиринта и используются во всех примерах.
Для задания северной, южной, восточной и западной сторон используется перечисление Direction: */
enum Direction {North, South, East, West};
/* Класс MapSite — общий абстрактный класс для всех компонентов лабиринта. Когда вы входите в комнату, ваше местоположение 
изменяется. При попытке затем войти в дверь может произойти одно из двух. Если дверь открыта, то вы попадаете в следующую 
комнату, а если закрыта, то вы разбиваете себе нос: */
class MapSite
{
public:
	virtual void Enter() = 0;
};
/* Операция Enter составляет основу для более сложных игровых операций. Например, если вы находитесь в комнате и говорите 
«Иду на восток», то игрой определяется, какой объект класса MapSite находится к востоку от вас, и для него вызывается 
операция Enter. Определенные в подклассах операции Enter «выяснят», изменили вы свое местоположение или расшибли нос. 
В реальной игре Enter мог бы передаваться аргумент с объектом, представляющим блуждающего игрока.
 Room — это конкретный подкласс класса MapSite, который определяет ключевые отношения между компонентами лабиринта. Он 
содержит ссылки на другие объекты MapSite, а также хранит номер комнаты. Все комнаты в лабиринте идентифицируются номерами: */
class Room : public MapSite
{
public:
	Room(int roomNo);
	MapSite * GetSide(Direction) const;
	void SetSide(Direction, MapSite *);
	virtual void Enter();
private:
	MapSite * _sides[4];
	int _roomNumber;
};
// Следующие классы представляют стены и двери, находящиеся с каждой стороны комнаты:
class Wall : public MapSite
{
public:
	Wall();
	virtual void Enter();
};

class Door : public MapSite
{
public:
	Door(Room * = 0, Room * = 0);
	virtual void Enter();
	Room * OtherSideFrom(Room *);
private:
	Room * _room1;
	Room * _room2;
	bool _isOpen;
};
/* Тем не менее, информации об отдельных частях лабиринта недостаточно. Определим еще класс Maze для представления набора комнат. 
В этот класс включена операция RoomNo для нахождения комнаты по ее номеру: */
class Maze
{
public:
	Maze();
	void AddRoom(Room *);
	Room * RoomNo(int) const;
private:
// ...
};
/* RoomNo могла бы выполнять поиск с помощью линейного списка, хеш-таблицы или даже простого массива.
Определим также класс MazeGame, который создает лабиринт. Самый простой способ сделать это — строить лабиринт последовательностью 
операций, добавляющих к нему компоненты, которые потом соединяются. Например, следующая функция создаст лабиринт из двух комнат 
с одной дверью между ними: */
Maze * MazeGame::CreateMaze()
{
	Maze * aMaze	= new Maze;
	Room * r1		= new Room(1);
	Room * r2		= new Room(2);
	Door * theDoor	= new Door(r1, r2);
	aMaze->AddRoom(r1);
	aMaze->AddRoom(r2);
	r1->SetSide(North, new Wall);
	r1->SetSide(East,  theDoor);
	r1->SetSide(South, new Wall);
	r1->SetSide(West,  new Wall);
	r2->SetSide(North, new Wall);
	r2->SetSide(East,  new Wall);
	r2->SetSide(South, new Wall);
	r2->SetSide(West,  theDoor);
	return aMaze;
}
/* Функция получилась довольно сложной, если учесть, что она всего лишь строит лабиринт из двух комнат. Есть очевидные способы 
упростить ее. Например, конструктор класса Room мог бы инициализировать стороны без дверей заранее; но это означает лишь 
перемещение кода в другое место. Суть проблемы не в размере этой функции, а в ее негибкости. Структура лабиринта жестко 
«зашита» в функции. Чтобы изменить структуру, придется изменить саму функцию, либо заместив ее (то есть полностью переписав 
заново), либо непосредственно модифицируя ее фрагменты. Оба пути чреваты ошибками и не способствуют повторному использованию.
Порождающие паттерны показывают, как сделать дизайн более гибким, хотя и необязательно меньшим по размеру. В частности, их 
применение позволит легко менять классы, определяющие компоненты лабиринта. С помощью порождающих паттернов можно различными 
способами избавиться от явных упоминаний конкретных классов из кода, создающего их экземпляры:
• */"если CreateMaze вызывает виртуальные функции вместо конструкторов для создания комнат, стен и дверей"/*, то классы, 
экземпляры которых создаются, можно подменить, создав подкласс MazeGame и переопределив в нем виртуальные функции. Такой 
подход применяется в паттерне фабричный метод;
• */"когда функции CreateMaze в параметре передается объект, используемый для создания комнат, стен и дверей,"/*, то их 
классы можно изменить, передав другой параметр. Это пример паттерна абстрактная фабрика;
• */"если функции CreateMaze передается объект"/*, способный целиком создать новый лабиринт с помощью своих операций для 
добавления комнат, дверей и стен, можно воспользоваться наследованием для изменения частей лабиринта или способа его построения. 
Такой подход применяется в паттерне строитель;
• */"если CreateMaze параметризована прототипами комнаты, двери и стены"/*, которые она затем копирует и добавляет к лабиринту, 
то состав лабиринта можно варьировать, заменяя одни объекты-прототипы другими. Это паттерн прототип.
 Последний из порождающих паттернов, - одиночка , может гарантировать существование единственного лабиринта в игре и свободный 
доступ к нему со стороны всех игровых объектов, не прибегая к глобальным переменным или функциям. Паттерн одиночка также 
позволяет легко расширить или заменить лабиринт, не трогая существующий код.

	ПАТТЕРН ABSTRACT FACTORY (АБСТРАКТНАЯ ФАБРИКА) == Kit (инструментарий).
 Абстрактная фабрика — паттерн, порождающий объекты.
  Назначение:
 Предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов, не специфицируя их конкретных классов.
Этот паттерн может создавать семейства объектов без явного создания экземпляров. Применять его лучше всего тогда, когда число 
и общий вид изготавливаемых объектов остаются постоянными, но между конкретными семействами продуктов имеются различия. Выбор 
того или иного семейства осуществляется путем создания экземпляра конкретной фабрики, после чего она используется для создания 
всех объектов. Подставив вместо одной фабрики другую, можно заменить все семейство объектов целиком. В паттерне абстрактная 
фабрика акцент делается на создании семейств объектов, и это отличает его от других порождающих паттернов, создающих только 
один какой-то вид объектов.
 Рассмотрим инструментальную программу для создания пользовательского интерфейса, поддерживающего разные стандарты оформления, например 
Motif и Presentation Manager. Оформление определяет визуальное представление и поведение элементов пользовательского интерфейса 
(«виджетов») — полос прокрутки, окон и кнопок. Чтобы приложение можно было перенести на другой стандарт, в нем не должно быть жестко 
закодировано оформление виджетов. Если создание экземпляров классов для конкретного оформления разбросано по всему приложению, то 
изменить оформление впоследствии будет нелегко. Для решения этой проблемы можно определить абстрактный класс WidgetFactory, в 
котором объявлен интерфейс для создания всех основных видов виджетов. Есть также абстрактные классы для каждого отдельного вида 
и конкретные подклассы, реализующие виджеты с определенным оформлением. В интерфейсе WidgetFactory имеется операция, возвращающая 
новый объект-виджет для каждого абстрактного класса виджетов. Клиенты вызывают эти операции для получения экземпляров виджетов, 
но при этом ничего не знают о том, какие именно классы используются. Таким образом, клиенты остаются независимыми от выбранного 
стандарта оформления. Для каждого стандарта оформления существует определенный подкласс WidgetFactory. Каждый такой подкласс 
реализует операции, необходимые для создания соответствующего стандарту виджета. Например, операция CreateScrollBar в классе 
MotifWidgetFactory создает экземпляр и возвращает полосу прокрутки в стандарте Motif, тогда как соответствующая операция 
в классе PMWidgetFactory возвращает полосу прокрутки в стандарте Presentation Manager. Клиенты создают виджеты, пользуясь 
исключительно интерфейсом WidgetFactory, и им ничего не известно о классах, реализующих виджеты для конкретного стандарта. 
Клиенты должны лишь придерживаться интерфейса, определенного абстрактным, а не конкретным классом. Класс WidgetFactory также 
устанавливает зависимости между конкретными классами виджетов. Полоса прокрутки для Motif должна использоваться с кнопкой и 
текстовым полем Motif, и это ограничение поддерживается автоматически как следствие использования класса MotifWidgetFactory.
  Применимость:
Основные условия для применения паттерна абстрактная фабрика:
• */"система не должна зависеть от того, как создаются, компонуются и представляются входящие в нее объекты;"/*
• */"система должна настраиваться одним из семейств объектов;"/*
• */"входящие в семейство взаимосвязанные объекты спроектированы для совместной работы,"/* и вы должны обеспечить выполнение 
этого ограничения;"/*
• */"вы хотите предоставить библиотеку объектов, раскрывая только их интерфейсы, но не реализацию."/*
  Участники:
• */"AbstractFactory (WidgetFactory) — абстрактная фабрика:"/* объявляет интерфейс для операций, создающих абстрактные объекты-продукты;
• */"ConcreteFactory (MotifWidgetFactory, PMWidgetFactory) — конкретная фабрика:"/* реализует операции, создающие конкретные 
объекты-продукты;
• */"AbstractProduct (Window, ScrollBar) — абстрактный продукт:"/* объявляет интерфейс для типа объекта-продукта;
• */"ConcreteProduct (MotifWindow, MotifScrollBar) — конкретный продукт:"/*
- определяет объект-продукт, создаваемый соответствующей конкретной фабрикой;
- реализует интерфейс AbstractProduct;
• */"Client — клиент:"/* пользуется исключительно интерфейсами, которые объявлены в классах AbstractFactory и AbstractProduct.
  Отношения:
• */"Обычно во время выполнения создается единственный экземпляр класса ConcreteFactory."/* Эта конкретная фабрика создает 
объекты-продукты, имеющие вполне определенную реализацию. Для создания других видов объектов клиент должен воспользоваться 
другой конкретной фабрикой;
• */"AbstractFactory передоверяет создание объектов-продуктов своему подклассу ConcreteFactory."/*
  Результаты:
 Паттерн абстрактная фабрика:
• */"изолирует конкретные классы."/* Паттерн помогает контролировать классы объектов, создаваемых приложением. Поскольку фабрика 
инкапсулирует ответственность за создание классов и сам процесс их создания, то она изолирует клиента от подробностей реализации 
классов. Клиенты манипулируют экземплярами через их абстрактные интерфейсы. Имена изготавливаемых классов известны только 
конкретной фабрике, в коде клиента они не упоминаются;
• */"упрощает замену семейств продуктов."/* Класс конкретной фабрики появляется в приложении только один раз: при создании экземпляра.
Это облегчает замену используемой приложением конкретной фабрики. Приложение может изменить конфигурацию продуктов, просто подставив 
новую конкретную фабрику. Поскольку абстрактная фабрика создает все семейство продуктов, то и заменяется сразу все семейство. В нашем 
примере для переключения пользовательского интерфейса с виджетов Motif на виджеты Presentation Manager достаточно переключиться на 
продукты соответствующей фабрики и заново создать интерфейс;
• */"гарантирует сочетаемость продуктов."/* Если продукты некоторого семейства спроектированы для совместного использования, то 
важно, чтобы приложение в каждый момент времени работало только с продуктами единственного семейства. Класс AbstractFactory 
позволяет легко соблюсти это ограничение;
• */"не упрощает задачу поддержки нового вида продуктов."/* Расширение абстрактной фабрики для изготовления новых видов продуктов —
непростая задача. Дело в том, что интерфейс AbstractFactory фиксирует набор продуктов, которые можно создать. Для поддержки новых 
продуктов необходимо расширить интерфейс фабрики, то есть изменить класс AbstractFactory и все его подклассы.
  Реализация:
• */"фабрики как объекты, существующие в единственном экземпляре."/* для реализации лучше всего применить паттерн Singleton (одиночка).
• */"создание продуктов."/* Класс AbstractFactory объявляет только интерфейс для создания продуктов. Фактическое их создание — дело 
подклассов ConcreteProduct. Чаще всего для этой цели определяется паттерн Factory Method (фабричный метод) для каждого продукта. 
Конкретная фабрика определяет свои продукты путем замещения фабричного метода для каждого из них. Хотя такая реализация проста, 
она требует создавать новый подкласс конкретной фабрики для каждого семейства продуктов, даже если они почти ничем не отличаются.
Если семейств продуктов может быть много, то конкретную фабрику удастся реализовать с помощью паттерна Prototype (прототип).
В этом случае она инициализируется экземпляром-прототипом каждого продукта в семействе и создает новый продукт путем клонирования 
этого прототипа. Подход на основе прототипов устраняет необходимость создавать новый класс конкретной фабрики для каждого нового 
семейства продуктов.
Smalltalk. Конкретная фабрика хранит клонируемые прототипы в словаре под названием partCatalog. Метод make: извлекает прототип и 
клонирует его: */
make: partName
	^ (partCatalog at: partName) copy
//У конкретной фабрики есть метод для добавления деталей в каталог:
addPart: partTemplate named: partName
	partCatalog at: partName put: partTemplate
// Прототипы добавляются к фабрике путем пометки их символом #:
aFactory addPart: aPrototype named: #ACMEWidget
/*
• */"определение расширяемых фабрик."/* Класс AbstractFactory обычно определяет разные операции для всех видов изготавливаемых 
продуктов. Виды продуктов кодируются в сигнатуре операции. Для добавления нового вида продуктов нужно изменить интерфейс класса 
AbstractFactory и всех зависящих от него классов. Более гибкий, но менее безопасный способ — добавить параметр к операциям, 
создающим объекты. Данный параметр определяет вид создаваемого объекта. Это может быть идентификатор класса, целое число, строка 
или что-то еще, однозначно описывающее вид продукта. При таком подходе классу AbstractFactory нужна только одна операция Make с 
параметром, задающим тип создаваемого объекта. */
make: partName
	^ (partCatalog at: partName) new		/* вместо хранения клонируемых прототипов partCatalog хранит классы продуктов
Такой вариант проще использовать в динамически типизированных языках вроде Smalltalk, нежели в статически типизированных, каким 
является C++. Воспользоваться им в C++ можно только в том случае, если у всех объектов имеется общий абстрактный базовый класс 
или если объекты-продукты могут быть безопасно приведены к корректному типу клиентом, который их запросил. Но даже если приведение 
типов не нужно, остается принципиальная проблема: все продукты возвращаются клиенту одним и тем же абстрактным интерфейсом с уже 
определенным типом возвращаемого значения. Клиент не может ни различить классы продуктов, ни сделать какие-нибудь предположения
о них. Если клиенту нужно выполнить операцию, зависящую от подкласса, то она будет недоступна через абстрактный интерфейс.
  Пример кода:
 Программы построения лабиринта принимают MazeFactory в качестве аргумента, так что программист может сам указать классы комнат, 
стен и дверей: */
class MazeFactory				// абстрактная фабрика
{
public:
	MazeFactory();
	virtual Maze * MakeMaze() const { return new Maze; }
	virtual Wall * MakeWall() const { return new Wall; }
	virtual Room * MakeRoom(int n) const { return new Room(n); }
	virtual Door * MakeDoor(Room * r1, Room * r2) const { return new Door(r1, r2); }
};
/* Функция CreateMaze избавлена от недостатка жестко «зашитых» имён классов. Поскольку она получает MazeFactory в параметре,
то можно воспользоваться функцией для создания лабиринтов с другими компонентами: */
Maze * MazeGame::CreateMaze(MazeFactory & factory)	// было: Maze * MazeGame::CreateMaze()
{
	Maze * aMaze = factory.MakeMaze();				// было: Maze * aMaze		= new Maze;
	Room * r1    = factory.MakeRoom(1);				// было: Room * r1		= new Room(1);
	Room * r2    = factory.MakeRoom(2);				// было: Room * r2		= new Room(2);
	Door * aDoor = factory.MakeDoor(r1, r2);			// было: Door * theDoor	= new Door(r1, r2);
	aMaze->AddRoom(r1);
	aMaze->AddRoom(r2);
	r1->SetSide(North, factory.MakeWall());			// было: r1->SetSide(North, new Wall);
	r1->SetSide(East,  aDoor);
	r1->SetSide(South, factory.MakeWall());			// было: r1->SetSide(South, new Wall);
	r1->SetSide(West,  factory.MakeWall());			// было: r1->SetSide(West,  new Wall);
	r2->SetSide(North, factory.MakeWall());			// было: r2->SetSide(North, new Wall);
	r2->SetSide(East,  factory.MakeWall());			// было: r2->SetSide(East,  new Wall);
	r2->SetSide(South, factory.MakeWall());			// было: r2->SetSide(South, new Wall);
	r2->SetSide(West,  aDoor);
	return aMaze;
}
/* Чтобы создать фабрику EnchantedMazeFactory для производства волшебных лабиринтов, следует породить подкласс от MazeFactory. 
В этом подклассе замещены различные функции класса, так что он возвращает другие подклассы классов Room, Wall и т. д.: */
class EnchantedMazeFactory : public MazeFactory
{
public:
	EnchantedMazeFactory();
	virtual Room * MakeRoom(int n) const { return new EnchantedRoom(n, CastSpell()); }
	virtual Door * MakeDoor(Room * r1, Room * r2) const { return new DoorNeedingSpell(r1, r2); }
protected:
	Spell * CastSpell() const;
};
/* А теперь предположим, что мы хотим построить для некоторой игры лабиринт, в комнате которого может быть заложена бомба. 
Если бомба взрывается, то она разрушает стены (а то и что-нибудь еще). Тогда можно породить от класса Room подкласс, 
отслеживающий, есть ли в комнате бомба и взорвалась ли она. Также понадобится подкласс класса Wall для хранения информации 
о том, были ли повреждены стены. Назовем эти классы соответственно RoomWithABomb и BombedWall. И наконец, мы определим класс
BombedMazeFactory, являющийся подклассом EnchantedMazeFactory, который создает стены класса BombedWall и комнаты класса 
RoomWithABomb. В BombedMazeFactory надо переопределить всего две функции: */
class BombedMazeFactory : public EnchantedMazeFactory
{
public:
	BombedMazeFactory();
	Wall * MakeWall() const { return new BombedWall; }
	Room * MakeRoom(int n) const { return new RoomWithABomb(n); }
protected:
	Spell * CastSpell() const;
}
/* Чтобы построить простой лабиринт, в котором могут быть спрятаны бомбы, просто вызовем функцию CreateMaze, передав ей в 
параметре BombedMazeFactory: */
MazeGame game;
BombedMazeFactory factory;
game.CreateMaze(factory);
/* С таким же успехом CreateMaze можно передать в параметре EnchantedMazeFactory для построения волшебного лабиринта.
MazeFactory — всего лишь набор фабричных методов. Это самый распространенный способ реализации паттерна абстрактная фабрика. 
MazeFactory — не абстрактный класс, то есть он работает и как AbstractFactory, и как ConcreteFactory. Это еще одна типичная 
реализация для простых применений паттерна абстрактная фабрика. Поскольку MazeFactory — конкретный класс, состоящий только 
из фабричных методов, легко получить новую фабрику MazeFactory, породив подкласс и заместив в нем необходимые операции.
В функции CreateMaze используется операция SetSide для описания сторон комнат. Если она создает комнаты с помощью фабрики
BombedMazeFactory, то лабиринт будет составлен из объектов класса RoomWithABomb, стороны которых описываются объектами 
класса BombedWall. Если классу RoomWithABomb потребуется обратиться к членам BombedWall, не имеющим аналога в его предках, 
то ссылку на объекты-стены придется преобразовать от типа Wall* к типу BombedWall*. Такое понижающее приведение безопасно 
при условии, что аргумент действительно принадлежит классу BombedWall*, а это заведомо так, если стены создаются 
исключительно фабрикой BombedMazeFactory.

	ИНКАПСУЛЯЦИЯ ЗАВИСИМОСТЕЙ ОТ РЕАЛИЗАЦИИ
 Класс Window инкапсулирует функциональность окна в любой оконной системе:
• */"операции прорисовки базовых геометрических фигур"/*;
• */"возможность свернуть и развернуть окно"/*;
• */"изменение собственных размеров"/*;
• */"перерисовка своего содержимого при необходимости"/* — например, при развертывании из значка или открытии ранее перекрытой части окна.
 Класс Window должен охватывать функциональность окон из разных оконных систем. Рассмотрим два крайних подхода:
• */"пересечение функциональности."/* Интерфейс класса Window предоставляет только функциональность, общую для всех оконных систем.
Однако в результате мы получаем интерфейс не богаче, чем в самой слабой из рассматриваемых систем. Мы не можем воспользоваться более 
мощными средствами, даже если их поддерживает большинство оконных систем (но не все);
• */"объединение функциональности."/* Создается интерфейс, который включает возможности всех существующих систем. Здесь возникает 
опасность получить чрезмерно громоздкий и внутренне противоречивый интерфейс. Кроме того, нам придется изменять его (а вместе с ним и 
наше приложение) всякий раз, как только производитель переработает интерфейс своей оконной системы.
 Ни одно из крайних решений не годится, поэтому мы выберем компромиссное. Класс Window будет предоставлять удобный интерфейс, 
поддерживающий наиболее популярные возможности оконных систем. Поскольку наш редактор будет работать с классом Window напрямую, 
этот класс должен поддерживать и сущности, о которых нашему приложению известно — то есть виджеты. Это означает, что интерфейс класса 
Window должен включать базовый набор графических операций, позволяющий виджетам отображать себя в окне.
 Управление окнами: */
virtual void Redraw()
virtual void Raise()
virtual void Lower()
virtual void Iconify()
virtual void Deiconify()
...
// Графика
virtual void DrawLine(...)
virtual void DrawRect(...)
virtual void DrawPolygon(...)
virtual void DrawText(...)
...
/* Window — это абстрактный класс. Его конкретные подклассы поддерживают различные виды окон, с которыми имеет дело 
пользователь. Например, окна приложений, сообщений, значки — это все окна, но свойства у них разные. Для учета таких 
различий мы можем определить подклассы ApplicationWindow, IconWindow и DialogWindow. Возникающая иерархия позволяет таким 
приложениям, как наше, создать унифицированную, интуитивно понятную абстракцию окна, не зависящую от оконной системы 
конкретного поставщика.
• */""/* 





























