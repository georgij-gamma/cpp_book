/*
1. Программируйте в соответствии с интерфейсом, а не с реализацией.
2. Предпочитайте композицию наследованию класса.

•	*/"При создании объекта явно указывается класс."/* Задание имени класса привязывает вас к 
конкретной реализации, а не к конкретному интерфейсу. Это может осложнить изменение объекта 
в будущем. Чтобы уйти от такой проблемы, создавайте объекты косвенно.
Паттерны проектирования: абстрактная фабрика, фабричный метод, прототип;
•	*/"Зависимость от конкретных операций."/* Задавая конкретную операцию, вы ограничиваете себя 
единственным способом выполнения запроса. Если же не включать запросы в код, то будет проще 
изменить способ удовлетворения запроса как на этапе компиляции, так и на этапе выполнения.
Паттерны проектирования: цепочка обязанностей, команда;
•	*/"Зависимость от аппаратной и программной платформ."/* Внешние интерфейсы операционной системы и 
интерфейсы прикладных программ (API) различны на разных программных и аппаратных платформах.
Если программа зависит от конкретной платформы, ее будет труднее перенести на другие. Возможно, 
даже на «родной» платформе такую программу трудно поддерживать. Поэтому при проектировании систем 
так важно ограничивать платформенные зависимости.
Паттерны проектирования: абстрактная фабрика, мост;
•	*/"Зависимость от представления или реализации объекта."/* Если клиент располагает информацией о 
том, как объект представлен, хранится или реализован, то, возможно, при изменении объекта 
придется изменять и клиента. Сокрытие этой информации от клиентов поможет уберечься от 
каскадных изменений.
Паттерны проектирования: абстрактная фабрика, мост, хранитель, заместитель;
•	*/"Зависимость от алгоритмов."/* Во время разработки и последующего использования алгоритмы часто
расширяются, оптимизируются и заменяются. Зависящие от алгоритмов объекты придется переписывать при 
каждом изменении алгоритма. Поэтому алгоритмы, которые с большой вероятностью будут изменяться, 
следует изолировать.
Паттерны проектирования: мост, итератор, стратегия, шаблонный метод, посетитель;
•	*/"Сильная связанность."/* Сильно связанные между собой классы трудно использовать порознь, так 
как они зависят друг от друга. Сильная связанность приводит к появлению монолитных систем, в которых 
нельзя ни изменить, ни удалить класс без знания деталей и модификации других классов. Такую систему 
трудно изучать, переносить на другие платформы и сопровождать.
Паттерны проектирования: абстрактная фабрика, мост, цепочка обязанностей, команда, фасад,
посредник, наблюдатель;
•	*/"Расширение функциональности за счет порождения подклассов."/* Специализация объекта путем 
создания подкласса часто оказывается непростым делом. С каждым новым подклассом связаны 
фиксированные издержки реализации (инициализация, очистка и т. д.). Для определения подкласса 
необходимо так же ясно представлять себе устройство родительского класса. Например, замещение 
одной операции может потребовать замещения и других. Кроме того, порождение подклассов ведет к 
разрастанию количества классов, поскольку даже для реализации простого расширения приходится 
создавать новые подклассы. Композиция объектов и делегирование — гибкие альтернативы наследованию
для комбинирования поведений. Приложению можно добавить новую функциональность, меняя способ 
композиции объектов, а не определяя новые подклассы уже имеющихся классов.
Паттерны проектирования: мост, цепочка обязанностей, компоновщик), декоратор, наблюдатель), стратегия;
•	*/"Неудобства при изменении классов."/* Иногда нужно модифицировать класс, но делать это неудобно.
 Допустим, вам нужен исходный код, а он недоступен (так обстоит дело с коммерческими библиотеками 
классов). Или любое изменение тянет за собой модификации множества существующих подклассов. 
Благодаря паттернам проектирования можно модифицировать классы и при таких условиях.
Паттерны проектирования: адаптер, декоратор, посетитель.

	Инструментальная библиотека — это набор взаимосвязанных, повторно используемых классов, 
спроектированный с целью предоставления полезной функциональности общего назначения. В
инструментальных библиотеках упор делается на повторном использовании кода. Это объектно-
ориентированные эквиваленты библиотек подпрограмм.
	Каркас — это набор взаимодействующих классов, составляющих повторно используемый дизайн для 
конкретного класса программ. Каркас можно адаптировать для конкретного приложения
путем порождения специализированных подклассов от входящих в него абстрактных классов. Каркас 
определяет общую структуру, ее разделение на классы и объекты, ключевые обязанности тех и 
других, методы взаимодействия объектов и классов и потоки управления. Акцент в каркасе делается 
на повторном использовании дизайна, а не кода, хотя обычно он включает и конкретные подклассы, 
которые можно применять непосредственно. Повторное использование на данном уровне означает 
инверсию контроля между приложением и программным обеспечением, лежащим в его основе. При 
использовании инструментальной библиотеки (или, если хотите, обычной библиотеки подпрограмм) 
вы пишете основной код приложения и вызываете из него код, который планируете использовать 
повторно. При работе с каркасом вы, наоборот, повторно используете основной код и пишете код, 
который он вызывает. Вам приходится кодировать операции с предопределенными именами и 
параметрами вызова, но зато число принимаемых вами проектных решений сокращается.
	Если проектировать приложения нелегко, инструментальные библиотеки — еще сложнее, то 
проектирование каркасов — задача самая трудная! Поскольку приложения так сильно зависят от 
каркаса, они особенно чувствительны к изменениям его интерфейсов. По мере усложнения каркаса 
приложения должны эволюционировать вместе с ним. В результате существенно возрастает значение 
слабой связанности, в противном случае малейшее изменение каркаса приведет к целой волне 
модификаций.
	Различия между паттернами и каркасами:
•	*/"Паттерны проектирования более абстрактны, чем каркасы."/* В код могут быть включены целые 
каркасы, но только отдельные воплощения паттернов. Каркасы можно писать на разных языках 
программирования и не только изучать, но и непосредственно исполнять и повторно использовать.
Паттерны проектирования, необходимо реализовывать всякий раз, когда в них возникает 
необходимость. Паттерны объясняют намерения проектировщика, сильные и слабые стороны, а также 
последствия выбранного дизайна;
•	*/"Как архитектурные элементы, паттерны проектирования мельче, чем каркасы."/* Типичный 
каркас содержит несколько паттернов. Обратное утверждение неверно;
•	*/"Паттерны проектирования менее специализированы, чем каркасы."/* Каркас всегда создается 
для конкретной предметной области. В принципе каркас графического редактора можно использовать 
для моделирования работы фабрики, но его никогда не спутаешь с каркасом, предназначенным 
специально для моделирования. Напротив, паттерны могут использоваться в приложениях любого вида.
	
	КАК ВЫБИРАТЬ ПАТТЕРН ПРОЕКТИРОВАНИЯ
	*/"Подумайте, как паттерны решают проблемы проектирования."/*
	*/"Пролистайте разделы каталога, описывающие назначение паттернов."/*
	*/"Изучите взаимосвязи паттернов."/*
	*/"Проанализируйте паттерны со сходными целями."/*
	*/"Разберитесь в причинах, вызывающих перепроектирование."/*
	*/"Посмотрите, какие аспекты вашего дизайна могут измениться."/* Вместо того чтобы думать, 
что могло бы заставить изменить дизайн, подумайте о том, что бы вам хотелось иметь возможность 
изменять без перепроектирования. Акцент здесь делается на инкапсуляции концепций, подверженных 
изменениям — основной теме многих паттернов. Аспекты дизайна, которые могут изменяться при 
применении паттернов проектирования: */
	Назначение			|Паттерн проектирования	|Переменные аспекты
======================================================================================================
Порождающие паттерны	|Абстрактная фабрика	| Семейства порождаемых объектов.
						|Одиночка				| Единственный экземпляр класса.
						|Прототип				| Класс, на основе которого создается объект.
						|Строитель				| Способ создания составного объекта.
						|Фабричный метод		| Подкласс создаваемого объекта.
------------------------------------------------------------------------------------------------------
Структурные паттерны	|Адаптер				| Интерфейс к объекту.
						|Декоратор				| Обязанности объекта без порождения подкласса.
						|Заместитель			| Способ доступа к объекту, его местоположение.
						|Компоновщик			| Структура и состав объекта.
						|Мост					| Реализация объекта.
						|Приспособленец			| Затраты на хранение объектов.
						|Фасад					| Интерфейс к подсистеме.
------------------------------------------------------------------------------------------------------
Паттерны поведения		|Интерпретатор			| Грамматика и интерпретация языка.
						|Итератор				| Способ перебора элементов агрегата.
						|Команда				| Время и способ выполнения запроса.
						|Наблюдатель			| Множество объектов, зависящих от другого 
						|						|объекта; способ, которым зависимые объекты 
						|						|поддерживают себя в актуальном состоянии.
						|Посетитель				| Операции, которые могут применяться к 
						|						|объекту или объектам, не меняя класса.
						|Посредник				| Взаимодействующие объекты и механизм их 
						|						|совместной работы.
						|Состояние				| Состояние объекта.
						|Стратегия				| Алгоритм.
						|Хранитель				| Закрытая информация, хранящаяся вне объекта, 
						|						|и время ее сохранения.
						|Цепочка обязанностей	| Объект, выполняющий запрос.
						|Шаблонный метод		| Шаги алгоритма.
======================================================================================================
/*	Последовательность действий, которая поможет вам эффективно применить паттерн:
1. Прочитайте описание паттерна, чтобы получить о нем общее представление.
2. Изучите разделы «Структура», «Участники» и «Отношения».
3. Просмотрите раздел «Пример кода» с конкретным примером применения паттерна в программе.		
4. Выберите для участников паттерна подходящие имена. Бывает полезно включить имя участника 
как составную часть имени, используемого в программе. Например, если вы пользуетесь паттерном 
стратегия в алгоритме размещения текста, то классы могли бы называться SimpleLayoutStrategy 
или TeXLayoutStrategy.
5. Определите классы. Объявите их интерфейсы, установите отношения наследования и определите 
переменные экземпляра, представляющие данные объекта и ссылки на другие объекты. Выявите в своем 
приложении классы, на которые паттерн оказывает влияние, и соответствующим образом модифицируйте их.
6. Определите имена операций, встречающихся в паттерне. Здесь,  имена обычно зависят от приложения.
Руководствуйтесь теми функциями и взаимодействиями, которые ассоциированы с каждой операцией. 
Кроме того, будьте последовательны при выборе имен. Например, для обозначения фабричного метода 
можно было бы всюду использовать префикс 'Create-'.
7. Реализуйте операции, которые выполняют обязанности и обеспечивают взаимодействия, определенные 
в паттерне.

	ПАТТЕРН Компоновщик
 Назначение:
• Компонует объекты в древовидные структуры для представления иерархий «часть — целое».
Позволяет клиентам единообразно трактовать индивидуальные и составные объекты. Ключом к 
паттерну компоновщик является абстрактный класс, который представляет одновременно и 
примитивы, и контейнеры.

 Применимость:
• Требуется представить иерархию объектов вида «часть — целое»;
• Клиенты должны по единым правилам работать с составными и индивидуальными объектами.

 Результаты:
• Определяет иерархии классов, состоящие из примитивных и составных объектов. Из примитивных 
объектов можно составлять более сложные, которые, в свою очередь, участвуют в более сложных 
композициях и так далее;
• Упрощает архитектуру клиента. Клиенты могут единообразно работать с индивидуальными и 
объектами и с составными структурами. Это упрощает код клиента, поскольку нет необходимости 
писать функции, ветвящиеся в зависимости от того, с объектом какого класса они работают;
• Облегчает добавление новых видов компонентов. Изменять клиент при добавлении новых 
компонентов не нужно;
• Способствует созданию общего дизайна.

 Реализация:
• Явные ссылки на родителей. Хранение в компоненте ссылки на своего родителя может упростить обход 
структуры и управление ею. Наличие такой ссылки облегчает передвижение вверх по структуре и удаление
компонента. Кроме того, ссылки на родителей помогают реализовать паттерн цепочка обязанностей. При 
наличии ссылки на родителя важно поддерживать следующий инвариант: для всех потомков в составном 
объекте родителем является составной объект, для которого они в свою очередь являются потомками. 
Простейший способ гарантировать соблюдение этого условия — изменять родителя компонента только тогда, 
когда он добавляется или удаляется из составного объекта. Если это удается один раз реализовать в 
операциях Add и Remove, то реализация будет унаследована всеми подклассами, а следовательно, 
инвариант будет поддерживаться автоматически;
• Совместное использование компонентов. Возможное решение — позволить компонентам хранить ссылки 
на нескольких родителей. Паттерн приспособленец показывает, как следует изменить дизайн, чтобы 
вовсе отказаться от хранения родителей. Работает он в тех случаях, когда потомки могут избежать 
отправки сообщений своим родителям, вынеся за свои границы часть внутреннего состояния;
• Максимизация интерфейса базового (абстрактного) для компоновщика класса (Component). Одна из 
целей паттерна компоновщик — избавить клиентов от необходимости знать, работают ли они с примитивным 
или составным объектом. Для достижения этой цели класс Component должен сделать как можно больше 
операций общими для Composite и примитывных классов. Однако иногда эта цель вступает в конфликт с 
принципом проектирования иерархии классов, согласно которому класс должен определять только логичные 
для всех его подклассов операции. Класс Component поддерживает много операций, не имеющих смысла для
примитывных классов. Как же тогда предоставить для них реализацию по умолчанию? Если рассматривать 
примитывные классы как Component, у которых никогда не бывает потомков, то в классе Component можно 
определить операцию обращения к потомкам как никогда не возвращающую потомков. Тогда примитывные 
подклассы могут использовать эту реализацию по умолчанию, а в подклассах Composite она будет 
переопределена, чтобы возвращать потомков.
• Объявление операций для управления потомками. Хотя в классе Composite реализованы операции 
Add и Remove для добавления и удаления потомков, но для паттерна компоновщик важно, в каких 
классах эти операции объявлены. Надо ли объявлять их в классе Component и тем самым делать 
доступными в примитывных классах, или их следует объявить и определить только в классе Composite 
и его подклассах? Ответ на этот вопрос подразумевает компромисс между безопасностью и прозрачностью:
1. Если определить интерфейс для управления потомками в корне иерархии классов, мы добиваемся 
прозрачности, так как все компоненты удается трактовать единообразно. Однако за это приходится 
расплачиваться безопасностью, поскольку клиент может попытаться выполнить бессмысленное действие 
вроде добавления или удаления объекта из примитивного узла;
2. Если управление потомками определяется в классе Компоновщике, то безопасность будет обеспечена — 
ведь любая попытка добавить или удалить объекты из примитывных классов в статически типизированном 
языке вроде C++ будет перехвачена на этапе компиляции. Но прозрачность при этом теряется, так как 
примитывные и составные объекты обладают разными интерфейсами.
 В паттерне компоновщик мы придаем особое значение прозрачности, а не безопасности. Если важнее 
безопасность, будьте готовы к тому, что в некоторых случаях вы можете потерять информацию о типе, 
и компонент придется преобразовывать к типу составного объекта. Как это сделать, не прибегая к 
небезопасным приведениям типов? Можно объявить в классе Component операцию Composite* getComposite().
Класс Component реализует ее по умолчанию, возвращая null-указатель. А в классе Composite эта 
операция переопределена, чтобы она возвращала текущий объект в виде указателя this: */
class Composite;					// компоновщик
class Component						// Абстрактный базовый класс
{
public:
	// ...
	virtual Composite * getComposite() { return nullptr; }	// по умолчанию
};
class Composite : public Component	// компоновщик
{
public:
	void Add(Component *);
	// ...
	virtual Composite* getComposite() { return this; }		// переопределен
};
class Leaf : public Component		// примитывный класс
{
	// ...
};
/* Благодаря операции getComposite можно спросить у компонента, является ли он составным. К 
возвращаемому этой операцией составному объекту допустимо безопасно применять операции Add и Remove: */
Composite * aComposite = new Composite;
Leaf * aLeaf = new Leaf;
Component * aComponent;
Composite * test;
aComponent = aComposite;
if (test = aComponent->getComposite())	// aComposite != nullptr
{
	test->Add(new Leaf);					// добавить в менеджер компоновки примитив
}
aComponent = aLeaf;
if (test = aComponent->getComposite())	// aLeaf == nullptr
{
	test->Add(new Leaf);					// лист не добавляется: getComposite() не переопределен в Leaf
}
/* Аналогичные проверки на принадлежность классу Composite в C++ выполняются с помощью оператора dynamic_cast 
и typeid, тогда метод getComposite() не нужен. Если виртуальный метод вызывается через ссылку или 
указатель на объект, то программа использует метод, определенный для типа объекта, а не для типа указателя 
или ссылки. Это называется динамическим (или поздним) связыванием. Такое поведение очень важно, т.к. 
указатель или ссылка на базовый класс всегда может обратиться к объекту производного типа. */
//if( test = dynamic_cast<Composite *>(*aComponent) )	// возвращает true, если aComponent указывает на Composite и его потомков!
#include <typeinfo>		// явное именование каждого класса:
if( typeid(Composite) == typeid(*aComponent) )		// возвращает true, если aComponent указывает на Composite only.
	test->Add(new Leaf);								// добавить в менеджер компоновки примитив
/* Недостаток: снова приходится проверять тип, перед тем как предпринять то или иное действие.
Единственный способ обеспечить прозрачность — это включить в класс Component реализации операций Add и Remove по умолчанию. 
Но тогда появится новая проблема: нельзя реализовать Component::Add так, чтобы не появилась возможность ошибки. Можно, конечно, 
сделать данную операцию пустой, но тогда нарушается важное проектное ограничение: попытка добавить что-то в листовый объект, 
скорее всего, свидетельствует об ошибке. Допустимо было бы заставить ее удалять свой аргумент, но такое поведение может оказаться 
неожиданным для клиента. Лучшим решением является такая реализация Add и Remove по умолчанию, при которой они завершаются с 
ошибкой (возможно, генерируя исключение), если компоненту не разрешено иметь потомков (для Add) или аргумент не является 
чьим-либо потомком (для Remove). Другая возможность — слегка изменить семантику операции «удаление». Если компонент хранит 
ссылку на родителя, то можно было бы считать, что Component::Remove удаляет самого себя;
• Должен ли Component реализовывать список компонентов? Можно определить множество потомков в виде переменной экземпляра 
класса Component, в котором объявлены операции обращения к потомкам и управления ими. Но размещение указателя на потомков в 
базовом классе создает лишние затраты памяти во всех листовых узлах, хотя у листа потомков быть не может. Такое решение 
может использоваться только в том случае, если в структуре относительно мало потомков;
• Упорядочение потомков. Во многих случаях важен порядок следования потомков составного объекта. В примере класса Component 
под порядком может пониматься Z-порядок расположения потомков. В составных объектах, описывающих деревья синтаксического разбора, 
составные операторы могут быть экземплярами класса Composite, порядок следования потомков которых отражает семантику программы.
Если порядок следования потомков важен, необходимо учитывать его при проектировании интерфейсов доступа и управления потомками. 
В этом может помочь паттерн итератор;
• Кэширование для повышения производительности. Если приходится часто выполнять обход или поиск в композициях, то класс 
Composite может кэшировать либо непосредственно полученные результаты, либо только информацию, достаточную для ускорения обхода 
или поиска. Например, класс Picture(типа Composite), мог бы кэшировать охватывающие прямоугольники своих потомков. При 
рисовании или выделении эта информация позволила бы пропускать тех потомков, которые не видимы в текущем окне.
При любом изменении компонента кэшированная информация всех его родителей должна становиться недействительной. Наиболее 
эффективен такой подход в случае, когда компонентам известно об их родителях. Поэтому, если вы решите воспользоваться 
кэшированием, необходимо определить интерфейс, позволяющий уведомить составные объекты о недействительности содержимого их кэшей;
• Кто должен удалять компоненты? В языках, где нет уборщика мусора, лучше всего поручить классу Composite удалять своих потомков 
в момент уничтожения. Исключением из этого правила является случай, когда листовые объекты постоянны и, следовательно, могут 
использоваться совместно;
• Выбор структуры данных для хранения компонентов. Составные объекты могут хранить своих потомков в самых разных структурах 
данных, включая связанные списки, деревья, массивы и хеш-таблицы. Выбор структуры данных определяется, как всегда, эффективностью. 
Собственно говоря, вовсе не обязательно пользоваться какой-либо из универсальных структур. Иногда в составных объектах каждый 
потомок представляется отдельной переменной. Правда, для этого каждый подкласс Composite должен реализовывать свой собственный 
интерфейс управления памятью. См. пример в описании паттерна интерпретатор.

 Пример кода:
Класс Equipment определяет интерфейс для всех видов аппаратуры в иерархии вида «часть — целое»: */
class Equipment
{
public:
	virtual ~Equipment();
	const char* Name() { return _name; }
	virtual Watt Power();					// мощность
	virtual Currency NetPrice();				// цена нетто
	virtual Currency DiscountPrice();		// цена со скидкой
	virtual void Add(Equipment*);
	virtual void Remove(Equipment*);
	virtual Iterator* CreateIterator();
protected:
	Equipment(const char*);
private:
	const char* _name;
};
/* В классе Equipment объявлены операции, которые возвращают атрибуты аппаратного блока, например энергопотребление 
и стоимость. Подклассы реализуют эти операции для конкретных видов оборудования. Класс Equipment объявляет также 
операцию CreateIterator, возвращающую итератор Iterator (см. приложение В) для обращения к отдельным частям. Реализация 
этой операции по умолчанию возвращает итератор NullIterator, умеющий обходить только пустое множество.
Среди подклассов Equipment могут быть примитивные классы, представляющие дисковые накопители, микросхемы и переключатели: */
class FloppyDisk : public Equipment
{
public:
	FloppyDisk(const char*);
	virtual ~FloppyDisk();
	virtual Watt Power();
	virtual Currency NetPrice();
	virtual Currency DiscountPrice();
};
/* CompositeEquipment — это базовый класс для оборудования, содержащего другое оборудование. Одновременно это подкласс 
класса Equipment: */
class CompositeEquipment : public Equipment {
public:
	virtual ~CompositeEquipment();
	virtual Watt Power();
	virtual Currency NetPrice();
	virtual Currency DiscountPrice();
	virtual void Add(Equipment*);
	virtual void Remove(Equipment*);
	virtual Iterator* CreateIterator();
protected:
	CompositeEquipment(const char*);
private:
	List _equipment;
};
/* CompositeEquipment определяет операции для доступа и управления внутренними аппаратными блоками. Операции Add и 
Remove добавляют и удаляют оборудование из списка, хранящегося в переменной _equipment. Операция CreateIterator 
возвращает итератор (точнее, экземпляр класса ListIterator), который будет обходить этот список. Реализация по 
умолчанию операции NetPrice могла бы использовать CreateIterator для суммирования цен на отдельные блоки: */
Currency CompositeEquipment::NetPrice()
{
	Iterator * i = CreateIterator();
	Currency total = 0;
	
	for (i->First(); !i->IsDone(); i->Next())
		total += i->CurrentItem()->NetPrice();

	delete i;
	return total;
}
/* Теперь мы можем представить аппаратный блок компьютера в виде подкласса к CompositeEquipment под названием Chassis. 
Chassis наследует порожденные операции класса CompositeEquipment: */
class Chassis : public CompositeEquipment
{
public:
	Chassis(const char*);
	virtual ~Chassis();
	virtual Watt Power();
	virtual Currency NetPrice();
	virtual Currency DiscountPrice();
};
/* Аналогичным образом можно определить и другие контейнеры для оборудования, например Cabinet (корпус) и Bus (шина). 
Этого вполне достаточно для сборки из отдельных блоков (довольно простого) персонального компьютера: */
Cabinet * cabinet = new Cabinet("PC Cabinet");
Chassis * chassis = new Chassis("PC Chassis");
cabinet->Add(chassis);
Bus * bus = new Bus("MCA Bus");
bus->Add(new Card("16Mbs Token Ring"));
chassis->Add(bus);
chassis->Add(new FloppyDisk("3.5in Floppy"));
cout << "The net price is " << chassis->NetPrice() << endl;
/* Родственные паттерны:
 Отношение «компонент — родитель» используется в паттерне цепочка обязанностей.
Паттерн декоратор часто применяется совместно с компоновщиком. Когда декораторы и компоновщики используются вместе, 
у них обычно бывает общий родительский класс. Поэтому декораторам придется поддержать интерфейс компонентов такими 
операциями, как Add, Remove и GetChild.
Паттерн приспособленец позволяет совместно использовать компоненты, но ссылаться на своих родителей они уже не могут.
Итератор можно использовать для обхода составных объектов.
Посетитель локализует операции и поведение, которые в противном случае пришлось бы распределять между классами Composite и Leaf.

	ГЛИФЫ
 Абстрактный класс Glyph (глиф) определяется для всех объектов, которые могут присутствовать в структуре документа1. Его 
подклассы определяют как примитивные графические элементы (символы, изображения..), так и структурные элементы 
(строки и колонки). */
class Glyph
{
	// Внешнее представление:
	virtual void Draw(Window*)				// перерисовывает текущий объект в окне
	virtual void Bounds(Rect&)				// возвращает прямоугольную область, занимаемую глифом
	// Обнаружение точки воздействия:
	virtual bool Intersects(const Point&)	// возвращает признак, показывающий, лежит ли заданная точка в пределах глифа
	// Структура:
	virtual void Insert(Glyph*, int)			// вставляет глиф в позицию, заданную целочисленным индексом (или указателем из списка)
	virtual void Remove(Glyph*)				// удаляет глиф
	virtual Glyph* Child(int)				// возвращает потомка с заданным индексом (если таковой существует)
	virtual Glyph* Parent()					// предоставляет стандартный интерфейс для доступа к родителю глифа, если таковой имеется
}
/* Глифы, у которых действительно есть потомки (такие как Row), должны пользоваться операцией Child, а не обращаться к структуре 
данных потомка напрямую. В таком случае при изменении структуры данных, скажем, с массива на связанный список не придется 
модифицировать операции вроде Draw, которые перебирают всех потомков. */
class Rectangle: public Glyph
{
private:
	int _x0, _y0, _x1, _y1;					// определяют два противоположных угла прямоугольника
public:
	void Draw (Window* w);
}
void Rectangle::Draw (Window* w)
{
	w->DrawRect(_x0, _y0, _x1, _y1); 		// DrawRect — операция класса Window, рисующая на экране прямоугольник
}

/*	ФОРМАТИРОВАНИЕ
 Представление и форматирование — это разные аспекты проектирования. По описанию внутренней структуры невозможно определить, 
как добраться до определенной подструктуры. Базовый интерфейс класса Compositor: */
class Compositor: public Glyph
{
public:
	void SetComposition(Composition *);		// что форматировать
	virtual void Compose();					// когда форматировать
}
/* Compositor (специализированный для конкретного алгоритма разбиения на строки) и в нужные моменты предписывает 
композитору строить композицию глифов по мере изменения документа пользователем.
	ИНКАПСУЛЯЦИЯ АЛГОРИТМА ФОРМАТИРОВАНИЯ
 Важно выдержать баланс между качеством и скоростью форматирования. Также возможен компромисс между временем и памятью, 
в большей степени ориентированный на реализацию: кэширование в памяти большего объема информации может уменьшить время 
форматирования. Поскольку алгоритмы форматирования обычно оказываются весьма сложными, желательно, чтобы они были 
достаточно замкнутыми, а еще лучше — полностью независимыми от структуры документа. С другой стороны, при добавлении 
нового алгоритма форматирования не должно возникать необходимости в модификации существующих глифов. Мы должны постараться 
спроектировать приложение так, чтобы алгоритм форматирования можно было легко заменить на этапе компиляции, если уж не 
во время выполнения. Алгоритм можно изолировать и обеспечить возможность его простой замены путем инкапсуляции в объекте:
определть отдельную иерархию классов для объектов, инкапсулирующих алгоритмы форматирования. Корнем иерархии станет интерфейс, 
который поддерживает широкий спектр алгоритмов, а каждый подкласс будет реализовывать этот интерфейс в виде конкретного алгоритма 
форматирования. Тогда удастся ввести подкласс класса Glyph, который будет автоматически структурировать своих потомков с помощью  
переданного ему объекта-алгоритма.
 Неформатированный объект Composition содержит только видимые глифы, составляющие основное содержание документа. В нем нет глифов,
определяющих физическую структуру документа, например Row и Column. В таком состоянии композиция находится сразу после создания и
инициализации глифами, которые должна отформатировать. Во время форматирования композиция вызывает операцию Compose своего объекта
Compositor. Композитор обходит всех потомков композиции и вставляет новые глифы Row и Column в соответствии со своим алгоритмом 
разбиения на строки (композитор должен получить коды символов глифов Character, чтобы вычислить места разбиения на строки).






















