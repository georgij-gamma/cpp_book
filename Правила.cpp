/*
1. Программируйте в соответствии с интерфейсом, а не с реализацией.
2. Предпочитайте композицию наследованию класса.

•	*/"При создании объекта явно указывается класс."/* Задание имени класса привязывает вас к 
конкретной реализации, а не к конкретному интерфейсу. Это может осложнить изменение объекта 
в будущем. Чтобы уйти от такой проблемы, создавайте объекты косвенно.
Паттерны проектирования: абстрактная фабрика, фабричный метод, прототип;
•	*/"Зависимость от конкретных операций."/* Задавая конкретную операцию, вы ограничиваете себя 
единственным способом выполнения запроса. Если же не включать запросы в код, то будет проще 
изменить способ удовлетворения запроса как на этапе компиляции, так и на этапе выполнения.
Паттерны проектирования: цепочка обязанностей, команда;
•	*/"Зависимость от аппаратной и программной платформ."/* Внешние интерфейсы операционной системы и 
интерфейсы прикладных программ (API) различны на разных программных и аппаратных платформах.
Если программа зависит от конкретной платформы, ее будет труднее перенести на другие. Возможно, 
даже на «родной» платформе такую программу трудно поддерживать. Поэтому при проектировании систем 
так важно ограничивать платформенные зависимости.
Паттерны проектирования: абстрактная фабрика, мост;
•	*/"Зависимость от представления или реализации объекта."/* Если клиент располагает информацией о 
том, как объект представлен, хранится или реализован, то, возможно, при изменении объекта 
придется изменять и клиента. Сокрытие этой информации от клиентов поможет уберечься от 
каскадных изменений.
Паттерны проектирования: абстрактная фабрика, мост, хранитель, заместитель;
•	*/"Зависимость от алгоритмов."/* Во время разработки и последующего использования алгоритмы часто
расширяются, оптимизируются и заменяются. Зависящие от алгоритмов объекты придется переписывать при 
каждом изменении алгоритма. Поэтому алгоритмы, которые с большой вероятностью будут изменяться, 
следует изолировать.
Паттерны проектирования: мост, итератор, стратегия, шаблонный метод, посетитель;
•	*/"Сильная связанность."/* Сильно связанные между собой классы трудно использовать порознь, так 
как они зависят друг от друга. Сильная связанность приводит к появлению монолитных систем, в которых 
нельзя ни изменить, ни удалить класс без знания деталей и модификации других классов. Такую систему 
трудно изучать, переносить на другие платформы и сопровождать.
Паттерны проектирования: абстрактная фабрика, мост, цепочка обязанностей, команда, фасад,
посредник, наблюдатель;
•	*/"Расширение функциональности за счет порождения подклассов."/* Специализация объекта путем 
создания подкласса часто оказывается непростым делом. С каждым новым подклассом связаны 
фиксированные издержки реализации (инициализация, очистка и т. д.). Для определения подкласса 
необходимо так же ясно представлять себе устройство родительского класса. Например, замещение 
одной операции может потребовать замещения и других. Кроме того, порождение подклассов ведет к 
разрастанию количества классов, поскольку даже для реализации простого расширения приходится 
создавать новые подклассы. Композиция объектов и делегирование — гибкие альтернативы наследованию
для комбинирования поведений. Приложению можно добавить новую функциональность, меняя способ 
композиции объектов, а не определяя новые подклассы уже имеющихся классов.
Паттерны проектирования: мост, цепочка обязанностей, компоновщик), декоратор, наблюдатель), стратегия;
•	*/"Неудобства при изменении классов."/* Иногда нужно модифицировать класс, но делать это неудобно.
 Допустим, вам нужен исходный код, а он недоступен (так обстоит дело с коммерческими библиотеками 
классов). Или любое изменение тянет за собой модификации множества существующих подклассов. 
Благодаря паттернам проектирования можно модифицировать классы и при таких условиях.
Паттерны проектирования: адаптер, декоратор, посетитель.

	Инструментальная библиотека — это набор взаимосвязанных, повторно используемых классов, 
спроектированный с целью предоставления полезной функциональности общего назначения. В
инструментальных библиотеках упор делается на повторном использовании кода. Это объектно-
ориентированные эквиваленты библиотек подпрограмм.
	Каркас — это набор взаимодействующих классов, составляющих повторно используемый дизайн для 
конкретного класса программ. Каркас можно адаптировать для конкретного приложения
путем порождения специализированных подклассов от входящих в него абстрактных классов. Каркас 
определяет общую структуру, ее разделение на классы и объекты, ключевые обязанности тех и 
других, методы взаимодействия объектов и классов и потоки управления. Акцент в каркасе делается 
на повторном использовании дизайна, а не кода, хотя обычно он включает и конкретные подклассы, 
которые можно применять непосредственно. Повторное использование на данном уровне означает 
инверсию контроля между приложением и программным обеспечением, лежащим в его основе. При 
использовании инструментальной библиотеки (или, если хотите, обычной библиотеки подпрограмм) 
вы пишете основной код приложения и вызываете из него код, который планируете использовать 
повторно. При работе с каркасом вы, наоборот, повторно используете основной код и пишете код, 
который он вызывает. Вам приходится кодировать операции с предопределенными именами и 
параметрами вызова, но зато число принимаемых вами проектных решений сокращается.
	Если проектировать приложения нелегко, инструментальные библиотеки — еще сложнее, то 
проектирование каркасов — задача самая трудная! Поскольку приложения так сильно зависят от 
каркаса, они особенно чувствительны к изменениям его интерфейсов. По мере усложнения каркаса 
приложения должны эволюционировать вместе с ним. В результате существенно возрастает значение 
слабой связанности, в противном случае малейшее изменение каркаса приведет к целой волне 
модификаций.
	Различия между паттернами и каркасами:
•	*/"Паттерны проектирования более абстрактны, чем каркасы."/* В код могут быть включены целые 
каркасы, но только отдельные воплощения паттернов. Каркасы можно писать на разных языках 
программирования и не только изучать, но и непосредственно исполнять и повторно использовать.
Паттерны проектирования, необходимо реализовывать всякий раз, когда в них возникает 
необходимость. Паттерны объясняют намерения проектировщика, сильные и слабые стороны, а также 
последствия выбранного дизайна;
•	*/"Как архитектурные элементы, паттерны проектирования мельче, чем каркасы."/* Типичный 
каркас содержит несколько паттернов. Обратное утверждение неверно;
•	*/"Паттерны проектирования менее специализированы, чем каркасы."/* Каркас всегда создается 
для конкретной предметной области. В принципе каркас графического редактора можно использовать 
для моделирования работы фабрики, но его никогда не спутаешь с каркасом, предназначенным 
специально для моделирования. Напротив, паттерны могут использоваться в приложениях любого вида.
	
	КАК ВЫБИРАТЬ ПАТТЕРН ПРОЕКТИРОВАНИЯ
	*/"Подумайте, как паттерны решают проблемы проектирования."/*
	*/"Пролистайте разделы каталога, описывающие назначение паттернов."/*
	*/"Изучите взаимосвязи паттернов."/*
	*/"Проанализируйте паттерны со сходными целями."/*
	*/"Разберитесь в причинах, вызывающих перепроектирование."/*
	*/"Посмотрите, какие аспекты вашего дизайна могут измениться."/* Вместо того чтобы думать, 
что могло бы заставить изменить дизайн, подумайте о том, что бы вам хотелось иметь возможность 
изменять без перепроектирования. Акцент здесь делается на инкапсуляции концепций, подверженных 
изменениям — основной теме многих паттернов. Аспекты дизайна, которые могут изменяться при 
применении паттернов проектирования: */
	Назначение			|Паттерн проектирования	|Переменные аспекты
======================================================================================================
Порождающие паттерны	|Абстрактная фабрика	| Семейства порождаемых объектов.
						|Одиночка				| Единственный экземпляр класса.
						|Прототип				| Класс, на основе которого создается объект.
						|Строитель				| Способ создания составного объекта.
						|Фабричный метод		| Подкласс создаваемого объекта.
------------------------------------------------------------------------------------------------------
Структурные паттерны	|Адаптер				| Интерфейс к объекту.
						|Декоратор				| Обязанности объекта без порождения подкласса.
						|Заместитель			| Способ доступа к объекту, его местоположение.
						|Компоновщик			| Структура и состав объекта.
						|Мост					| Реализация объекта.
						|Приспособленец			| Затраты на хранение объектов.
						|Фасад					| Интерфейс к подсистеме.
------------------------------------------------------------------------------------------------------
Паттерны поведения		|Интерпретатор			| Грамматика и интерпретация языка.
						|Итератор				| Способ перебора элементов агрегата.
						|Команда				| Время и способ выполнения запроса.
						|Наблюдатель			| Множество объектов, зависящих от другого 
						|						|объекта; способ, которым зависимые объекты 
						|						|поддерживают себя в актуальном состоянии.
						|Посетитель				| Операции, которые могут применяться к 
						|						|объекту или объектам, не меняя класса.
						|Посредник				| Взаимодействующие объекты и механизм их 
						|						|совместной работы.
						|Состояние				| Состояние объекта.
						|Стратегия				| Алгоритм.
						|Хранитель				| Закрытая информация, хранящаяся вне объекта, 
						|						|и время ее сохранения.
						|Цепочка обязанностей	| Объект, выполняющий запрос.
						|Шаблонный метод		| Шаги алгоритма.
======================================================================================================
/*	Последовательность действий, которая поможет вам эффективно применить паттерн:
1. Прочитайте описание паттерна, чтобы получить о нем общее представление.
2. Вернитесь назад и изучите разделы «Структура», «Участники» и «Отношения».
3. Просмотрите раздел «Пример кода» с конкретным примером применения паттерна в программе.		
4. Выберите для участников паттерна подходящие имена. Бывает полезно включить имя участника 
как составную часть имени, используемого в программе. Например, если вы пользуетесь паттерном 
стратегия в алгоритме размещения текста, то классы могли бы называться SimpleLayoutStrategy 
или TeXLayoutStrategy.
5. Определите классы. Объявите их интерфейсы, установите отношения наследования и определите 
переменные экземпляра, представляющие данные объекта и ссылки на другие объекты. Выявите в своем 
приложении классы, на которые паттерн оказывает влияние, и соответствующим образом модифицируйте их.
6. Определите имена операций, встречающихся в паттерне. Здесь,  имена обычно зависят от приложения.
Руководствуйтесь теми функциями и взаимодействиями, которые ассоциированы с каждой операцией. 
Кроме того, будьте последовательны при выборе имен. Например, для обозначения фабричного метода 
можно было бы всюду использовать префикс 'Create-'.
7. Реализуйте операции, которые выполняют обязанности и обеспечивают взаимодействия, определенные 
в паттерне.



		
	
	

















