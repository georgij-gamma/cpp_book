/*
1. Программируйте в соответствии с интерфейсом, а не с реализацией.
2. Предпочитайте композицию наследованию класса.

•	*/"При создании объекта явно указывается класс."/* Задание имени класса привязывает вас к 
конкретной реализации, а не к конкретному интерфейсу. Это может осложнить изменение объекта 
в будущем. Чтобы уйти от такой проблемы, создавайте объекты косвенно.
Паттерны проектирования: абстрактная фабрика, фабричный метод, прототип;
•	*/"Зависимость от конкретных операций."/* Задавая конкретную операцию, вы ограничиваете себя 
единственным способом выполнения запроса. Если же не включать запросы в код, то будет проще 
изменить способ удовлетворения запроса как на этапе компиляции, так и на этапе выполнения.
Паттерны проектирования: цепочка обязанностей, команда;
•	*/"Зависимость от аппаратной и программной платформ."/* Внешние интерфейсы операционной системы и 
интерфейсы прикладных программ (API) различны на разных программных и аппаратных платформах.
Если программа зависит от конкретной платформы, ее будет труднее перенести на другие. Возможно, 
даже на «родной» платформе такую программу трудно поддерживать. Поэтому при проектировании систем 
так важно ограничивать платформенные зависимости.
Паттерны проектирования: абстрактная фабрика, мост;
•	*/"Зависимость от представления или реализации объекта."/* Если клиент располагает информацией о 
том, как объект представлен, хранится или реализован, то, возможно, при изменении объекта 
придется изменять и клиента. Сокрытие этой информации от клиентов поможет уберечься от 
каскадных изменений.
Паттерны проектирования: абстрактная фабрика, мост, хранитель, заместитель;
•	*/"Зависимость от алгоритмов."/* Во время разработки и последующего использования алгоритмы часто
расширяются, оптимизируются и заменяются. Зависящие от алгоритмов объекты придется переписывать при 
каждом изменении алгоритма. Поэтому алгоритмы, которые с большой вероятностью будут изменяться, 
следует изолировать.
Паттерны проектирования: мост, итератор, стратегия, шаблонный метод, посетитель;
•	*/"Сильная связанность."/* Сильно связанные между собой классы трудно использовать порознь, так 
как они зависят друг от друга. Сильная связанность приводит к появлению монолитных систем, в которых 
нельзя ни изменить, ни удалить класс без знания деталей и модификации других классов. Такую систему 
трудно изучать, переносить на другие платформы и сопровождать.
Паттерны проектирования: абстрактная фабрика, мост, цепочка обязанностей, команда, фасад,
посредник, наблюдатель;
•	*/"Расширение функциональности за счет порождения подклассов."/* Специализация объекта путем 
создания подкласса часто оказывается непростым делом. С каждым новым подклассом связаны 
фиксированные издержки реализации (инициализация, очистка и т. д.). Для определения подкласса 
необходимо так же ясно представлять себе устройство родительского класса. Например, замещение 
одной операции может потребовать замещения и других. Кроме того, порождение подклассов ведет к 
разрастанию количества классов, поскольку даже для реализации простого расширения приходится 
создавать новые подклассы. Композиция объектов и делегирование — гибкие альтернативы наследованию
для комбинирования поведений. Приложению можно добавить новую функциональность, меняя способ 
композиции объектов, а не определяя новые подклассы уже имеющихся классов.
Паттерны проектирования: мост, цепочка обязанностей, компоновщик), декоратор, наблюдатель), стратегия;
•	*/"Неудобства при изменении классов."/* Иногда нужно модифицировать класс, но делать это неудобно.
 Допустим, вам нужен исходный код, а он недоступен (так обстоит дело с коммерческими библиотеками 
классов). Или любое изменение тянет за собой модификации множества существующих подклассов. 
Благодаря паттернам проектирования можно модифицировать классы и при таких условиях.
Паттерны проектирования: адаптер, декоратор, посетитель.

	Инструментальная библиотека — это набор взаимосвязанных, повторно используемых классов, 
спроектированный с целью предоставления полезной функциональности общего назначения. В
инструментальных библиотеках упор делается на повторном использовании кода. Это объектно-
ориентированные эквиваленты библиотек подпрограмм.
	Каркас — это набор взаимодействующих классов, составляющих повторно используемый дизайн для 
конкретного класса программ. Каркас можно адаптировать для конкретного приложения
путем порождения специализированных подклассов от входящих в него абстрактных классов. Каркас 
определяет общую структуру, ее разделение на классы и объекты, ключевые обязанности тех и 
других, методы взаимодействия объектов и классов и потоки управления. Акцент в каркасе делается 
на повторном использовании дизайна, а не кода, хотя обычно он включает и конкретные подклассы, 
которые можно применять непосредственно. Повторное использование на данном уровне означает 
инверсию контроля между приложением и программным обеспечением, лежащим в его основе. При 
использовании инструментальной библиотеки (или, если хотите, обычной библиотеки подпрограмм) 
вы пишете основной код приложения и вызываете из него код, который планируете использовать 
повторно. При работе с каркасом вы, наоборот, повторно используете основной код и пишете код, 
который он вызывает. Вам приходится кодировать операции с предопределенными именами и 
параметрами вызова, но зато число принимаемых вами проектных решений сокращается.
	Если проектировать приложения нелегко, инструментальные библиотеки — еще сложнее, то 
проектирование каркасов — задача самая трудная! Поскольку приложения так сильно зависят от 
каркаса, они особенно чувствительны к изменениям его интерфейсов. По мере усложнения каркаса 
приложения должны эволюционировать вместе с ним. В результате существенно возрастает значение 
слабой связанности, в противном случае малейшее изменение каркаса приведет к целой волне 
модификаций.
	Различия между паттернами и каркасами:
•	*/"Паттерны проектирования более абстрактны, чем каркасы."/* В код могут быть включены целые 
каркасы, но только отдельные воплощения паттернов. Каркасы можно писать на разных языках 
программирования и не только изучать, но и непосредственно исполнять и повторно использовать.
Паттерны проектирования, необходимо реализовывать всякий раз, когда в них возникает 
необходимость. Паттерны объясняют намерения проектировщика, сильные и слабые стороны, а также 
последствия выбранного дизайна;
•	*/"Как архитектурные элементы, паттерны проектирования мельче, чем каркасы."/* Типичный 
каркас содержит несколько паттернов. Обратное утверждение неверно;
•	*/"Паттерны проектирования менее специализированы, чем каркасы."/* Каркас всегда создается 
для конкретной предметной области. В принципе каркас графического редактора можно использовать 
для моделирования работы фабрики, но его никогда не спутаешь с каркасом, предназначенным 
специально для моделирования. Напротив, паттерны могут использоваться в приложениях любого вида.


















