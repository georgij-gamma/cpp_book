/* Статический член класса обладает особым свойством: программа
создает только одну копию статической переменной класса независимо
от количества создаваемых объектов.
Если, к примеру, создано десять объектов StringBad, то в них будут 
содержаться десять членов str и десять членов lеп, но лишь один общий член num_strings
(рис. 12.1). Это удобно для данных, которые являются закрытыми для класса, но при
этом должны иметь одно общее значение для всех объектов класса. Например, член
num_strings предназначен для отслеживания количества создаваемых объектов. */
class StringBad
{
private:
	char * str;
	int len;
	static int num_strings; // статический член класса
public:
...
};
/* Следующий оператор устанавливает первоначальное значение 0 для статического
члена num_strings: */
int StringBad::num_strings = 0; /* При инициализации используется операция разрешения 
контекста, чтобы указать, к какому классу принадлежит статический член.
 Статическую переменную-член нельзя инициализировать внутри объявления класса.
Объявление — это описание того, как выделяется память, но не само выделение. Память 
выделяется и инициализируется при создании объекта на основе данного формата. 
Для статического члена класса осуществляется независимая инициализация — с помощью 
отдельного оператора вне объявления класса. Это объясняется тем, что статический 
член класса хранится не в составе объектов. Оператор инициализации задает тип и 
указывает область действия, но не содержит ключевое слово static.
 Исключение, когда статические данные-члены все-таки инициализируются внутри 
объявления класса — если статический член данных определяется как  константа 
целочисленного или перечислимого типа.
 Каждый конструктор содержит выражение num_strings++. Это значит, что 
каждый раз, когда программа создает новый объект, общая переменная num_strings
увеличивается на единицу, т.е. всегда содержит общее количество объектов String.
А деструктор содержит выражение — num_strings. Таким образом, класс String 
отслеживает не только создание, но и удаление объектов, храня в переменной 
num_strings их текущее количество.
 Указатель строки можно передать конструктору при инициализации объекта: */
String boston("Boston");
/* Затем конструктор должен выделить объем памяти, достаточный для хранения
строки, и скопировать строку в это место. */
StringBad::StringBad(const char * s)
{
  len = std::strlen(s);             // установка размера
  str = new char[len + 1];          // выделение памяти
  std::strcpy(str, s);              // инициализация указателя
  num_strings++;                    // счетчик объектов
  std::cout << num_strings << ": \"" << str
			<< "\" object created\n"; // для целей отладки
}
/* Применяется операция new, чтобы выделить память, достаточную для хранения строки, 
и адрес этого участка памяти заносится в член str. Поскольку функция strlen() 
возвращает длину строки без завершающего нулевого символа, конструктор увеличивает 
len на единицу, чтобы уместить строку с нулевым символом. Функция strcpy() для 
копирования передаваемой строки в новый участок памяти. Затем обновляется счетчик 
объектов. Строка не хранится в объекте. Символы находятся отдельно, в куче, а сам 
объект просто указывает, где их найти. */
str = s; // не делайте так:
// Этот код просто сохраняет адрес, но не создает копию строки.
StringBad::~StringBad()	// необходимый деструктор
{
    std::cout << "\"" << str << "\" object deleted, "; // для целей отладки
    --num_strings;							// является обязательным
    std::cout << num_strings << " left\n";	// для целей отладки
    delete[] str;							// является обязательным
}
/* Операция delete необходима. Ведь член str указывает на память, выделенную 
операцией new. При уничтожении объекта StringBad исчезает и указатель str. 
Однако память, на которую указывал str, остается выделенной, пока не будет 
освобождена операцией delete. Удаление объекта освобождает память, занимаемую 
самим объектом, но при этом не освобождается автоматически память, адресованная 
указателями, которые были членами объекта. Для этого нужно использовать деструктор. 
Операция delete в деструкторе перед удалением объекта освобождает память, 
выделенную в конструкторе операцией new. Если использовалась операция new[] 
(с квадратными скобками), то нужно применять операцию delete[] (тоже с квадратными 
скобками).
Рассмотрим следующую строку: */
StringBad sailor = sports;
/* Какой конструктор здесь используется? Не конструктор по умолчанию и не 
конструктор с параметром const char *. Вспомните, что инициализация, применяющая
данную форму, должна иметь другой синтаксис: */
StringBad sailor = StringBad(sports); // конструктор, использующий sports
/* Поскольку объект sports имеет тип StringBad, соответствующий конструктор
должен обладать следующим прототипом: */
StringBad(const StringBad &);
/* Оказывается, что компилятор автоматически генерирует этот конструктор 
(называемый конструктором копирования, поскольку он создает копию объекта), если 
один объект инициализируется другим. Автоматически сгенерированной версии 
конструктора ничего не известно про обновление статической переменной num_strings, 
поэтому подсчет и нарушается. Так что все проблемы, обнаруженные в данном 
примере, возникли из-за функций-членов, которые компилятор генерирует автоматически.
Давайте рассмотрим данную тему.
	Специальные функции-члены.
 Cпециальных функци-члены определяются автоматически.
C++ автоматически предоставляет следующие функции-члены:
• конструктор по умолчанию, если не было определено ни одного конструктора;
• деструктор  по умолчанию, если он не был определен;
• конструктор копирования,  если он не был определен;
• операция присваивания, если она не была определена;
• операция взятия адреса, если она не была определена. 
 Неявная операция взятия адреса возвращает адрес вызывающего объекта (т.е. значение 
указателя this). В С++11 предлагаются еще две специальные функции-члена —
конструктор переноса и операция присваивания с переносом.
	Конструкторы копирования
 Используется во время инициализации — в том числе при передаче функции аргументов 
по значению — но не во время обычного присваивания. Конструктор копирования для 
класса обычно имеет следующий прототип: */
Имя_класса(const Имя_класса &);
/* Обратите внимание, что в качестве аргумента он принимает константную ссылку
на объект класса: */
StringBad(const StringBad &);
/* О конструкторе копирования нужно знать два момента: когда он используется и
что он делает. Когда:
 Когда новый объект явно инициализируется существующим объектом. Например, если 
motto является объектом StringBad, то следующие четыре объявления вызывают конструктор 
копирования: */
StringBad ditto(motto);				// вызывает StringBad(const StringBad &)
StringBad metoo = motto;			// вызывает StringBad(const StringBad &)
StringBad also = StringBad(motto);	// вызывает StringBad(const StringBad &)
StringBad * pStringBad = new StringBad(motto); // вызывает StringBad(const StringBad &)
/* Приведенный выше код инициализирует анонимный объект значением motto и присваивает 
адрес нового объекта указателю pstring. Компилятор использует конструктор копирования при
каждом генерировании копии объекта в программе. Компилятор также использует 
конструктор копирования при генерировании временных объектов. Например, компилятор 
может генерировать временный объект Vector для хранения промежуточного результата 
при сложении трех объектов Vector.
Следующий вызов функции void callme2(StringBad sb): */ 
callme2(headline2); /* запускает конструктор копирования, который применяется для
инициализации sb — формального параметра типа StringBad для функции callme2().
 Что делает:
 Конструктор копирования по умолчанию выполняет почленное копирование нестатических членов, 
также иногда называемое поверхностным копированием. Каждый член копируется по значению. */
StringBad sailor = sports;
/* эквивалентен следующему коду (который, правда, не скомпилируется по причине 
запрета доступа к закрытым членам): */
StringBad sailor;
sailor.str = sports.str;
sailor.len = sports.len;
/* Если член сам является объектом класса, для копирования одного объекта-члена в
другой используется конструктор копирования этого класса. Но это не влияет на 
статические члены, подобные num_strings, поскольку они принадлежат классу вообще,
а не отдельным объектам. Конструктор копирования по умолчанию никак не проявляет себя: 
не объявляет о создании объектов и не увеличивает счетчик num_strings.
Однако деструктор обновляет счетчик и вызывается вплоть до уничтожения всех 
объектов, независимо от способа их создания. Для решения этой проблемы необходим 
явный конструктор копирования, который обновляет счетчик: */
String::String(const String & s)
{
	num_strings++;
	... // существенный код
}
/* Если в классе имеется статические данные-члены, значение которых изменяется при 
создании новых объектов, должен быть предусмотрен явный конструктор копирования, который
принимает это во внимание.
 Неявный конструктор копирования осуществляет копирование по значению. Например: */
sailor.str = sports.str; // копирует не строку, а указатель на строку
/* То есть после того какобъекту sailor присвоено первоначальное значение sports, 
появилось два указателя на одну и ту же строку. Это не проблема, когда функция 
operator<<() использует указатель для вывода строки. Но это становится проблемой, 
когда вызывается деструктор. Ведь деструктор StringBad освобождает память, на которую 
указывает указатель str. Результат уничтожения sailor: */
delete[] sailor.str; // удаляется строка, на которую указывает ditto.str
/* Указатель sailor, str указывает на строку "Spinach Leaves Bowl for Dollars",
поскольку ему присвоено значение sports.str, которое указывает на данную 
строку. А после этого уничтожается объект sports: */
delete[] sports.str; // результат не определен
/* Здесь sports.str указывает на то поле памяти, которое уже очищено 
деструктором для объекта sailor — и поведение программы становится неопределенным или
даже разрушительным. 
 Для устранения проблем в структуре класса следует выполнять глубокое копирование.
Вместо простого копирования адреса строки конструктор копирования должен создать 
дубликат строки и присвоить адрес этого дубликата члену str. Тогда каждый объект 
получает собственную строку вместо ссылки на строку другого объекта, при каждом 
вызове деструктора освобождаются различные строки, и не происходит попыток повторного 
освобождения одной и той же строки. */
StringBad::StringBad(const StringBad & st) // явный конструктор копирования
{
	num_strings++;				// обновление статического члена
	len = st.len;				// та же самая длина
	str = new char [len + 1];	// выделение памяти
	std::strcpy(str, st.str);	// копирование строки в новое место
	cout << num_strings << ": \"" << str << "\" object created\n"; // для целей отладки
}
/* Определение конструктора копирования необходимо из-за того, что некоторые
члены класса являются указателями на данные, инициализированными операцией
new, а не самими данными. Если класс содержит члены, которые являются указателями, 
инициализированными операцией new, потребуется определить конструктор копирования, 
копирующий данные, на которые указывают указатели, а не сами указатели. Это называется 
глубоким копированием. Альтернативная форма копирования (почленное или поверхностное 
копирование) просто копирует значения указателей. Поверхностная копия — это только 
"наружное соскабливание" информации указателя для копирования, а не "глубокая добыча", 
требующая копирования конструкций, на которые указывают указатели.
	Операции присваивания.
 Подобно тому, как ANSI С разрешает присваивание структур, C++ допускает присваивание 
объектов класса. Это делается за счет автоматической перегрузки операции присваивания 
для класса, которая имеет следующий прототип: */
Имя_класса & Имя_класса::operator=(const Имя_класса &);
// Она принимает и возвращает ссылку на объект класса. Например:
StringBad & StringBad::operator=(const StringBad &);
/*	Когда:
 Перегруженная операция присваивания используется при присваивании одного
объекта другому существующему объекту: */
StringBad headline1.("Celery .Stalks at Midnight");
StringBad knot;
knot = headline1; // вызывается операция присваивания
// При инициализации объекта операция присваивания не обязательна:
StringBad metoo = knot; // используется конструктор копирования, но возможно и присваивание
/* Как и в случае конструктора копирования, неявная реализация операции 
присваивания выполняет почленное копирование. Если какой-то член сам является объектом
некоторого класса, то программа использует операцию присваивания, определенную
для данного класса, чтобы выполнить копирование для данного конкретного члена.
На статические члены данных это не распространяется.
	Где: */
knot = headline1; // присваивание
/* Здесь присутствует та же проблема, что и с неявным конструктором 
копирования — запорченные данные. И снова все упирается в почленное копирование, 
когда и headlinel.str, и knot.str указывают на один и тот же адрес. При вызове 
деструктора для knot строка "Celery Stalks at Midnight" удаляется, а при вызове 
деструктора для headlinel программа пытается удалить уже удаленную строку.
	Исправление присваивания.
• Поскольку целевой объект может ссылаться на данные, для которых уже была
распределена память, функция должна использовать операцию delete[] для
ее освобождения.
• Функция должна содержать защиту от присваивания объекта самому себе —
иначе вышеописанное освобождение памяти может стереть содержимое объекта до
того, как оно будет переустановлено.
• Функция возвращает ссылку на вызывающий объект.
Возвращая объект, функция может эмулировать цепочку обычных присваиваний для 
встроенных типов. То есть если S0, S1 и S2 являются объектами StringBad, то: */
S0 = S1 = S2;
// В нотации с помощью функций это выглядит так:
S0.operator = (S1.operator = (S2));
/* Таким образом, значение, возвращаемое функцией S1.operator = (S2), 
становится аргументом функции S0.operator = (). Поскольку возвращаемое значение 
является ссылкой на объект String, это корректный тип аргумента. */
StringBad & StringBad::operator=(const StringBad & st) // операция присваивания
{
	if (this == &st)				// присваивание объекта самому себе
		return *this;			// все готово
	delete[] str;				// освобождение старой строки
	len = st.len;
	str = new char[len + 1] ;	// выделение памяти для новой строки
	std::strcpy(str, st.str);	// копирование строки
	return *this;				// возврат ссылки на вызывающий объект
}
/* Сначала код проверяет, не выполняется ли присваивание самому себе. Для этого
адрес в правой части присваивания (&st) сравнивается с адресом принимающего 
объекта (this). Если они совпадают, функция возвращает *this и завершает работу. 
 Иначе функция переходит к освобождению памяти, на которую указывает str.
Ведь после этого указателю str будет присвоен адрес новой строки. Если не 
выполнить сначала операцию delete, то предыдущая строка останется в памяти, а 
поскольку указатель на старую строку уже не существует, память будет занята зря.
Далее функция действует как конструктор копирования: выделяет достаточный
объем памяти для новой строки и копирует строку из объекта в правой части в новое
место. После этого функция возвращает *this и завершается. Присваивание не создает 
новый объект, поэтому корректировать значение статического члена данных num_strings 
не нужно.
 Новый конструктор по умолчанию выглядит следующим образом: */
String::String()
{
	len = 0;
	str = new char[1];
	str[0] = '\0';	// строка по умолчанию
}
// Почему в коде применяется оператор:
str = new char[1];
// а не:
str = new char;
/* Обе формы выделяют одинаковый объем памяти. Различие состоит в том, что 
первая форма совместима с деструктором класса delete[] str;, а вторая нет.
Использование операции delete[] совместимо с указателями, инициализированными 
операцией new[], и с нулевым указателем. Поэтому еще одним вариантом 
является замена кода. */
str = new char[1];
str[0] = '\0'; // строка по умолчанию
// кодом
str = 0; // теперь str — нулевой указатель
/* Результат использования delete[] с любыми указателями, инициализированными
любым другим способом, не определен: */
char words[15] = "bad idea";
char * p1 = words;
char * p2 = new char;
char * p3;
delete[] p1; // не определено, поэтому не делайте так
delete[] р2; // не определено, поэтому не делайте так
delete[] р3; // не определено, поэтому не делайте так
/* Иногда программисты употребляют конструкцию (void *) 0, чтобы подчеркнуть, 
что это именно указатель. (Сам нулевой указатель может иметь и ненулевое внутреннее 
представление.) Другие программисты используют макрос NULL, определенный в языке С 
для представления нулевого указателя. Но эти решения все-таки неполны. В С++11 
введено лучшее решение — ключевое слово nullptr, которое означает нулевой указатель. */
str = nullptr; // нотация нулевого указателя в C++11
/*	Члены для сравнений.
Функция operator<() возвращает значение true, если первая строка идет раньше второй 
в алфавитном порядке (точнее, в машинной последовательности сопоставления). 
strcmp() возвращает отрицательное значение, если первый аргумент предшествует второму 
по алфавиту; 0, если строки одинаковые, и положительное значение, если первая строка 
по алфавиту следует за второй. */
bool operator<(const String &st1, const String &st2)
{
	if (std::strcmp(st1.str, st2.str) > 0)
		return true;
	else
		return false;
}
/* Поскольку встроенная операция > уже возвращает значение типа bool, можно 
дополнительно упростить код: */
bool operator<(const String &st1, const String &st2)
{
	return (std::strcmp(st1.str, st2.str) < 0);
}
// По аналогии можно записать и две остальные функции сравнения:
bool operator>(const String &st1, const String &st2)
{
	return st2.str < st1.str;
}
bool operator==(const String &st1, const String &st2)
{
	return (std:strcmp(st1.str, st2.str) == 0);
}
/* Первое определение выражает операцию > через операцию < и может служить 
хорошим кандидатом на встроенную функцию. Создание дружественных функций 
сравнения облегчает сравнение объектов String и стандартных строк С. 
 Пусть, например, answer — объект String, и имеется следующий код: */
if ("love" == answer)
// Он транслируется в такой код:
if (operator==("love", answer))
/* Затем компилятор использует один из конструкторов для преобразования кода
к следующему виду: */
if (operator==(String("love"), answer)) // И это как раз соответствует прототипу.
/*	Доступ к символам с помощью скобочной нотации.
 Пусть opera является объектом String: */
String opera("The Magic Flute");
/* Если в коде имеется выражение opera[4], C++ ищет метод со следующим именем
и сигнатурой: */
operator[](int i)
/* Если такой прототип найден, компилятор заменяет выражение opera[4] вызовом
данной функции:*/
opera.operator[](4)
/* Объект opera вызывает метод, а индекс массива 4 становится аргументом функции.
 Вот пример простой реализации скобочной операции: */
char & String::operator[](int i)
{
	return str[i];
}
// При таком определении оператор
cout << opera[4];
// транслируется в
cout << opera.operator[](4);
/* При этом возвращается значение opera.str[4], т.е. символ 'е'. Подобным образом
открытый метод предоставляет доступ к закрытым данным.
Если объявить возвращаемый тип как char &, то это позволит присваивать 
значения отдельным элементам. Например, можно использовать следующий код: */
String means("might");
means[0] = 'r';
// Второй оператор преобразуется в вызов функции перегруженной операции:
means.operator[][0] = 'r';
/* Это код присваивает 'r' возвращаемому значению метода. Но функция возвращает
ссылку на means.str[0], поэтому данный код эквивалентен следующему: */
means.str[0] = 'r';
/* Последняя строка кода нарушает закрытый доступ, но операция operator[]() 
является методом класса, и она допускает изменения содержимого массива. В результате
строка "might" становится "right". Предположим, что имеется константный объект: */
const String answer("futile");
/* Тогда если единственным доступным определением operator[]() является 
приведенное выше, то следующий код будет помечен как ошибочный: */
cout << answer[1]; // ошибка компиляции
/* Объект answer объявлен как константный, а метод не обещает не менять данные. 
при перегрузке C++ может различить сигнатуры константных и не константных функций, 
поэтому можно предусмотреть вторую версию operator[](), которая будет 
использоваться только объектами const String: */
const char & String::operator[](int i) const
{
	return str[i];
}
/* Такие определения позволят иметь доступ для чтения и записи к обычным 
объектам String и доступ только для чтения к данным const String: */
String text("Once upon a time");
const String answer("futile");
cout << text[1];		// нормально, используется не константная версия operator[]()
cout << answer[1];	// нормально, используется константная версия operator[]()
cin  >> text[1];		// нормально, используется не константная версия operator[]()
cin  >> answer[1];	// ошибка компиляции
/*	Статические функции-члены класса.
 Функцию-член можно объявить как статическую. Ключевое слово static должно
присутствовать в объявлении, а не в определении функции, если последнее 
размещается отдельно. Это влечет за собой два важных следствия:
 Во-первых, статическую функцию-член не обязательно вызывать через объект, она
даже не получает указатель this. Если статическая функция-член объявляется в 
разделе public, то ее можно вызвать с помощью имени класса и операции разрешения
контекста. К примеру, в класс String можно добавить статическую функцию-член с
именем HowMany() и следующим прототипом/определением в объявлении класса: */
static int HowMany() { return num_strings; }
// Вызвать ее можно так:
int count = String::HowMany(); // вызов статической функции-члена
/* Во-вторых, поскольку статическая функция-член не связана с каким-либо 
конкретным объектом, то она может использовать только статические члены данных.
	Дополнительная перегрузка операции присваивания.
 Самым простым способом увеличения эффективности процесса является 
перегрузка операции присваивания таким образом, чтобы она работала непосредственно
с обычными строками. Это устранит дополнительные шаги по созданию и удалению
временного объекта. Ниже показана одна из возможных реализаций: */
String & String::operator=(const char * s)
{
	delete [] str;
	len = std::strlen(s);
	str = new char [len + 1];
	std::strcpy(str, s);
	return *this;
}
/* Как обычно, необходимо освободить память, ранее управляемую указателем str, и
выделить достаточный объем памяти для новой строки.
	Простой вывод String. */
std::istream & operator>>(std::istream & is, String & st)		// Простой ввод String
{
	char temp[String::CINLIM];	  // строка длиной String::CINLIM
	is.get(temp, String::CINLIM); // принимает введенную строку длиной String::CINLIM
								  // или менее символов 
	if (is) /* false, если ввод данных по каким-то причинам аварийно прерывается —
			   например, появление условия конца файла или, в случае get (char *, int), 
			   чтение пустой строки.*/
		st = temp;
	while (is && is.get() != '\n')
		continue;
	return is;
}
/*	О чем следует помнить при использовании операции new в конструкторах?
• Если для инициализации указателя-члена в конструкторе применяется операция
new, то в деструкторе нужно использовать операцию delete.
• Операции new и delete должны быть согласованными. Операции new должна
соответствовать операция delete, а операции new[] — операция delete[].
• Если применяется несколько конструкторов, все они должны единообразно 
использовать операцию new — либо все со скобками, либо все без скобок. В классе
существует только один деструктор, и все конструкторы должны быть 
совместимы с ним. При этом допустимо инициализировать указатель с помощью 
операции new в одном конструкторе и с помощью нулевого указателя (NULL или
nullptr в С++11) — в другом, поскольку к нулевому указателю можно применять
операцию delete (со скобками или без них).
• Необходимо определить конструктор копирования, в котором инициализация
одного объекта другим выполняется с помощью глубокого копирования.
• Необходимо определить операцию присваивания, в которой копирование 
одного объекта в другой осуществляется с помощью глубокого копирования.
То есть метод должен проверить наличие присваивания объекта самому себе,
освободить память, на которую ранее указывал указатель-член, скопировать 
данные, а не только их адрес, и возвратить ссылку на вызвавший объект.
	Что следует делать, а что делать нельзя:
 В первом конструкторе не хватает вызова new для инициализации str. Деструктор,
вызываемый для объекта, применяет к str операцию delete. Результат использования 
операции delete с указателем, который не был инициализирован с помощью new, не 
определен: */
String::String()
{
	str = "default string";	// неверно: не хватает new[]
	len = std::strlen(str)
}
// Подойдет один из следующих вариантов:
String::String()
{
	len = 0;
	str = new char[1];		// используется new с []
	str[0] = '\0';
}
String::String()
{
	len = 0;
	str = 0;				// или str = nullptr; в С++11
}
String::String()
{
	static const char *s = "C++"; // инициализируется только однажды
	len = std::strlen(s);
	str = new char [len + 1];	  // использует new с []
	std::strcpy(str, s);
}
/* Конструктор ниже в исходном фрагменте выполняет операцию new, но не 
запрашивает нужный объем памяти. Поэтому операция new возвращает блок памяти,
способный вместить только один символ. При попытке скопировать в это место 
более длинную строку возникнут проблемы с памятью. К тому же использование new без
скобок несовместимо с правильной формой других конструкторов.*/
String::String(const char *s)
{
	len = std::strlen(s);
	str = new char;				// неверно: не хватает []
	std::strcpy(str, s);		// неверно: некуда же
}
// Третий конструктор ошибок не содержит:
String::String(const String & st)
{
	len = st.len;
	str = new char [len + 1];	// правильно: выделение памяти
	std::strcpy(str, st.str);	// правильно: копируется значение
}
/* В завершение рассмотрим пример деструктора, который не будет правильно 
работать с приведенными ранее конструкторами: */
String::~String()
{
	delete str; // неверно, нужно использовать delete [] str;
}
/* В деструкторе неправильно используется delete. Поскольку конструкторы 
запрашивают массив символов, деструктор должен удалять массив.
















