/* Статический член класса обладает особым свойством: программа
создает только одну копию статической переменной класса независимо
от количества создаваемых объектов.
Если, к примеру, создано десять объектов StringBad, то в них будут 
содержаться десять членов str и десять членов lеп, но лишь один общий член num_strings
(рис. 12.1). Это удобно для данных, которые являются закрытыми для класса, но при
этом должны иметь одно общее значение для всех объектов класса. Например, член
num_strings предназначен для отслеживания количества создаваемых объектов. */
class StringBad
{
private:
	char * str;
	int len;
	static int num_strings; // статический член класса
public:
...
};
/* Следующий оператор устанавливает первоначальное значение 0 для статического
члена num_strings: */
int StringBad::num_strings = 0; /* При инициализации используется операция разрешения 
контекста, чтобы указать, к какому классу принадлежит статический член.
 Статическую переменную-член нельзя инициализировать внутри объявления класса.
Объявление — это описание того, как выделяется память, но не само выделение. Память 
выделяется и инициализируется при создании объекта на основе данного формата. 
Для статического члена класса осуществляется независимая инициализация — с помощью 
отдельного оператора вне объявления класса. Это объясняется тем, что статический 
член класса хранится не в составе объектов. Оператор инициализации задает тип и 
указывает область действия, но не содержит ключевое слово static.
 Исключение, когда статические данные-члены все-таки инициализируются внутри 
объявления класса — если статический член данных определяется как  константа 
целочисленного или перечислимого типа.
 Каждый конструктор содержит выражение num_strings++. Это значит, что 
каждый раз, когда программа создает новый объект, общая переменная num_strings
увеличивается на единицу, т.е. всегда содержит общее количество объектов String.
А деструктор содержит выражение — num_strings. Таким образом, класс String 
отслеживает не только создание, но и удаление объектов, храня в переменной 
num_strings их текущее количество.
 Указатель строки можно передать конструктору при инициализации объекта: */
String boston("Boston");
/* Затем конструктор должен выделить объем памяти, достаточный для хранения
строки, и скопировать строку в это место. */
StringBad::StringBad(const char * s)
{
  len = std::strlen(s);             // установка размера
  str = new char[len + 1];          // выделение памяти
  std::strcpy(str, s);              // инициализация указателя
  num_strings++;                    // счетчик объектов
  std::cout << num_strings << ": \"" << str
			<< "\" object created\n"; // для целей отладки
}
/* Применяется операция new, чтобы выделить память, достаточную для хранения строки, 
и адрес этого участка памяти заносится в член str. Поскольку функция strlen() 
возвращает длину строки без завершающего нулевого символа, конструктор увеличивает 
len на единицу, чтобы уместить строку с нулевым символом. Функция strcpy() для 
копирования передаваемой строки в новый участок памяти. Затем обновляется счетчик 
объектов. Строка не хранится в объекте. Символы находятся отдельно, в куче, а сам 
объект просто указывает, где их найти. */
str = s; // не делайте так:
// Этот код просто сохраняет адрес, но не создает копию строки.
StringBad::~StringBad()	// необходимый деструктор
{
    std::cout << "\"" << str << "\" object deleted, "; // для целей отладки
    --num_strings;							// является обязательным
    std::cout << num_strings << " left\n";	// для целей отладки
    delete[] str;							// является обязательным
}
/* Операция delete необходима. Ведь член str указывает на память, выделенную 
операцией new. При уничтожении объекта StringBad исчезает и указатель str. 
Однако память, на которую указывал str, остается выделенной, пока не будет 
освобождена операцией delete. Удаление объекта освобождает память, занимаемую 
самим объектом, но при этом не освобождается автоматически память, адресованная 
указателями, которые были членами объекта. Для этого нужно использовать деструктор. 
Операция delete в деструкторе перед удалением объекта освобождает память, 
выделенную в конструкторе операцией new. Если использовалась операция new[] 
(с квадратными скобками), то нужно применять операцию delete[] (тоже с квадратными 
скобками).
Рассмотрим следующую строку: */
StringBad sailor = sports;
/* Какой конструктор здесь используется? Не конструктор по умолчанию и не 
конструктор с параметром const char *. Вспомните, что инициализация, применяющая
данную форму, должна иметь другой синтаксис: */
StringBad sailor = StringBad(sports); // конструктор, использующий sports
/* Поскольку объект sports имеет тип StringBad, соответствующий конструктор
должен обладать следующим прототипом: */
StringBad(const StringBad &);
/* Оказывается, что компилятор автоматически генерирует этот конструктор 
(называемый конструктором копирования, поскольку он создает копию объекта), если 
один объект инициализируется другим. Автоматически сгенерированной версии 
конструктора ничего не известно про обновление статической переменной num_strings, 
поэтому подсчет и нарушается. Так что все проблемы, обнаруженные в данном 
примере, возникли из-за функций-членов, которые компилятор генерирует автоматически.
Давайте рассмотрим данную тему.
	Специальные функции-члены.
 Cпециальных функци-члены определяются автоматически.
C++ автоматически предоставляет следующие функции-члены:
• конструктор по умолчанию, если не было определено ни одного конструктора;
• деструктор  по умолчанию, если он не был определен;
• конструктор копирования,  если он не был определен;
• операция присваивания, если она не была определена;
• операция взятия адреса, если она не была определена. 
 Неявная операция взятия адреса возвращает адрес вызывающего объекта (т.е. значение 
указателя this). В С++11 предлагаются еще две специальные функции-члена —
конструктор переноса и операция присваивания с переносом.
	Конструкторы копирования
 Используется во время инициализации — в том числе при передаче функции аргументов 
по значению — но не во время обычного присваивания. Конструктор копирования для 
класса обычно имеет следующий прототип: */
Имя_класса(const Имя_класса &);
/* Обратите внимание, что в качестве аргумента он принимает константную ссылку
на объект класса: */
StringBad(const StringBad &);
/* О конструкторе копирования нужно знать два момента: когда он используется и
что он делает. Когда:
 Когда новый объект явно инициализируется существующим объектом. Например, если 
motto является объектом StringBad, то следующие четыре объявления вызывают конструктор 
копирования: */
StringBad ditto(motto);				// вызывает StringBad(const StringBad &)
StringBad metoo = motto;			// вызывает StringBad(const StringBad &)
StringBad also = StringBad(motto);	// вызывает StringBad(const StringBad &)
StringBad * pStringBad = new StringBad(motto); // вызывает StringBad(const StringBad &)
/* Приведенный выше код инициализирует анонимный объект значением motto и присваивает 
адрес нового объекта указателю pstring. Компилятор использует конструктор копирования при
каждом генерировании копии объекта в программе. Компилятор также использует 
конструктор копирования при генерировании временных объектов. Например, компилятор 
может генерировать временный объект Vector для хранения промежуточного результата 
при сложении трех объектов Vector.
Следующий вызов функции void callme2(StringBad sb): */ 
callme2(headline2); /* запускает конструктор копирования, который применяется для
инициализации sb — формального параметра типа StringBad для функции callme2().
 Что делает:
 Конструктор копирования по умолчанию выполняет почленное копирование нестатических членов, 
также иногда называемое поверхностным копированием. Каждый член копируется по значению. */
StringBad sailor = sports;
/* эквивалентен следующему коду (который, правда, не скомпилируется по причине 
запрета доступа к закрытым членам): */
StringBad sailor;
sailor.str = sports.str;
sailor.len = sports.len;
/* Если член сам является объектом класса, для копирования одного объекта-члена в
другой используется конструктор копирования этого класса. Но это не влияет на 
статические члены, подобные num_strings, поскольку они принадлежат классу вообще,
а не отдельным объектам. Конструктор копирования по умолчанию никак не проявляет себя: 
не объявляет о создании объектов и не увеличивает счетчик num_strings.
Однако деструктор обновляет счетчик и вызывается вплоть до уничтожения всех 
объектов, независимо от способа их создания. Для решения этой проблемы необходим 
явный конструктор копирования, который обновляет счетчик: */
String::String(const String & s)
{
	num_strings++;
	... // существенный код
}
/* Если в классе имеется статические данные-члены, значение которых изменяется при 
создании новых объектов, должен быть предусмотрен явный конструктор копирования, который
принимает это во внимание.
 Неявный конструктор копирования осуществляет копирование по значению. Например: */
sailor.str = sports.str; // копирует не строку, а указатель на строку
/* То есть после того какобъекту sailor присвоено первоначальное значение sports, 
появилось два указателя на одну и ту же строку. Это не проблема, когда функция 
operator<<() использует указатель для вывода строки. Но это становится проблемой, 
когда вызывается деструктор. Ведь деструктор StringBad освобождает память, на которую 
указывает указатель str. Результат уничтожения sailor: */
delete[] sailor.str; // удаляется строка, на которую указывает ditto.str
/* Указатель sailor, str указывает на строку "Spinach Leaves Bowl for Dollars",
поскольку ему присвоено значение sports.str, которое указывает на данную 
строку. А после этого уничтожается объект sports: */
delete[] sports.str; // результат не определен
/* Здесь sports.str указывает на то поле памяти, которое уже очищено 
деструктором для объекта sailor — и поведение программы становится неопределенным или
даже разрушительным. 
 Для устранения проблем в структуре класса следует выполнять глубокое копирование.
Вместо простого копирования адреса строки конструктор копирования должен создать 
дубликат строки и присвоить адрес этого дубликата члену str. Тогда каждый объект 
получает собственную строку вместо ссылки на строку другого объекта, при каждом 
вызове деструктора освобождаются различные строки, и не происходит попыток повторного 
освобождения одной и той же строки. */
StringBad::StringBad(const StringBad & st) // явный конструктор копирования
{
	num_strings++;				// обновление статического члена
	len = st.len;				// та же самая длина
	str = new char [len + 1];	// выделение памяти
	std::strcpy(str, st.str);	// копирование строки в новое место
	cout << num_strings << ": \"" << str << "\" object created\n"; // для целей отладки
}
/* Определение конструктора копирования необходимо из-за того, что некоторые
члены класса являются указателями на данные, инициализированными операцией
new, а не самими данными. Если класс содержит члены, которые являются указателями, 
инициализированными операцией new, потребуется определить конструктор копирования, 
копирующий данные, на которые указывают указатели, а не сами указатели. Это называется 
глубоким копированием. Альтернативная форма копирования (почленное или поверхностное 
копирование) просто копирует значения указателей. Поверхностная копия — это только 
"наружное соскабливание" информации указателя для копирования, а не "глубокая добыча", 
требующая копирования конструкций, на которые указывают указатели.
	Операции присваивания.
 Подобно тому, как ANSI С разрешает присваивание структур, C++ допускает присваивание 
объектов класса. Это делается за счет автоматической перегрузки операции присваивания 
для класса, которая имеет следующий прототип: */
Имя_класса & Имя_класса::operator=(const Имя_класса &);
// Она принимает и возвращает ссылку на объект класса. Например:
StringBad & StringBad::operator=(const StringBad &);
/*	Когда:
 Перегруженная операция присваивания используется при присваивании одного
объекта другому существующему объекту: */
StringBad headline1.("Celery .Stalks at Midnight");
StringBad knot;
knot = headline1; // вызывается операция присваивания
// При инициализации объекта операция присваивания не обязательна:
StringBad metoo = knot; // используется конструктор копирования, но возможно и присваивание
/* Как и в случае конструктора копирования, неявная реализация операции 
присваивания выполняет почленное копирование. Если какой-то член сам является объектом
некоторого класса, то программа использует операцию присваивания, определенную
для данного класса, чтобы выполнить копирование для данного конкретного члена.
На статические члены данных это не распространяется.
	Где: */
knot = headline1; // присваивание
/* Здесь присутствует та же проблема, что и с неявным конструктором 
копирования — запорченные данные. И снова все упирается в почленное копирование, 
когда и headlinel.str, и knot.str указывают на один и тот же адрес. При вызове 
деструктора для knot строка "Celery Stalks at Midnight" удаляется, а при вызове 
деструктора для headlinel программа пытается удалить уже удаленную строку.
	Исправление присваивания.
• Поскольку целевой объект может ссылаться на данные, для которых уже была
распределена память, функция должна использовать операцию delete[] для
ее освобождения.
• Функция должна содержать защиту от присваивания объекта самому себе —
иначе вышеописанное освобождение памяти может стереть содержимое объекта до
того, как оно будет переустановлено.
• Функция возвращает ссылку на вызывающий объект.
Возвращая объект, функция может эмулировать цепочку обычных присваиваний для 
встроенных типов. То есть если S0, S1 и S2 являются объектами StringBad, то: */
S0 = S1 = S2;
// В нотации с помощью функций это выглядит так:
S0.operator = (S1.operator = (S2));
/* Таким образом, значение, возвращаемое функцией S1.operator = (S2), 
становится аргументом функции S0.operator = (). Поскольку возвращаемое значение 
является ссылкой на объект String, это корректный тип аргумента. */
StringBad & StringBad::operator=(const StringBad & st) // операция присваивания
{
	if (this == &st)				// присваивание объекта самому себе
		return *this;			// все готово
	delete[] str;				// освобождение старой строки
	len = st.len;
	str = new char[len + 1] ;	// выделение памяти для новой строки
	std::strcpy(str, st.str);	// копирование строки
	return *this;				// возврат ссылки на вызывающий объект
}
/* Сначала код проверяет, не выполняется ли присваивание самому себе. Для этого
адрес в правой части присваивания (&st) сравнивается с адресом принимающего 
объекта (this). Если они совпадают, функция возвращает *this и завершает работу. 
 Иначе функция переходит к освобождению памяти, на которую указывает str.
Ведь после этого указателю str будет присвоен адрес новой строки. Если не 
выполнить сначала операцию delete, то предыдущая строка останется в памяти, а 
поскольку указатель на старую строку уже не существует, память будет занята зря.
Далее функция действует как конструктор копирования: выделяет достаточный
объем памяти для новой строки и копирует строку из объекта в правой части в новое
место. После этого функция возвращает *this и завершается. Присваивание не создает 
новый объект, поэтому корректировать значение статического члена данных num_strings 
не нужно.
 Новый конструктор по умолчанию выглядит следующим образом: */
String::String()
{
	len = 0;
	str = new char[1];
	str[0] = '\0';	// строка по умолчанию
}
// Почему в коде применяется оператор:
str = new char[1];
// а не:
str = new char;
/* Обе формы выделяют одинаковый объем памяти. Различие состоит в том, что 
первая форма совместима с деструктором класса delete[] str;, а вторая нет.
Использование операции delete[] совместимо с указателями, инициализированными 
операцией new[], и с нулевым указателем. Поэтому еще одним вариантом 
является замена кода. */
str = new char[1];
str[0] = '\0'; // строка по умолчанию
// кодом
str = 0; // теперь str — нулевой указатель
/* Результат использования delete[] с любыми указателями, инициализированными
любым другим способом, не определен: */
char words[15] = "bad idea";
char * p1 = words;
char * p2 = new char;
char * p3;
delete[] p1; // не определено, поэтому не делайте так
delete[] р2; // не определено, поэтому не делайте так
delete[] р3; // не определено, поэтому не делайте так
/* Иногда программисты употребляют конструкцию (void *) 0, чтобы подчеркнуть, 
что это именно указатель. (Сам нулевой указатель может иметь и ненулевое внутреннее 
представление.) Другие программисты используют макрос NULL, определенный в языке С 
для представления нулевого указателя. Но эти решения все-таки неполны. В С++11 
введено лучшее решение — ключевое слово nullptr, которое означает нулевой указатель. */
str = nullptr; // нотация нулевого указателя в C++11
/*	Члены для сравнений.
Функция operator<() возвращает значение true, если первая строка идет раньше второй 
в алфавитном порядке (точнее, в машинной последовательности сопоставления). 
strcmp() возвращает отрицательное значение, если первый аргумент предшествует второму 
по алфавиту; 0, если строки одинаковые, и положительное значение, если первая строка 
по алфавиту следует за второй. */
bool operator<(const String &st1, const String &st2)
{
	if (std::strcmp(st1.str, st2.str) > 0)
		return true;
	else
		return false;
}
/* Поскольку встроенная операция > уже возвращает значение типа bool, можно 
дополнительно упростить код: */
bool operator<(const String &st1, const String &st2)
{
	return (std::strcmp(st1.str, st2.str) < 0);
}
// По аналогии можно записать и две остальные функции сравнения:
bool operator>(const String &st1, const String &st2)
{
	return st2.str < st1.str;
}
bool operator==(const String &st1, const String &st2)
{
	return (std:strcmp(st1.str, st2.str) == 0);
}
/* Первое определение выражает операцию > через операцию < и может служить 
хорошим кандидатом на встроенную функцию. Создание дружественных функций 
сравнения облегчает сравнение объектов String и стандартных строк С. 
 Пусть, например, answer — объект String, и имеется следующий код: */
if ("love" == answer)
// Он транслируется в такой код:
if (operator==("love", answer))
/* Затем компилятор использует один из конструкторов для преобразования кода
к следующему виду: */
if (operator==(String("love"), answer)) // И это как раз соответствует прототипу.
/*	Доступ к символам с помощью скобочной нотации.
 Пусть opera является объектом String: */
String opera("The Magic Flute");
/* Если в коде имеется выражение opera[4], C++ ищет метод со следующим именем
и сигнатурой: */
operator[](int i)
/* Если такой прототип найден, компилятор заменяет выражение opera[4] вызовом
данной функции:*/
opera.operator[](4)
/* Объект opera вызывает метод, а индекс массива 4 становится аргументом функции.
 Вот пример простой реализации скобочной операции: */
char & String::operator[](int i)
{
	return str[i];
}
// При таком определении оператор
cout << opera[4];
// транслируется в
cout << opera.operator[](4);
/* При этом возвращается значение opera.str[4], т.е. символ 'е'. Подобным образом
открытый метод предоставляет доступ к закрытым данным.
Если объявить возвращаемый тип как char &, то это позволит присваивать 
значения отдельным элементам. Например, можно использовать следующий код: */
String means("might");
means[0] = 'r';
// Второй оператор преобразуется в вызов функции перегруженной операции:
means.operator[][0] = 'r';
/* Это код присваивает 'r' возвращаемому значению метода. Но функция возвращает
ссылку на means.str[0], поэтому данный код эквивалентен следующему: */
means.str[0] = 'r';
/* Последняя строка кода нарушает закрытый доступ, но операция operator[]() 
является методом класса, и она допускает изменения содержимого массива. В результате
строка "might" становится "right". Предположим, что имеется константный объект: */
const String answer("futile");
/* Тогда если единственным доступным определением operator[]() является 
приведенное выше, то следующий код будет помечен как ошибочный: */
cout << answer[1]; // ошибка компиляции
/* Объект answer объявлен как константный, а метод не обещает не менять данные. 
при перегрузке C++ может различить сигнатуры константных и не константных функций, 
поэтому можно предусмотреть вторую версию operator[](), которая будет 
использоваться только объектами const String: */
const char & String::operator[](int i) const
{
	return str[i];
}
/* Такие определения позволят иметь доступ для чтения и записи к обычным 
объектам String и доступ только для чтения к данным const String: */
String text("Once upon a time");
const String answer("futile");
cout << text[1];		// нормально, используется не константная версия operator[]()
cout << answer[1];	// нормально, используется константная версия operator[]()
cin  >> text[1];		// нормально, используется не константная версия operator[]()
cin  >> answer[1];	// ошибка компиляции
/*	Статические функции-члены класса.
 Функцию-член можно объявить как статическую. Ключевое слово static должно
присутствовать в объявлении, а не в определении функции, если последнее 
размещается отдельно. Это влечет за собой два важных следствия:
 Во-первых, статическую функцию-член не обязательно вызывать через объект, она
даже не получает указатель this. Если статическая функция-член объявляется в 
разделе public, то ее можно вызвать с помощью имени класса и операции разрешения
контекста. К примеру, в класс String можно добавить статическую функцию-член с
именем HowMany() и следующим прототипом/определением в объявлении класса: */
static int HowMany() { return num_strings; }
// Вызвать ее можно так:
int count = String::HowMany(); // вызов статической функции-члена
/* Во-вторых, поскольку статическая функция-член не связана с каким-либо 
конкретным объектом, то она может использовать только статические члены данных.
	Дополнительная перегрузка операции присваивания.
 Самым простым способом увеличения эффективности процесса является 
перегрузка операции присваивания таким образом, чтобы она работала непосредственно
с обычными строками. Это устранит дополнительные шаги по созданию и удалению
временного объекта. Ниже показана одна из возможных реализаций: */
String & String::operator=(const char * s)
{
	delete [] str;
	len = std::strlen(s);
	str = new char [len + 1];
	std::strcpy(str, s);
	return *this;
}
/* Как обычно, необходимо освободить память, ранее управляемую указателем str, и
выделить достаточный объем памяти для новой строки.
	Простой вывод String. */
std::istream & operator>>(std::istream & is, String & st)		// Простой ввод String
{
	char temp[String::CINLIM];	  // строка длиной String::CINLIM
	is.get(temp, String::CINLIM); // принимает введенную строку длиной String::CINLIM
								  // или менее символов 
	if (is) /* false, если ввод данных по каким-то причинам аварийно прерывается —
			   например, появление условия конца файла или, в случае get (char *, int), 
			   чтение пустой строки.*/
		st = temp;
	while (is && is.get() != '\n')
		continue;
	return is;
}
/*	О чем следует помнить при использовании операции new в конструкторах?
• Если для инициализации указателя-члена в конструкторе применяется операция
new, то в деструкторе нужно использовать операцию delete.
• Операции new и delete должны быть согласованными. Операции new должна
соответствовать операция delete, а операции new[] — операция delete[].
• Если применяется несколько конструкторов, все они должны единообразно 
использовать операцию new — либо все со скобками, либо все без скобок. В классе
существует только один деструктор, и все конструкторы должны быть 
совместимы с ним. При этом допустимо инициализировать указатель с помощью 
операции new в одном конструкторе и с помощью нулевого указателя (NULL или
nullptr в С++11) — в другом, поскольку к нулевому указателю можно применять
операцию delete (со скобками или без них).
• Необходимо определить конструктор копирования, в котором инициализация
одного объекта другим выполняется с помощью глубокого копирования.
• Необходимо определить операцию присваивания, в которой копирование 
одного объекта в другой осуществляется с помощью глубокого копирования.
То есть метод должен проверить наличие присваивания объекта самому себе,
освободить память, на которую ранее указывал указатель-член, скопировать 
данные, а не только их адрес, и возвратить ссылку на вызвавший объект.
	Что следует делать, а что делать нельзя:
 В первом конструкторе не хватает вызова new для инициализации str. Деструктор,
вызываемый для объекта, применяет к str операцию delete. Результат использования 
операции delete с указателем, который не был инициализирован с помощью new, не 
определен: */
String::String()
{
	str = "default string";	// неверно: не хватает new[]
	len = std::strlen(str)
}
// Подойдет один из следующих вариантов:
String::String()
{
	len = 0;
	str = new char[1];	// используется new с []
	str[0] = '\0';
}
String::String()
{
	len = 0;
	str = 0;				// или str = nullptr; в С++11
}
String::String()
{
	static const char *s = "C++"; // инициализируется только однажды
	len = std::strlen(s);
	str = new char[len + 1];		  // использует new с []
	std::strcpy(str, s);
}
/* Конструктор ниже в исходном фрагменте выполняет операцию new, но не 
запрашивает нужный объем памяти. Поэтому операция new возвращает блок памяти,
способный вместить только один символ. При попытке скопировать в это место 
более длинную строку возникнут проблемы с памятью. К тому же использование new без
скобок несовместимо с правильной формой других конструкторов: */
String::String(const char *s)
{
	len = std::strlen(s);
	str = new char;				// неверно: не хватает []
	std::strcpy(str, s);			// неверно: некуда же
}
// Третий конструктор ошибок не содержит:
String::String(const String & st)
{
	len = st.len;
	str = new char [len + 1];	// правильно: выделение памяти
	std::strcpy(str, st.str);	// правильно: копируется значение
}
/* В завершение рассмотрим пример деструктора, который не будет правильно 
работать с приведенными ранее конструкторами: */
String::~String()
{
	delete str; // неверно, нужно использовать delete [] str;
}
/* В деструкторе неправильно используется delete. Поскольку конструкторы 
запрашивают массив символов, деструктор должен удалять массив.
	Почленное копирование для классов с членами других классов.
 Предположим, что класс String или даже стандартный класс string используется
в качестве типа для членов другого класса: */
class Magazine
{
private:
	String title;
	string publisher;
};
/* И String, и string используют динамическое выделение памяти. Значит ли это,
что для класса Magazine нужно писать специальный конструктор копирования и
операцию присваивания? Оказывается, нет — по крайней мере, не в нем самом. С 
такой задачей способно справиться стандартное поведение почленного копирования и
присваивания. Когда осуществляется копирование или присваивание одного объекта
Magazine другому, почленное копирование использует конструкторы копирования
и операции присваивания, определенные для типов членов такого объекта.
	Возвращаемые объекты.
 Функция может возвращать ссылку на объект, константную ссылку
на объект, объект или константный объект.
	Возврат ссылки на константный объект.
 Если функция возвращает объект, который передан ей (либо путем вызова объекта, 
либо в качестве аргумента метода), то можно увеличить эффективность метода, 
возвращая из него ссылку. */
Vector force1(50,60);
Vector force2(10,70);
Vector max;
max = Max(force1, force2);
// Обе следующие реализации будут работать:
Vector Max(const Vector & v1, const Vector & v2)			 // версия 1
{
	if (v1.magval() > v2.magval() )
		return v1;
	else
		return v2;
}
const Vector & Max(const Vector & v1, const Vector & v2) // версия 2
{
	if (v1.magval () > v2.magval())
		return v1;
	else
		return v2;
}
/* Три важных момента:
 Во-первых при возврате объекта вызывается конструктор копирования, а при возврате 
ссылки — нет. Поэтому второй вариант выполняет меньше работы и более эффективен.
 Во-вторых, при выполнении вызываемой функции ссылка должна указывать на существующий
объект. В данном примере ссылка формируется либо на force1, либо на force2, причем 
оба объекта определены в вызывающей функции, поэтому указанное требование выполняется.
 В-третьих, ѵ1 и ѵ2 объявлены как константные ссылки — соответственно и возвращаемый 
тип должен быть константным.
	Возврат ссылки на не константный объект.
 Значение, возвращаемое operator=(), используется для присваивания в виде цепочки: */
String s1("Good stuff");
String s2, s3;
s3 = s2 = s1;
/* Как и в примере с объектом Vector, применение ссылки позволяет функции не 
вызывать конструктор копирования String для создания нового объекта String. В этом
случае возвращаемый тип не является константным, поскольку метод operator=()
возвращает ссылку на измененный объект s2.
 Значение, возвращаемое operator<<(), применяется для присваивания в виде цепочки: */
String s1("Good stuff");
cout << s1 << "is coming!";
/* Значение, возвращаемое методом operator<<(cout, s1), становится объектом, который 
используется для вывода строки "is coming!". Возвращаемый тип должен быть ostream &, 
а не просто ostream. Использование типа ostream потребует вызова конструктора копирования 
ostream, но класс ostream не имеет открытого конструктора копирования. Возврат ссылки на 
cout не вызывает проблем, поскольку cout уже содержится в области действия вызывающей функции.
	Возврат объекта.
 Нельзя возвращать по ссылке локальный объект для вызванной функции, поскольку при 
завершении функции для него вызывается собственный деструктор. Следует возвращать объект, 
а не ссылку: */
Vector force1(50,60);
Vector force2(10,70);
Vector net;
net = force1 + force2;
/* Сумма векторов — это новый временный объект, вычисляемый в Vector::operator+(),
а функция не должна возвращать ссылку на временный объект. */
Vector Vector::operator+(const Vector & b) const
{
	return Vector (x + b.x, y + b.y);
}
/* В примере Vector::operator+() вызов конструктора Vector(x + b.x, y + b.y) создает 
объект, доступный методу operator+(). А неявный вызов конструктора копирования, 
порождаемый оператором return, создает объект, доступный вызывающей программе.
	Возврат константного объекта.
 Предыдущее определение Vector::operator+() обладает странным свойством.
Предполагается следующее использование операции: */
net = force1 + force2; // 1: три объекта Vector
// Однако данное определение позволяет использовать и такие операторы:
force1 + force2 = net; // 2: непроизносимое программирование
cout << (force1 + force2 = net).magval() << endl; // 3: невообразимое программирование
/* Данный код допустим, поскольку конструктор копирования создает временный объект 
для  представления возвращаемого значения. Поэтому в приведенном выше коде выражение 
force1 + f orce2 означает такой временный объект. В операторе 1 временный объект 
присваивается переменной net. В операторах 2 и 3 переменная net присваивается 
временному объекту. В операторе 2 программа вычисляет сумму переменных force1 и force2, 
копирует ответ во временный возвращаемый объект, переписывает его содержимое содержимым
net и затем удаляет временный объект. Все исходные векторы остаются без изменений. 
В операторе 3 значение временного объекта выводится перед его удалением.
 Чтобы избежать проблем, обусловленных таким поведением, можно объявить возвращаемый тип
константным. Например, если объявить, что операция Vector::operator+() возвращает тип 
const Vector, то оператор 1 остается допустимым, а операторы 2 и 3 — нет.
	Использование указателей на объекты класса.
 Указатели на объекты не создают новые объекты, они просто указывают на существующие 
объекты. Поэтому они не требуют применения операции new для выделения дополнительной 
памяти.
 А здесь выделяется память для хранения не строки, а объекта — т.е. для указателя str,
который хранит адрес строки, и для члена lеп. (При этом для члена num_strings память
не выделяется, поскольку он является статическим и хранится отдельно от объектов.): */
String * favorite = new String(sayings[choice]); /* Здесь указатель favorite 
обеспечивает доступ к безымянному объекту, созданному операцией new. Этот синтаксис 
означает инициализацию нового объекта String с помощью объекта sayings[choice].
При этом вызывается конструктор копирования, поскольку тип аргумента для конструктора 
копирования (const String &) соответствует инициализирующему значению (sayings[choice]).
Конструктор, выделяет память для хранения строки и заносит адрес строки в указатель str. 
А после завершения работы с объектом программа использует операцию delete для его 
удаления. Объект является одиночным, поэтому в программе применяется операция delete 
без скобок — при этом освобождается только память, которая использовалась для хранения 
указателя str и члена lеп. Память, выделенная для хранения строки, на которую указывает 
str, при этом не освобождается, эту завершающую задачу выполняет деструктор. */
class Act {...};
...
Act nice;				// внешний (статический) объект
...
int main()
{
	Act *pt = new Act;	// динамический объект
	{
		Act up;			// автоматический объект
		...
	}			// Вызывается деструктор для автоматического объекта
	delete pt;	// Вызывается деструктор для динамического объекта
	...
}				// Вызывается деструктор для статического объекта
/*	Деструкторы вызываются в перечисленных ниже ситуациях:
• Если объект является автоматической переменной, то деструктор объекта 
вызывается, когда программа завершает выполнение блока, в котором 
определен этот объект.
• Если объект является статической переменной (внешней, статической, внешней
статической или из пространства имен), то его деструктор вызывается при 
завершении программы.
• Если объект является динамической переменной, т.е. создается операцией new, 
его деструктор вызывается только при явном выполнении операции delete для 
данного объекта.
	Относительно использования указателей на объекты должны учитываться 
определенные моменты: */
//	• Указатель на объект объявляется как обычно:
String * glamour;
//	• Указатель можно инициализировать адресом существующего объекта:
String * first = &sayings[0];
/*	• Указатель можно инициализировать с помощью операции new; при этом 
создается новый объект: */
String * favorite = new String (sayings[choice]);
/*	• Использование операции new с классом вызывает соответствующий 
конструктор класса для инициализации вновь созданного объекта: */
String * gleep = new String;						 // вызов конструктора по умолчанию
String * glop  = new String ("ox ox ox");		 // вызов конструктора String (const char *)
String * favorite = new String(sayings[choice]); // вызов конструктора String(const String &)
//	• Для доступа к методу класса через указатель применяется операция -> :
if (sayings[i].length() < shortest->length())
//	• Для получения объекта к указателю применяется операция разыменования (*) :
if (sayings[i] < *first) // сравнение значений объектов
	first = &sayings[i]; // присваивание адреса объекта
	
//	new с размещением.
// placenew1.cpp  -- операции new, new с размещением, но без delete
#include <iostream>
#include <string>
#include <new>
using namespace std;
const int BUF = 512;

class JustTesting
{
private:
    string words;
    int number;
public:
    JustTesting(const string & s = "Just Testing", int n = 0) 
    {words = s; number = n; cout << words << " constructed\n"; }
    ~JustTesting() { cout << words << " destroyed\n";}
    void Show() const { cout << words << ", " << number << endl;}
};
int main()
{
    char * buffer = new char[BUF];       // получение блока памяти
    JustTesting *pc1, *pc2;
    pc1 = new (buffer) JustTesting;      // размещение объекта в buffer
    pc2 = new JustTesting("Heap1", 20);  // размещение объекта в куче
    cout << "Memory block addresses:\n"   << "buffer: "
         << (void *) buffer << "\theap: " << pc2 << endl; // вывод адресов памяти
    cout << "Memory contents:\n";        // вывод содержимого памяти
    cout << pc1 << ": ";
    pc1->Show();
    cout << pc2 << ": ";
    pc2->Show();

    JustTesting *pc3, *pc4;
    pc3 = new (buffer) JustTesting("Bad Idea", 6);
    pc4 = new JustTesting("Heap2", 10);
    cout << "Memory contents:\n";        // вывод содержимого памяти
    cout << pc3 << ": ";
    pc3->Show();
    cout << pc4 << ": ";
    pc4->Show();
    
    delete pc2;                          // освобождение Heap1
    delete pc4;                          // освобождение Неар2
    delete[] buffer;                     // освобождение buffer
    cout << "Done\n";
    // std::cin.get();
    return 0;
}
/* От вас зависит управление позициями памяти в буфере, который заполняется операцией 
new с размещением. Для использования двух различных позиций необходимо указать два 
различных адреса внутри буфера, которые гарантируют, что эти позиции не перекрываются: */
pc1 = new (buffer) JustTesting;
// Фиксация ячейки, с которой работает new с размещением:
pc3 = new (buffer + sizeof (JustTesting)) JustTesting("Better Idea", 6);
/* Указатель рс3 смещен относительно pc1 на размер объекта JustTesting.
 Если применять операцию new для хранения объектов, то для них нужно организовать 
и вызов деструкторов. Использование операции delete[] для buffer не приводит к вызову 
деструкторов для объектов, созданных с помощью new с размещением. Для объектов, 
созданных в куче, это можно сделать следующим образом: */
delete pc2; // удаление объекта, на который указывает рс2
// Однако показанные ниже операторы использовать нельзя:
delete pc1; // удаление объекта, на который указывает pc1? НЕЛЬЗЯ!
delete pc3; // удаление объекта, на который указывает pc2? НЕЛЬЗЯ!
/* Операция delete работает согласованно с операцией new, но не с new с размещением. 
Например, указатель pc3 не получает адрес, возвращаемый операцией new, поэтому delete 
pcЗ приводит к ошибке времени выполнения. А указатель pc1 имеет то же самое числовое 
значение, что и buffer, но buffer инициализирован операцией new[], поэтому он должен 
быть освобожден операцией delete[], а не delete. Даже если buffer был инициализирован 
с помощью new вместо new[], операция delete pc1 освободит buffer, но не pc1. Ведь 
система new/delete знает о размещении 256-байтного блока, но ничего не знает о действиях 
new с размещением в этом блоке. Обратите внимание на то, что программа освобождает буфер: */
delete[] buffer; // освобождение buffer
/* Оператор delete[] buffer; удаляет весь блок памяти, выделенный операцией new. Но 
он не вызывает деструкторы ни для одного из объектов, созданных в блоке операцией new 
с размещением. Следует явно вызывать деструктор для каждого объекта, созданного операцией 
new с размещением. Поскольку существуют указатели на объекты, можно воспользоваться ими: */
pc3->~JustTesting(); // уничтожение объекта, на который указывает pc3
pc1->~JustTesting(); // уничтожение объекта, на который указывает pc1
/* Важно соблюдать правильный порядок удаления. Объекты, созданные операцией new с 
размещением, должны удаляться в порядке, обратном порядку их создания. Причина в том,
что более поздний объект может зависеть от более ранних. А буфер, используемый для 
хранения объектов, можно освободить только после уничтожения всех содержащихся в нем 
объектов.
	Технические приемы.
  Перегрузка операции << */
ostream & operator<<(ostream & os, const имя_класса & obj)
{
os <<... ; // отображение содержимого объекта
return os;
}
/* Если класс предоставляет общедоступные методы, которые возвращают нужное 
содержимое, то эти методы можно задействовать в функции операции и обойтись без 
дружественного статуса.
  Функции преобразования. */
имя_класса(имя_типа value);
/* Здесь имя_класса представляет собой имя класса, а имя_типа — имя типа, 
который нужно преобразовать. Для преобразования типа класса в какой-то другой 
тип нужно создать функцию-член класса с таким прототипом: */
operator имя_типа();
/* Хотя данная функция не имеет объявленного типа возврата, она должна возвращать 
значение требуемого типа. При объявлении конструктора можно добавить ключевое слово 
explicit, чтобы его нельзя было задействовать для неявных преобразование.
  Классы, в конструкторах которых используется операция new.
• К любому члену класса, который указывает на память, выделенную операцией
new, необходимо применить операцию delete в деструкторе класса, чтобы 
освободить занимаемую память.
• Если деструктор освобождает память операцией delete для указателя, который 
является членом класса, то каждый конструктор для этого класса должен 
инициализировать такой указатель — с помощью либо операции new, либо 
присваивания нулевого указателя.
• Конструкторы должны содержать либо new[], либо new, но не оба варианта.
Деструктор должен использовать delete[], если в конструкторах применяется
new[], и delete — если new.
• Конструктор копирования должен выделять новую память, а не копировать 
указатель на существующую память. Это дает программе возможность инициализировать 
объект класса другим объектом. Конструктор, как правило, должен иметь следующий 
прототип: */
имяКлассa(const имяКласса &);
/* • Необходимо определить функцию-член класса, которая перегружает операцию
присваивания и имеет показанный ниже прототип (здесь c_pointer является членом 
класса имя_класса и имеет тип указателя на имя_типа). В следующем примере 
предполагается, что конструктор инициализирует переменную c_pointer с помощью 
операции new[]: */
имя_класса & имя_класса::operator=(const имя_класса & cn)
{
	if (this == & cn_)
		return *this;	// если присваивание самому себе, то все готово
	delete[] c_pointer;
// Определение количества единиц имя_типа, которые нужно скопировать:
	c_pointer = new имя_типа[size];
// Копирование данных, на которые указывает cn.c_pointer, в позицию, указанную c_pointer:
	...
	return *this;
}
/*	Моделирование очереди.
  Класс Queue.
 Атрибуты, которыми должен обладать требуемый вид очереди:
• очередь содержит упорядоченную последовательность элементов;
• количество элементов, которые может содержать очередь, ограничено;
• должна быть возможность создания пустой очереди;
• должна быть возможность проверки, является ли очередь пустой;
• должна быть возможность проверки, является ли очередь заполненной;
• должна быть возможность добавления элемента в конец очереди;
• должна быть возможность удаления элемента из начала очереди;
• необходима возможность определения количества элементов в очереди.
 Интерфейс. */
class Queue
{
	enum {Q_SIZE = 10};
private:
// Закрытое представление будет разработано позже
public:
	Queue(int qs = Q_SIZE); // создание очереди с размером qs по умолчанию,
// но это ограничение может быть изменено с помощью аргумента при явной инициализации.
	~Queue();
	bool isempty() const;			// проверка на пустоту
	bool isfull () const;			// проверка на заполнение
	int  queuecount() const;			// определения количества элементов
	bool enqueue(const Item &item);	// добавление элемента в конец
	bool dequeue(Item &item);		// удаление элемента из начала
};
/* При использовании очереди для определения Item можно применять конструкцию typedef.
 Реализация.
Наиболее разумным подходом, соответствующим всем требованиям очереди, является связный 
список. Связный список состоит из последовательности узлов. Каждый узел содержит 
информацию, которую нужно хранить в списке, а также указатель на следующий узел в 
списке. Для очереди в данном примере каждая часть данных имеет тип Item, и для 
представления узла можно воспользоваться следующей структурой: */
struct Node
{
	Item item;				// данные, хранящиеся в узле
	struct Node * next;		// указатель на следующий узел
}; /* называется односвязным списком, поскольку каждый узел содержит единственную 
ссылку, или указатель, на другой узел. Если знать адрес первого узла, то по указателям 
можно пройти по всем последующим узлам в списке. Обычно в указатель внутри последнего 
узла заносится значение NULL(либо 0), означающее, что узлов больше нет. В С++11 лучше 
использовать новое ключевое слово nullptr.
 Для указания на начало списка можно использовать член данных класса Queue. Этой
информации достаточно, т.к. по цепочке узлов можно добраться до любого из них.
Но поскольку новый элемент всегда добавляется в конец очереди, удобно иметь также
член данных, указывающий на последний узел. */
class Queue
private:
// Определения области действия класса
// Node — это вложенное определение структуры, локальное для данного класса
	struct Node { Item item; struct Node * next;};
	enum {Q_SIZE = 10};
// Закрытые члены класса:
	Node * front;		// указатель на начало Queue
	Node * rear;		// указатель на конец Queue
	int items;			// текущее количество элементов в Queue
	const int qsize;	// максимальное количество элементов в Queue
public:
//...
}
/* Поскольку объявление Node расположено внутри класса Queue, его область действия 
ограничена этим классом. Это значит, что тип Node можно применять для объявления 
членов класса и в качестве имени типа в методах класса, но использование данного 
типа ограничено содержащим его классом. Структура, класс или перечисление, объявленное 
внутри объявления класса, называется вложенным в класс. Областью его действия является 
класс. Такое объявление не создает объект данных, а задает тип, который можно 
использовать внутри класса. Если объявление размещено в закрытом разделе класса, то 
объявленный тип можно применять только внутри класса. Если объявление размещено в 
открытом разделе, то объявленный тип можно также использовать вне класса с помощью 
операции разрешения контекста. Если, например, тип Node объявить в открытом разделе 
класса Queue, то можно объявлять переменные типа Queue::Node за пределами класса Queue.
 Методы класса.
Конструктор класса должен предоставлять значения для членов класса. */
Queue::Queue (int qs)
{
	front = rear = NULL;
	items = 0;
	qsize = qs; // неприемлемо!
}
/* qsize — константная переменная, поэтому ее можно инициализировать, но ей нельзя 
присвоить некоторое значение. При вызове конструктора Queue (int qs) программа 
сначала выделяет память для четырех переменных-членов. Затем программа начинает 
выполнять код в скобках и заносит значения в выделенную память с помощью обычного 
присваивания. Значит, если нужно инициализировать константный член данных, то это 
необходимо сделать, когда объект уже создан, но до того, как выполнение программы 
дойдет до тела конструктора. Для этого в C++ предусмотрен специальный синтаксис —
список инициализаторов членов. Если член данных имеет имя mdata и его нужно 
инициализировать значением val, то инициализатор имеет форму mdata(val). */
Queue::Queue(int qs) : qsize(qs) // инициализация qsize значением qs
{
	front = rear = NULL;
	items = 0;
}
/* Начальное значение может быть константой или аргументом из списка аргументов 
конструктора. Данный прием позволяет не только инициализировать константы: */
Queue::Queue(int qs) : qsize(qs), front(NULL), rear(NULL), items(0)
{
}
/* Такой список инициализаторов может применяться только в конструкторах. Этот 
синтаксис необходимо использовать для константных членов класса const. Кроме того, 
его следует применять для членов класса, которые объявлены как ссылки: */
class Agency {...};
class Agent
{
private:
	Agency & belong; // для инициализации нужен список инициализаторов
	...
};
Agent::Agent(Agency & a) : belong(a) {...}
/* Это связано с тем, что ссылки, как и константные данные, могут быть 
инициализированы только во время создания. Для простых членов данных вроде front 
и items нет особой разницы, использовать для них список инициализаторов членов или 
присваивание в теле функции.
  Синтаксис списка инициализаторов членов
Если, например, Classy — это класс, a mem1, mem2 и mem3 — данные-члены этого класса,
то конструктор класса может использовать для инициализации данных-членов следующий
синтаксис: */
Classy::Classy(int n, int m) : mem1(n), mem2(0), mem3(n*m + 2)
{
	...
}
/* Эти инициализации производятся во время создания объекта и до того, как
выполняется код в скобках.
• Такая форма может применяться только с конструкторами.
• Эту форму необходимо (по крайней мере, до С++11) использовать для инициализации
нестатических константных членов данных.
• Эту форму необходимо применять для инициализации ссылочных данных-членов.
 Данные-члены инициализируются в том порядке, в котором они находятся в объявлении
класса, а не в порядке перечисления инициализаторов. Списки инициализаторов членов 
нельзя использовать в методах класса, отличных от конструкторов.
Форма с круглыми скобками, применяемая в списке инициализаторов членов, 
может применяться и при обычной инициализации. */
int games = 162;
double talk = 2.71828;
// можно заменить кодом
int games(162);
double talk(2.71828);
// Стандарт С++11 позволяет делать то, что выглядит вполне естественным:
class Classy
{
	int mem1 = 10;		 // инициализация внутри класса
	const int mem2 = 20; // инициализация внутри класса
};
// Такой код эквивалентен использованию списка инициализации членов в конструкторах:
Classy::Classy() : mem1(10), mem2(20) {...}
/* Члены mem1 и mem2 инициализируются значениями 10 и 20 соответственно —
если только не применяется конструктор со списком инициализаторов членов. В этом 
случае приведенный список переопределяет такие стандартные инициализации: */
Classy::Classy(int n) : mem1(n) {...}
/* В такой ситуации конструктор использует значение п для инициализации mem1, a mem2 так
и останется равным 20.
 Добавление элемента в конец очереди. Один из подходов: */
bool Queue::enqueue(const Item & item)
{
	if (isfull())			// если очередь уже полна, завершить программу
		return false;
	Node * add = new Node;	// создание узла
// При неудачном выполнении операция new генерирует исключение std::bad_alloc
	add->item = item;		// занесение значения в часть данных узла
	add->next = NULL;		// занесение в указатель на следующий узел NULL или nullptr
	items++;					// увеличить счетчик элементов (items) на единицу
	if (front == NULL)		// если очередь пуста,
		front = add;		// элемент помещается в начало
	else
		rear->next = add;	// иначе он помещается в конец
	/* Присоединить узел в конец очереди. Этот процесс состоит из двух частей.
1. Созданный узел привязывается к другим узлам в списке. Для этого в указатель next 
предыдущего конечного узла заносится ссылка на новый конечный узел.
2. В указатель-член rear объекта Queue заносится ссылка на новый узел, чтобы иметь 
доступ непосредственно к последнему узлу. Если очередь пуста, то ссылку на новый 
узел необходимо поместить и в указатель front. (Если в очереди всего один узел, 
то он является и начальным, и конечным.) */			
	rear = add;				// указатель конца указывает на новый узел
	return true;
}
// Удаление элемента из начала очереди также выполняется за несколько шагов:
bool Queue::dequeue(Item & item)
{
	if (front == NULL)		// если очередь уже пуста, завершить программу
		return false;
	item = front->item;		// часть данных узла front(первый элемент из очереди) заносится в item
	items--;					// уменьшить счетчик элементов (items) на единицу
	Node * temp = front;		// сохранение местоположения первого элемента для последующего удаления
	front = front->next;		/* Удалить узел из очереди: сдвиг указателя начала на следующий элемент.
						В указатель-член front объекта Queue заносится указатель на следующий узел,
						адрес которого находится в front->next. */
	delete temp;			// удаление предыдущего первого элемента
	if (items == 0)			// если список теперь пуст, то занести в rear значение NULL. (Начальный 
		rear = NULL;		// указатель уже равен NULL после установки front->next ).
	return true;
}
/* При добавлении объектов в очередь выполняется операция new для создания новых узлов.
Метод dequeue() производит очистку при удалении узлов, но нет никакой гарантии, что
после завершения работы очередь будет пустой. Поэтому для данного класса нужен явный 
деструктор — такой, который удалит все оставшиеся узлы. */
Queue::~Queue()	// явный деструктор поочередно удаляет все узлы, начиная с начала списка
{
	Node * temp;
	while (front != NULL)	 // пока очередь не пуста
	{
		temp  = front;		 // сохранение адреса начального элемента
		front = front->next; // переустановка указателя на следующий элемент
		delete temp;		 // удаление предыдущего начального элемента
	}
}
/* Почленное копирование объекта Queue порождает новый объект, который указывает на 
начало и конец исходного связного списка. Значит, добавление элемента в копию объекта 
Queue изменит общий связный список. Это само по себе плохо. Но еще хуже то, что 
конечный указатель обновляется только в копии, т.е. с точки зрения исходного объекта 
список существенно искажается. Очевидно, что для клонирования или копирования очередей 
нужны конструктор копирования и конструктор присваивания, которые выполняют глубокое 
копирование.
 Могут пригодиться операции разделения очереди, как это иногда бывает в супермаркетах 
при открытии дополнительной кассы. Аналогично может возникнуть необходимость в 
объединении двух очередей в одну или в усечении очереди.
 Существует хитрый способ избежать дополнительной работы и в то же время защититься 
от будущих аварийных ситуаций в работе программы — определение необходимых методов 
как фиктивных закрытых методов: */
class Queue
{
private:
	Queue(const Queue & q) : qsize(0) {}	 // упреждающее определение
	Queue & operator=(const Queue & q) { return *this; }
	...
}; /* Этот код переопределяет стандартные определения методов, которые в противном 
случае генерируются автоматически. Поскольку это закрытые методы, они не могут 
вызываться внешним кодом. То есть если nip и tuck являются объектами Queue, то 
компилятор не разрешит следующие операторы: */
Queue snick(nip);	// нельзя
tuck = nip;			// нельзя
/* Теперь Вы не столкнетесь с загадочными проблемами во время работы программы,
а получите легко отслеживаемую ошибку компилятора, гласящую, что данные методы
недоступны. Этот прием полезен и при определении класса, элементы которого 
нельзя копировать.
	Класс Customer.
 Для моделирования необходимо только два свойства: момент постановки клиента в 
очередь и время, необходимое для выполнения клиентской транзакции. При появлении 
в процессе моделирования нового клиента программа должна создать новый объект 
клиента, сохранив в нем время появления клиента и сгенерированное случайным 
образом время транзакции. Когда клиент достигает начала очереди, программа 
должна отметить время и вычесть из него время присоединения к очереди,чтобы 
получить время ожидания клиента. */
class Customer
{
private:
	long arrive;		// момент появления клиента
	int processtime;	// время обслуживания клиента
public:
	Customer() { arrive = processtime = 0; }	  // Конструктор по умолчанию создает нулевой клиент. 
	void set(long when);
	long when() const { return arrive; }
	int ptime() const { return processtime; }
};
void Customer::set(long when) /* устанавливает для клиента переданное в качестве аргумента 
	время прибытия и случайным образом выбирает значение от 1 до 3 для времени обслуживания. */
{
	processtime = std::rand() % 3 + 1;
	arrive = when;
}
/*	Моделирование работы банкомата.
 Программа должна запрашивать у пользователя три параметра: максимальный
размер очереди, количество часов, которые моделируются программой, и среднее 
количество клиентов в час. Затем программа должна запустить цикл, каждое 
выполнение которого соответствует одной минуте моделируемого времени.
Во время каждого такого минутного цикла должны выполняться перечисленные ниже шаги:
1. Определить, появился ли новый клиент. Если да, то добавить клиента в очередь при условии, 
что для него есть место; иначе отклонить его.
2. Если никто не обслуживается, выбрать из очереди первого человека. Определить
время ожидания его обслуживания и занести в счетчик wait_time необходимое ему время обслуживания.
3. Если в данный момент обслуживается клиент, уменьшить счетчик waittime на одну минуту.
4 Вести подсчет различных параметров: количество обслуженных клиентов, количество 
отвергнутых клиентов, общее время, проведенное в ожидании в очереди, и общую длину очереди.
 После завершения цикла моделирования программа должна выдать статистический отчет. Для 
 определения, появился ли клиент во время минутного цикла, в программе используется функция: */
bool newcustomer(double x)
{
	return (std::rand() * x / RAND_MAX < 1);
}
/* Значение RAND_MAX определено в файле cstdlib и представляет собой наибольшее значение, 
которое может возвращать функция rand ()(наименьшее равно 0). Предположим, что среднее 
время х между появлениями клиентов равно 6. Тогда значение rand() * х / RAND_MAX попадает
куда-то в интервал от 0 до 6. В частности, оно будет меньше 1 в среднем одну шестую
часть времени. Данная функция может выдать двух клиентов с промежутком в одну минуту, 
а может и с интервалом 20 минут. Такое нерегулярное поведение как раз и отличает реальные 
процессы от хронологически точных поступлений клиентов по одному каждые 6 минут.
Данный метод не сможет работать, если среднее время между появлением клиентов меньше одной 
минуты, но наше моделирование и не предназначено для работы в таком напряженном режиме. 
Однако если понадобится эмулировать такую ситуацию, можно применить более подходящее 
временное разрешение — например, считать, что каждый цикл длится 10 секунд.
