/*	Исходную программу можно разбить на три части:
• заголовочный файл, содержащий объявления структур и прототипы функций,
которые используют эти структуры;
• файл исходного кода, содержащий код функций, которые работают со структурами;
• файл исходного кода, содержащий код, который вызывает функции работы со
структурами.
	В заголовочных файлах обычно содержится следующее:
• прототипы функций;
• символические константы, определенные с использованием #define или const;
• объявления структур;
• объявления классов;
• объявления шаблонов;
• встроенные функции.
	Фрагмент кода обеспечивает обработку операторов, находящихся между 
директивами #if ndef и #endif, только в случае, если имя coordin_h_ не 
было определено ранее с помощью директивы препроцессора #defіnе: */
#ifndef COORDIN_H_
#define COORDIN_H_
// здесь размещается содержимое включаемого файла
#endif
/* Если затем компилятор обнаруживает второе включение сооrdin.h в том же 
самом файле, он замечает, что имя coordin_h_ уже определено, и переходит к 
строке, следующей после #endif. Данный прием не предотвращает повторного 
включения файла. Вместо этого он заставляет компилятор игнорировать содержимое 
всех включений кроме первого.
 В стандарте C++ вместо термина файл используется термин единица трансляции, 
чтобы сохранить более высокую степень обобщенности; файловая модель —
это не единственный способ организации информации в компьютере.
	Продолжительность хранения, область видимости и компоновка.
• Автоматическая продолжительность хранения - они создаются, когда выполнение 
программы входит в функцию или блок, где эти переменные определены. После 
выхода из блока или функции используемая переменными память освобождается.
Бывают: автоматические и регистровые.
• Статическая продолжительность хранения. Переменные, объявленные за 
пределами определения функции либо с использованием ключевого слова static,
имеют статическую продолжительность хранения. Они существуют в течение
всего времени выполнения программы. Бывают: Статические без связывания, с 
с внешним и внутренним связыванием.
• Потоковая продолжительность хранения (C++11). Переменные, объявленные с 
ключевым словом threadlocal, хранятся на протяжении времени существования 
содержащего их потока.
• Динамическая продолжительность хранения. Память, выделяемая операцией
new, сохраняется до тех пор, пока она не будет освобождена с помощью 
операции delete или до завершения программы, смотря какое из событий наступит
раньше. Эта память имеет динамическую продолжительность хранения и часто
называется свободным хранилищем или кучей (heap).
	Стек.
	Стек применяется потому, что новые данные размещаются, образно говоря,
поверх старых данных (т.е. в смежных, а не в тех же самых ячейках памяти), 
а затем удаляются из стека, после того как программа завершит работу с ними.
 Программа отслеживает состояние стека с помощью двух указателей. Один 
указывает на базу стека, с которой начинается выделенная область памяти, 
а другой — на вершину стека, которая представляет собой следующую ячейку 
свободной памяти. Когда происходит вызов функции, ее автоматические 
переменные добавляются в стек, а указатель вершины устанавливается на 
свободную ячейку памяти, следующую за только что размещенными переменными. 
После завершения функции указатель вершины снова принимает значение, 
которое он имел до вызова функции. В результате эффективно освобождается 
память, которая использовалась для хранения новых переменных. Стек построен 
по принципу LIFO (last-in, first-out — последним пришел, первым обслужен). 
Это означает, что переменная, которая попала в стек последней, удаляется 
из него первой.
	Переменные со статической продолжительностью хранения.
	Компилятор просто резервирует фиксированный блок памяти для хранения 
всех статических переменных, и эти переменные доступны программе на 
протяжении всего времени ее выполнения. Более того, если статическая
переменная не инициализирована явно, компилятор устанавливает ее в 0. 
Элементы статических массивов и структур устанавливаются в 0 по умолчанию.*/
int global = 1000;	// статическая продолжительность, внешнее связывание
static int one_file = 50; // статическая продолжительность, внутреннее связывание
int main ()
{
void functl(int n)
...
{
static int count = 0; // статическая продолжительность, нет связывания
}
/* Поскольку переменная global имеет внешнее связывание, она также может 
применяться в других файлах, которые являются частью программы.
 Все биты неинициализированной статической переменной устанавливаются в 0. 
Такая переменная называется инициализированной нулями.
 При использовании в локальном объявлении для указания статической переменной 
без связывания static отражает вид продолжительности хранения. Когда ключевое 
слово static применяется с объявлением вне блока, оно отражает внутреннее 
связывание; переменная уже имеет статическую продолжительность хранения. 
Это можно назвать перегрузкой ключевого слова, причем более точный смысл 
определяется контекстом.
Статические переменные могут быть инициализированными нулями, они могут
быть подвергнуты инициализации константным выражением, и они могут быть 
подвергнуты динамической инициализации. */
#include <cmath>
int x;	// инициализация нулями
int у = 5; // инициализация константным выражением
long z=13*13; // инициализация константным выражением
const double pi = 4.0 *atan(1.O); // динамическая инициализация

/*	Ключевое слово constexpr, добавленное в C++11, перед функцией означает, 
что если значения параметров возможно посчитать на этапе компиляции, то 
возвращаемое значение также должно посчитаться на этапе компиляции. Если 
значение хотя бы одного параметра будет неизвестно на этапе компиляции, то 
функция будет запущена в runtime (а не будет выведена ошибка компиляции).
constexpr-функция:*/ constexpr возвращаемое_значение имя_функции (параметры)
/*constexpr-переменная: */ constexpr тип = expression;
int sum (int a, int b)
{
	return a + b;
}

constexpr int new_sum (int a, int b)
{
	return a + b;
}

void func()
{
	constexpr int a1 = new_sum (5, 12); // ОК: constexpr-переменная
	constexpr int a2 = sum (5, 12); // ошибка: функция sum не является constexp-выражением
	int a3 = new_sum (5, 12); // ОК: функция будет вызвана на этапе компиляции
	int a4 = sum (5, 12); // ОК
}
/* constexpr-переменная является константой (const), но константа не 
является constexpr-переменной.
 В случае «утери» constexpr-спецификатора переменной вернуть обратно его 
уже не получится, даже если значение может посчитаться на этапе компиляции. 
constexpr-спецификатор нельзя добавить с помощью const_cast, так как constexpr 
не является cv-спецификатором (это const и volatile). Такой код не заработает: */
constexpr int inc (int a)
{
	return a + 1;
}

void func()
{
	int a = inc (3);
	constexpr int b = inc (a); // ошибка: a не является constexpr-выражением, 
	// из-за чего возвращаемое значение не имеет спецификатор constexpr
}
/* Параметры функций не могут быть constexpr. То есть не получится создать 
исключительно constexpr-функцию, которая может работать только на этапе компиляции.
Также constexpr-функции могут работать с классами.
	Правило одного определения:
	Гласит, что для каждой переменной должно существовать только одно определение. 
Два вида объявления переменных. Первый вид называется определяющим объявлением 
или просто определением. Определение приводит к выделению памяти для переменной. 
Второй вид называется ссылочным объявлением или просто объявлением. Объявление 
не приводит к выделению памяти, поскольку ссылается на переменную, которая уже 
существует. Ссылочное объявление использует ключевое слово extern и не 
предоставляет возможности инициализации. В противном случае объявление является 
определением и приводит к выделению пространства для хранения: */
double up; // определение, up равно О
extern int blem; // переменная blem определена в другом месте
extern char gr = 'z'; // определение, поскольку присутствует инициализация
/* Если внешняя переменная используется в нескольких файлах, только один из них
может содержать определение этой переменной (согласно правилу одного 
определения). Но во всех прочих файлах, где эта переменная используется, 
она должна быть объявлена с указанием ключевого слова extern: */
// fileOl.cpp
extern int cats = 20;// определение, поскольку присутствует инициализация
int dogs = 22; // тоже определение
int fleas; // и это определение
// file02.cpp
// используются cats и dogs из fileOl.cpp
extern int cats; // это не определения, поскольку в них указано
extern int dogs; // ключевое слово extern и отсутствует инициализация
// file98.cpp
// используются cats, dogs и fleas из fileOl.cpp
extern int cats;
extern int dogs;
extern int fleas;
/* В этом случае во всех файлах используются переменные cats и dogs, 
определенные в fileOl.cpp. Однако в file02.cpp переменная fleas не 
объявляется повторно, поэтому доступ к ней невозможен. Ключевое слово 
extern в fileOl.cpp в действительности не нужно, поскольку и без него 
эффект будет таким же. Хотя в программе могут присутствовать различные 
переменные с одинаковыми именами, каждая версия может иметь только 
одно определение.
	Выбор между глобальными и локальными переменными.
	Чем эффективнее программа изолирует данные от нежелательного доступа, 
тем лучше будет сохраняться их целостность. В большинстве случаев следует 
пользоваться локальными переменными и передавать данные функциям только 
по мере необходимости, а не делать данные открытыми за счет использования 
глобальных переменных. Глобальные переменные имеют свою область применения. 
Если имеется блок данных, который должен использоваться несколькими 
функциями, например, такой как массив с названиями месяцев или список 
атомных весов химических элементов. */
const char *const months [12] = 
{
"January", "February", "March", "April", "May",
"June", "July", "August", "September", "October",
"November", "December"
};
/* Первое ключевое слово const защищает от изменений строки, а второе 
слово const гарантирует, что каждый указатель в массиве будет постоянно 
указывать на ту же самую строку, на которую он указывал изначально.
	Статическая продолжительность хранения, внутреннее связывание.
Применение модификатора static к переменной с областью видимости файла
обеспечивает для нее внутреннее связывание. Переменная с внутренним 
связыванием является локальной для файла, который ее содержит. При этом 
обычная внешняя переменная обладает внешним связыванием, что означает 
возможность ее применения в различных файлах. */
// файл 1
int errors = 20; // внешнее объявление
// файл 2
int errors = 5; // ??известна только в file2??
void froobish ()
{
cout << errors; // ошибка, нарушается правило одного определения!
...
// Так правильно:
// файл 2
static int errors =5; // известна только файлу 2
void froobish ()
{
cout << errors; // использует переменную errors, определенную в файле 2
...
/* В многофайловой программе внешнюю переменную можно определять в 
одном и только одном файле. Все остальные файлы, использующие эту 
переменную, должны содержать ее объявление с ключевым словом extern.
	Статическая продолжительность хранения, отсутствие связывания.
Такая переменная создается за счет применения модификатора static к
переменной, определенной внутри блока. Несмотря на видимость 
переменной в пределах блока, она существует даже тогда, когда блок 
неактивен. Таким образом, статическая локальная переменная может 
сохранять свое значение между вызовами функции. Если статическая 
локальная переменная инициализируется, это делается только один раз 
при запуске программы. Последующие вызовы функции не будут приводить к
повторной инициализации переменной, как это происходит в случае 
автоматических переменных. */
void strcount(const char *str)
{
using namespace std;
static int total = 0; // статическая локальная переменная: при следующем
// входе в эту функцию не будет инициализирована нулём, а примет 
// релультат, полученный при предыдущем входе в эту функцию
int count = 0; // автоматическая локальная переменная, всегда 
// инициализируется нулём
cout << "V" << str <<"\" contains ";
while (*str++) // переход к концу строки
count++;
total += count; // здесь статическая переменная обновляется
cout << count << " characters\n";
cout << total << " characters total\n";
}
/*	Cпецификаторs класса храпения и сѵ-квалификаторы. */
• auto // (исключен из спецификаторов в С++11)
• register
• static
• extern
• thread_local // (добавлен в С++11)
• mutable
/* До появления С++11 ключевое слово auto могло использоваться в 
объявлении для документирования того факта, что переменная является 
автоматической. (В С++11 ключевое слово auto применяется для 
автоматического выведения типа.) Ключевое слово register используется 
в объявлении для указания регистрового класса хранения, который в 
С++11 представляет собой всего лишь явный способ сообщения о том, что 
переменная является автоматической. Ключевое слово static, когда 
применяется в объявлении с областью видимости файла, задает внутреннее
связывание. При использовании в локальном объявлении оно определяет 
статический класс хранения для локальной переменной. Ключевое слово 
extern указывает на ссылочное объявление — т.е., что объявление 
ссылается на переменную, которая определена где-то в другом месте. 
Ключевое слово thread_local отражает, что продолжительность хранения 
переменной является продолжительностью существования содержащего ее 
потока. Переменная thread_local соотносится с потоком во многом так же, 
как обычная статическая переменная — со всей программой.
 mutable - с его помощью можно указать, что отдельный член структуры 
(или класса) может быть изменен, даже если переменная типа структуры 
(или класса) объявлена со спецификатором const: */
struct data
{
char name[30];
mutable int accesses;
};
const data veep = { "Claybourne Clodde", 0, ... };
strcpy(veep.name, "Joye Joux"); // не разрешено
veep.accesses++; // разрешено
/* Квалификатор const структуры ѵеер предотвращает изменение ее 
элементов в программе, но спецификатор mutable, указанный для члена 
accesses, снимает с него это ограничение.
	Сѵ-квалификаторы:
• const
• volatile
 volatile указывает, что значение в ячейке 
памяти может быть изменено, даже если в коде программы нет ничего такого, 
что может модифицировать ее содержимое. 
const указывает, что переменная после инициализации не может быть 
оптимизирована программой. Глобальная переменная со спецификатором 
const по умолчанию имеет внутреннее связывание. const обрабатывается 
так, будто в нем использован спецификатор static: */
const int fingers = 10; // то же самое, что и static const int fingers = 10;
/* Внутреннее связывание также означает, что каждый файл получает собственный
набор констант, а не разделяет их с другими файлами. Каждое определение 
является приватным для файла, который его содержит. Именно поэтому 
определения констант целесообразно поместить в заголовочный файл. Таким 
образом, если включить один и тот же заголовочный файл в два файла исходного 
кода, они оба получат один и тот же набор констант. Если по какой-либо 
причине необходимо, чтобы константа имела внешнее связывание, можно 
воспользоваться ключевым словом extern и переопределить устанавливаемое 
по умолчанию внутреннее связывание: */
extern const int states =50; // определение с внешним связыванием
/* При объявлении константы внутри функции или блока она получает область 
видимости блока.
	Функции и связывание.
	Язык C++, как и С, не позволяет объявлять одну функцию внутри другой, 
поэтому все функции автоматически получают статическую продолжительность 
хранения, т.е. существуют во время выполнения программы. По умолчанию функции 
имеют внешнее связывание, в том смысле, что могут разделяться между файлами. 
На самом деле в прототипе функции можно указать ключевое слово extern,
отразив, что эта функция определена в другом файле, но это не обязательно.
Можно также ограничить область видимости функции одним файлом, назначив для 
нее внутреннее связывание с помощью ключевого слова static. Это ключевое 
слово должно применяться к прототипу и к определению функции: */
static int private(double x) ;
static int private(double x)
{
}
/* Это также означает, что то же самое имя можно назначить какой-то другой 
функции в другом файле. Как и в случае с переменными, статическая функция 
переопределяет внешнее определение для файла, содержащего статическое 
объявление. Правило одного определения распространяется также на невстроенные 
функции. Однако каждый файл, использующий функцию, должен содержать прототип 
этой функции. Встроенные функции являются исключением из этого правила и 
позволяют помещать свои определения в заголовочный файл. Таким образом, 
каждый файл, который включает такой заголовочный файл, будет иметь 
определения встроенных функций. Однако язык C++ требует, чтобы все 
встроенные определения для конкретной функции были идентичными.
 Где компилятор C++ ищет функции?
Если прототип функции в данном файле указывает, что функция является 
статической, компилятор ищет ее определение только в этом файле. В противном 
случае компилятор (а также и компоновщик) просматривает все файлы программы. 
Если компилятор находит два определения, он выдает сообщение об ошибке, 
поскольку может существовать только одно определение внешней функции. Если 
компилятору не удается обнаружить ни одного определения этой функции, он 
переходит к поиску в библиотеках.
	Языковое связывание.
Для каждой отдельной функции компоновщику необходимо уникальное символическое 
имя. Для внутренних потребностей компилятор языка С может транслировать имя 
функции С, такое как spiff, в _spiff. Этот прием называется языковым 
связыванием С. Однако в C++ допускается наличие нескольких функций с одним 
и тем же именем, которые тоже должны транслироваться в разные символические 
имена. Таким образом, компилятор C++ инициирует процесс искажения или 
декорирования имен , позволяющий сгенерировать разные символические имена 
для перегруженных функций. Например, spiff(int) может быть преобразовано, 
скажем, в _spiff_i, a spiff(double, double) — в _spiff_d_d. Этот прием 
называется языковым связыванием C++. Если требуется использовать 
предварительно скомпилированную функцию из библиотеки С в программе на C++: */
spiff(22); // обращение к функции spiff(int) из библиотеки С
/* Гипотетическое символическое имя в библиотеке С выглядит как _spiff, 
однако для нашего воображаемого компоновщика соглашение, принятое в отношении 
поиска в C++, диктует поиск символического имени _spiff_i. Можно 
воспользоваться прототипом функции, которое указывает, какой протокол 
следует применять: */
extern "С" void spiff(int); // использовать для поиска имени протокол С
extern void spoff(int); // использовать для поиска имени протокол C++
extern "C++" void spaff(int); // использовать для поиска имени протокол C++

/*	Схемы хранения и динамическое выделение памяти.
В отличие от автоматической памяти, динамическая память не подчиняется 
схеме LIFO. Порядок выделения и освобождения памяти зависит от того, когда 
и как применяются операции new и delete. Как правило, компилятор использует 
три отдельных области памяти: одну для статических переменных (эта область 
может быть разбита дополнительно), одну для автоматических переменных и 
одну для динамической памяти. Несмотря на то что концепции схем хранения 
неприменимы к динамической памяти, они применимы к автоматическим и 
статическим переменным-указателям, используемым для отслеживания 
динамической памяти. */
float *p_fees = new float [20];
/* 80 байтов памяти (предполагая, что тип float занимает 4 байта), 
выделенных операцией new, остаются занятыми до тех пор, пока операция 
delete не освободит их. Однако указатель p_fees перестает существовать, 
когда выполнение программы покидает блок, содержащий его объявление. 
Если требуется, чтобы 80 байтов выделенной памяти стали доступными другой 
функции, необходимо передать или вернуть адрес этой памяти данной функции. 
С другой стороны, если сделать объявление указателя p_fees внешним, то он 
станет доступным всем функциям, которые находятся в файле после этого 
объявления. Используя следующий оператор во втором файле, можно сделать 
указатель доступным и в нем: */
extern float *p_fees;
/*	Инициализация с помощью операции new.
Если требуется создать и инициализировать хранилище для одного из встроенных
скалярных типов, таких как int или double, необходимо указать имя типа и 
инициализирующее значение, заключенное в круглых скобках: */
int *рі = new int (6) ; // *pi устанавливается в 6
double *pd = new double (99.99); // *pd устанавливается в 99.99
/* Синтаксис с круглыми скобками также может использоваться с классами, 
которые имеют подходящие конструкторы.
C++11 позволяет делать следующее: */
struct where {double x; double у; double z;};
where *one = new where {2.5, 5.3, 7.2}; // C++11
int *ar = new int [4] {2,4,6,7}; // C++11
/* В C++11 можно также применять инициализацию с помощью фигурных скобок для
переменных с одиночным значением: */
int *pin = new int {}; // *pi устанавливается в 6
double *pdo = new double {99.99}; // *pd устанавливается в 99.99
/*	Когда new дает сбой?
Может случиться так, что операция new не сможет найти запрошенный объем 
памяти. В настоящее время new генерирует исключение std::bad_alloc. 
	new: операции, функции и заменяющие функции.
Операции new и new[] обращаются к двум функциям: */
void *operator new(std::size_t); // используется new
void *operator new[](std::size_t); // используется new[]
/* Они называются функциями распределения и являются частью глобального 
пространства имен. Подобным же образом, существуют функции освобождения, 
вызываемые операциями delete и delete[]: */
void operator delete(void *) ;
void operator delete[](void *) ;
/* Они используют синтаксис перегрузки операций, рассматриваемый в главе 11.
Здесь std::size_t — это typedef для некоторых подходящих целочисленных 
типов. Базовый оператор, такой как: */
int *pi = new int;
// транслируются примерно в следующее:
int *pi = new (sizeof (int));
// А оператор:
int *pa = new int[40];
// транслируются в такую конструкцию:
int *pa = new (40 *sizeof(int));
/* Оператор с операцией new может также предоставлять инициализирующие 
значения, поэтому в общем случае использование new может сводиться не
только к вызову функции new().
Аналогично, оператор: */
delete pi;
// приводит к следующему вызову функции:
delete (pi) ;
/* В C++ эти функции называются заменяемыми. Это значит, что при наличии 
достаточного опыта и желания можно создать заменяющие функции для new и 
delete, подогнав их под специфические требования. Например, можно было
бы определить заменяющие функции с областью видимости класса и настроить 
их для удовлетворения потребностей в распределении конкретного класса. 
В коде операция new применялась бы как обычно, но вызывала бы заменяющую 
функцию new().
	Операция new с размещением.
Существует разновидность операции new, называемая операцией new с 
размещением, которая позволяет указывать адрес используемого блока.
Чтобы воспользоваться операцией new с размещением, сначала нужно включить
заголовочный файл new, который содержит прототип этой версии new. Затем 
операция new применяется с аргументом, указывающим требуемый адрес.
Операция new с размещением может записываться со скобками или без них. */
#include <new>
struct chaff
{
	char dross[20];
	int slag;
};
char buffer1[50];
char buffer2[500];
int main()
{
	chaff *p1, *p2;
	int *p3, *p4;
// Обычные формы операции new
	p1 = new chaff; // помещение структуры в кучу
	р3 = new int [20]; // помещение массива int в кучу
// Две формы операции new с размещением
	р2 = new (buffer1) chaff; // помещение структуры в область bufferl
	р4 = new (buffer2) int[20]; // помещение массива int в область buffer2
	...
/* Для структуры chaff выделяется область памяти bufferl, а для массива 
из 20 элементов int — область памяти buffer2. */
// newplace.cpp — использование операции new с размещением
#include <iostream>
#include <new> // для операции new с размещением
const int BUF = 512;
const int N = 5;
char buffer[BUF]; // блок памяти
int main()
{
    using namespace std;

    double *pd1, *pd2;
    int i;
	// Вызов обычной и операции new с размещением
    cout << "Calling new and placement new:\n";
    pd1 = new double[N];           // использование кучи
    pd2 = new (buffer) double[N];  // использование массива buffer
    for (i = 0; i < N; i++)
        pd2[i] = pd1[i] = 1000 + 20.0 * i;
    cout << "Memory addresses:\n" << "pd1 in heap: " << pd1 // вывод адресов памяти
         << "; buffer in static: " <<  (void *) buffer  <<endl;
    cout << "Memory contents:\n";
    for (i = 0; i < N; i++)		   // вывод содержимого памяти
    {
        cout << "pd1[" << i << "] = " << pd1[i] << " at " << &pd1[i] << "; ";
        cout << "pd2[" << i << "] = " << pd2[i] << " at " << &pd2[i] << endl;
    }
	// Вызов обычной и операции new с размещением во второй раз
    cout << "  Calling new and placement new a second time:\n";
    double *pd3, *pd4;
    pd3= new double[N];            // нахождение нового адреса
    pd4 = new (buffer) double[N];  // перезаписывание старых данных
    for (i = 0; i < N; i++)
        pd4[i] = pd3[i] = 1000 + 40.0 * i;
    cout << "Memory contents:\n";
    for (i = 0; i < N; i++)
    {
        cout << "pd3[" << i << "] = " << pd3[i] << " at " << &pd3[i] << "; ";
        cout << "pd4[" << i << "] = " << pd4[i] << " at " << &pd4[i] << endl;
    }
	// Вызов обычной и операции new с размещением в третий раз
    cout << "  Calling new and placement new a third time:\n";
    delete [] pd1;
    pd1= new double[N];
    pd2 = new (buffer + N * sizeof(double)) double[N]; 
    for (i = 0; i < N; i++)
        pd2[i] = pd1[i] = 1000 + 60.0 * i;
    cout << "Memory contents:\n";
    for (i = 0; i < N; i++)
    {
        cout << "pd1[" << i << "] = " << pd1[i] << " at " << &pd1[i] << "; ";
        cout << "pd2[" << i << "] = " << pd2[i] << " at " << &pd2[i] << endl;
    }
    delete [] pd1;
    delete [] pd3;
    // cin.get();
    return 0;
}
/* Программа имеет вывод:
Calling new and placement new:
Memory addresses:
pd1 in heap: 0x957bc0; buffer in static: 0x406040
Memory contents:
pd1[0] = 1000 at 0x957bc0; pd2[0] = 1000 at 0x406040
pd1[1] = 1020 at 0x957bc8; pd2[1] = 1020 at 0x406048
pd1[2] = 1040 at 0x957bd0; pd2[2] = 1040 at 0x406050
pd1[3] = 1060 at 0x957bd8; pd2[3] = 1060 at 0x406058
pd1[4] = 1080 at 0x957be0; pd2[4] = 1080 at 0x406060
  Calling new and placement new a second time:
Memory contents:
pd3[0] = 1000 at 0x957db0; pd4[0] = 1000 at 0x406040
pd3[1] = 1040 at 0x957db8; pd4[1] = 1040 at 0x406048
pd3[2] = 1080 at 0x957dc0; pd4[2] = 1080 at 0x406050
pd3[3] = 1120 at 0x957dc8; pd4[3] = 1120 at 0x406058
pd3[4] = 1160 at 0x957dd0; pd4[4] = 1160 at 0x406060
  Calling new and placement new a third time:
Memory contents:
pd1[0] = 1000 at 0x957bc0; pd2[0] = 1000 at 0x406068
pd1[1] = 1060 at 0x957bc8; pd2[1] = 1060 at 0x406070
pd1[2] = 1120 at 0x957bd0; pd2[2] = 1120 at 0x406078
pd1[3] = 1180 at 0x957bd8; pd2[3] = 1180 at 0x406080
pd1[4] = 1240 at 0x957be0; pd2[4] = 1240 at 0x406088
----------------------------------------------------
Операция new с размещением действительно помещает массив pd2 в 
массив buffer; обе переменные pd2 и buffer имеют значение 0x406040. 
Тем не менее, они относятся к разным типам; рd1 — это указатель на 
double, тогда как buffer — указатель на char. (именно поэтому в 
программе используется приведение (void *) для buffer; в противном 
случае cout попытается отобразить строку.) Между тем, обычная 
операция new выделяет массиву рd1 адрес памяти с более высоким 
значением — 0x957bc0, который принадлежит динамически управляемой 
куче. Второе обращение к обычной операции new приводит к нахождению 
другого блока памяти — начинающегося с адреса 0x957db0. Однако второе 
обращение к операции new с размещением приводит к использованию того 
же блока памяти, что и прежде. Этот блок начинается с адреса 0x406040.
Важный факт в том, что операция new с размещением просто использует 
адрес, переданный в качестве аргумента; она не анализирует, свободна 
ли указанная область памяти, а также не ищет блок неиспользуемой 
памяти. В результате часть забот об управлении памятью возлагается 
на программиста. Например, при третьем обращении к операции new с 
размещением задается смещение в массиве buffer, чтобы использовалась 
новая область памяти: */
pd2 = new (buffer + N * sizeof(double)) double[N]; // смещение на 40 байт
/* Третий момент касается наличия или отсутствия операции delete. Для 
обычной операции new следующий оператор освобождает блок памяти, 
начинающийся с адреса 0x957bc0; в результате следующее обращение к new 
может повторно использовать тот же самый блок: */
delete [] pd1;
/* В противоположность этому программа из листинга newplace.cpp не 
использует delete для освобождения памяти, выделенной операцией new с 
размещением. В этом случае подобное невозможно. Область памяти, 
указанная переменной buffer, является статической, a delete может 
использоваться только с указателем на область памяти в куче, которая 
выделена обычной операцией new. Массив buffer не подпадает под 
полномочия операции delete, поэтому следующий оператор вызовет 
ошибку времени выполнения: */
delete [] pd2; // не работает
/* 








