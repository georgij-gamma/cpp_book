/*	Исходную программу можно разбить на три части:
• заголовочный файл, содержащий объявления структур и прототипы функций,
которые используют эти структуры;
• файл исходного кода, содержащий код функций, которые работают со структурами;
• файл исходного кода, содержащий код, который вызывает функции работы со
структурами.
	В заголовочных файлах обычно содержится следующее:
• прототипы функций;
• символические константы, определенные с использованием #define или const;
• объявления структур;
• объявления классов;
• объявления шаблонов;
• встроенные функции.
	Фрагмент кода обеспечивает обработку операторов, находящихся между 
директивами #if ndef и #endif, только в случае, если имя coordin_h_ не 
было определено ранее с помощью директивы препроцессора #defіnе: */
#ifndef COORDIN_H_
#define COORDIN_H_
// здесь размещается содержимое включаемого файла
#endif
/* Если затем компилятор обнаруживает второе включение сооrdin.h в том же 
самом файле, он замечает, что имя coordin_h_ уже определено, и переходит к 
строке, следующей после #endif. Данный прием не предотвращает повторного 
включения файла. Вместо этого он заставляет компилятор игнорировать содержимое 
всех включений кроме первого.
 В стандарте C++ вместо термина файл используется термин единица трансляции, 
чтобы сохранить более высокую степень обобщенности; файловая модель —
это не единственный способ организации информации в компьютере.
	Продолжительность хранения, область видимости и компоновка.
• Автоматическая продолжительность хранения - переменные создаются, когда 
выполнение программы входит в функцию или блок, где эти переменные определены. 
После выхода из блока или функции используемая переменными память освобождается.
Бывают: автоматические и регистровые.
• Статическая продолжительность хранения. Переменные, объявленные за 
пределами определения функции либо с использованием ключевого слова static,
имеют статическую продолжительность хранения. Они существуют в течение
всего времени выполнения программы. Бывают: Статические без связывания, с 
с внешним и внутренним связыванием.
• Потоковая продолжительность хранения (C++11). Переменные, объявленные с 
ключевым словом threadlocal, хранятся на протяжении времени существования 
содержащего их потока.
• Динамическая продолжительность хранения. Память, выделяемая операцией
new, сохраняется до тех пор, пока она не будет освобождена с помощью 
операции delete или до завершения программы, смотря какое из событий наступит
раньше. Эта память имеет динамическую продолжительность хранения и часто
называется свободным хранилищем или кучей (heap).
	Стек.
	Стек применяется потому, что новые данные размещаются, образно говоря,
поверх старых данных (т.е. в смежных, а не в тех же самых ячейках памяти), 
а затем удаляются из стека, после того как программа завершит работу с ними.
 Программа отслеживает состояние стека с помощью двух указателей. Один 
указывает на базу стека, с которой начинается выделенная область памяти, 
а другой — на вершину стека, которая представляет собой следующую ячейку 
свободной памяти. Когда происходит вызов функции, ее автоматические 
переменные добавляются в стек, а указатель вершины устанавливается на 
свободную ячейку памяти, следующую за только что размещенными переменными. 
После завершения функции указатель вершины снова принимает значение, 
которое он имел до вызова функции. В результате эффективно освобождается 
память, которая использовалась для хранения новых переменных. Стек построен 
по принципу LIFO (last-in, first-out — последним пришел, первым обслужен). 
Это означает, что переменная, которая попала в стек последней, удаляется 
из него первой.
	В программном обеспечении переполнение буфера стека происходит, когда 
программа выполняет запись по адресу памяти в стеке вызовов программы за 
пределами предполагаемой структуры данных, которая обычно является буфером 
фиксированной длины. Ошибки переполнения буфера стека возникают, когда 
программа записывает в буфер, расположенный в стеке, больше данных, чем 
фактически выделено для этого буфера. Это почти всегда приводит к повреждению 
смежных данных в стеке, а в случаях, когда переполнение было инициировано по 
ошибке, часто приводит к сбою или неправильной работе программы. Переполнение 
буфера в стеке с большей вероятностью нарушит выполнение программы, чем 
переполнение буфера в куче, потому что стек содержит адреса возврата для всех 
активных вызовов функций. Переполнение может быть вызвано намеренно как часть 
атаки, известной как разбиение стека. Если уязвимая программа работает с особыми 
привилегиями или принимает данные от ненадежных сетевых хостов (например, 
веб-сервера), то ошибка является потенциальной уязвимостью безопасности. 
Если буфер стека заполнен данными, полученными от ненадежного пользователя, 
то этот пользователь может повредить стек таким образом, чтобы внедрить 
исполняемый код в запущенную программу и взять под контроль процесс. 
Это один из самых старых и надежных методов получения злоумышленниками 
несанкционированного доступа к компьютеру. 
Канонический метод использования переполнения буфера на основе стека - 
перезапись адреса возврата функции указателем на данные, контролируемые 
злоумышленником (обычно в самом стеке). */
#include <string.h>
void foo (char * bar) 
{ 
   char c[12];
   strcpy (c, bar); // без проверки границ 
}
int main (int argc, char **argv)
{ 
   foo (argv[1]); 
   return 0; 
}
/* Этот код берет аргумент из командной строки и копирует его в локальную 
переменную стека c. Это отлично работает для аргументов командной строки 
меньше 12 символов (как вы можете видеть на рисунке B ниже). Любые аргументы 
длиной более 11 символов приведут к повреждению стека. (Максимальное количество 
безопасных символов на единицу меньше размера буфера здесь, потому что в языке 
программирования C строки заканчиваются нулевым байтовым символом. Таким 
образом, для ввода из двенадцати символов требуется тринадцать байтов для 
хранения, за вводом следует нулевым байтом сигнального устройства. Нулевой 
байт затем завершает перезапись области памяти, которая на один байт выходит 
за пределы буфера.)
	
	Переменные со статической продолжительностью хранения.
Компилятор просто резервирует фиксированный блок памяти для хранения 
всех статических переменных, и эти переменные доступны программе на 
протяжении всего времени ее выполнения. Более того, если статическая
переменная не инициализирована явно, компилятор устанавливает ее в 0. 
Элементы статических массивов и структур устанавливаются в 0 по умолчанию.*/
int global = 1000;	// статическая продолжительность, внешнее связывание
static int one_file = 50; // статическая продолжительность, внутреннее связывание
int main ()
{
void functl(int n)
...
{
static int count = 0; // статическая продолжительность, нет связывания
}
/* Поскольку переменная global имеет внешнее связывание, она также может 
применяться в других файлах, которые являются частью программы.
 Все биты неинициализированной статической переменной устанавливаются в 0. 
Такая переменная называется инициализированной нулями.
 При использовании в локальном объявлении для указания статической переменной 
без связывания static отражает вид продолжительности хранения. Когда ключевое 
слово static применяется с объявлением вне блока, оно отражает внутреннее 
связывание; переменная уже имеет статическую продолжительность хранения. 
Это можно назвать перегрузкой ключевого слова, причем более точный смысл 
определяется контекстом.
Статические переменные могут быть инициализированными нулями, они могут
быть подвергнуты инициализации константным выражением, и они могут быть 
подвергнуты динамической инициализации. */
#include <cmath>
int x;	// инициализация нулями
int у = 5; // инициализация константным выражением
long z=13*13; // инициализация константным выражением
const double pi = 4.0 *atan(1.O); // динамическая инициализация

/*	Ключевое слово constexpr, добавленное в C++11, перед функцией означает, 
что если значения параметров возможно посчитать на этапе компиляции, то 
возвращаемое значение также должно посчитаться на этапе компиляции. Если 
значение хотя бы одного параметра будет неизвестно на этапе компиляции, то 
функция будет запущена в runtime (а не будет выведена ошибка компиляции).
constexpr-функция:*/ constexpr возвращаемое_значение имя_функции (параметры)
/*constexpr-переменная: */ constexpr тип = expression;
int sum (int a, int b)
{
	return a + b;
}

constexpr int new_sum (int a, int b)
{
	return a + b;
}

void func()
{
	constexpr int a1 = new_sum (5, 12); // ОК: constexpr-переменная
	constexpr int a2 = sum (5, 12); // ошибка: функция sum не является constexp-выражением
	int a3 = new_sum (5, 12); // ОК: функция будет вызвана на этапе компиляции
	int a4 = sum (5, 12); // ОК
}
/* constexpr-переменная является константой (const), но константа не 
является constexpr-переменной.
 В случае «утери» constexpr-спецификатора переменной вернуть обратно его 
уже не получится, даже если значение может посчитаться на этапе компиляции. 
constexpr-спецификатор нельзя добавить с помощью const_cast, так как constexpr 
не является cv-спецификатором (это const и volatile). Такой код не заработает: */
constexpr int inc (int a)
{
	return a + 1;
}

void func()
{
	int a = inc (3);
	constexpr int b = inc (a); // ошибка: a не является constexpr-выражением, 
	// из-за чего возвращаемое значение не имеет спецификатор constexpr
}
/* Параметры функций не могут быть constexpr. То есть не получится создать 
исключительно constexpr-функцию, которая может работать только на этапе компиляции.
Также constexpr-функции могут работать с классами.
	Правило одного определения:
	Гласит, что для каждой переменной должно существовать только одно определение. 
Два вида объявления переменных. Первый вид называется определяющим объявлением 
или просто определением. Определение приводит к выделению памяти для переменной. 
Второй вид называется ссылочным объявлением или просто объявлением. Объявление 
не приводит к выделению памяти, поскольку ссылается на переменную, которая уже 
существует. Ссылочное объявление использует ключевое слово extern и не 
предоставляет возможности инициализации. В противном случае объявление является 
определением и приводит к выделению пространства для хранения: */
double up; // определение, up равно О
extern int blem; // переменная blem определена в другом месте
extern char gr = 'z'; // определение, поскольку присутствует инициализация
/* Если внешняя переменная используется в нескольких файлах, только один из них
может содержать определение этой переменной (согласно правилу одного 
определения). Но во всех прочих файлах, где эта переменная используется, 
она должна быть объявлена с указанием ключевого слова extern: */
// fileOl.cpp
extern int cats = 20;// определение, поскольку присутствует инициализация
int dogs = 22; // тоже определение
int fleas; // и это определение
// file02.cpp
// используются cats и dogs из fileOl.cpp
extern int cats; // это не определения, поскольку в них указано
extern int dogs; // ключевое слово extern и отсутствует инициализация
// file98.cpp
// используются cats, dogs и fleas из fileOl.cpp
extern int cats;
extern int dogs;
extern int fleas;
/* В этом случае во всех файлах используются переменные cats и dogs, 
определенные в fileOl.cpp. Однако в file02.cpp переменная fleas не 
объявляется повторно, поэтому доступ к ней невозможен. Ключевое слово 
extern в fileOl.cpp в действительности не нужно, поскольку и без него 
эффект будет таким же. Хотя в программе могут присутствовать различные 
переменные с одинаковыми именами, каждая версия может иметь только 
одно определение.
	Выбор между глобальными и локальными переменными.
	Чем эффективнее программа изолирует данные от нежелательного доступа, 
тем лучше будет сохраняться их целостность. В большинстве случаев следует 
пользоваться локальными переменными и передавать данные функциям только 
по мере необходимости, а не делать данные открытыми за счет использования 
глобальных переменных. Глобальные переменные имеют свою область применения. 
Если имеется блок данных, который должен использоваться несколькими 
функциями, например, такой как массив с названиями месяцев или список 
атомных весов химических элементов. */
const char *const months [12] = 
{
"January", "February", "March", "April", "May",
"June", "July", "August", "September", "October",
"November", "December"
};
/* Первое ключевое слово const защищает от изменений строки, а второе 
слово const гарантирует, что каждый указатель в массиве будет постоянно 
указывать на ту же самую строку, на которую он указывал изначально.
	Статическая продолжительность хранения, внутреннее связывание.
Применение модификатора static к переменной с областью видимости файла
обеспечивает для нее внутреннее связывание. Переменная с внутренним 
связыванием является локальной для файла, который ее содержит. При этом 
обычная внешняя переменная обладает внешним связыванием, что означает 
возможность ее применения в различных файлах. */
// файл 1
int errors = 20; // внешнее объявление
// файл 2
int errors = 5; // ??известна только в file2??
void froobish ()
{
cout << errors; // ошибка, нарушается правило одного определения!
...
// Так правильно:
// файл 2
static int errors =5; // известна только файлу 2
void froobish ()
{
cout << errors; // использует переменную errors, определенную в файле 2
...
/* В многофайловой программе внешнюю переменную можно определять в 
одном и только одном файле. Все остальные файлы, использующие эту 
переменную, должны содержать ее объявление с ключевым словом extern.
	Статическая продолжительность хранения, отсутствие связывания.
Такая переменная создается за счет применения модификатора static к
переменной, определенной внутри блока. Несмотря на видимость 
переменной в пределах блока, она существует даже тогда, когда блок 
неактивен. Таким образом, статическая локальная переменная может 
сохранять свое значение между вызовами функции. Если статическая 
локальная переменная инициализируется, это делается только один раз 
при запуске программы. Последующие вызовы функции не будут приводить к
повторной инициализации переменной, как это происходит в случае 
автоматических переменных. */
void strcount(const char *str)
{
	using namespace std;
	static int total = 0; // статическая локальная переменная: при следующем
// входе в эту функцию не будет инициализирована нулём, а примет 
// релультат, полученный при предыдущем входе в эту функцию
	int count = 0; // автоматическая локальная переменная, всегда 
// инициализируется нулём
	cout << "V" << str <<"\" contains ";
	while (*str++) // переход к концу строки
		count++;
	total += count; // здесь статическая переменная обновляется
	cout << count << " characters\n";
	cout << total << " characters total\n";
}
/*	Cпецификаторs класса храпения и сѵ-квалификаторы. */
• auto // (исключен из спецификаторов в С++11)
• register
• static
• extern
• thread_local // (добавлен в С++11)
• mutable
/* До появления С++11 ключевое слово auto могло использоваться в 
объявлении для документирования того факта, что переменная является 
автоматической. (В С++11 ключевое слово auto применяется для 
автоматического выведения типа.) Ключевое слово register используется 
в объявлении для указания регистрового класса хранения, который в 
С++11 представляет собой всего лишь явный способ сообщения о том, что 
переменная является автоматической. Ключевое слово static, когда 
применяется в объявлении с областью видимости файла, задает внутреннее
связывание. При использовании в локальном объявлении оно определяет 
статический класс хранения для локальной переменной. Ключевое слово 
extern указывает на ссылочное объявление — т.е., что объявление 
ссылается на переменную, которая определена где-то в другом месте. 
Ключевое слово thread_local отражает, что продолжительность хранения 
переменной является продолжительностью существования содержащего ее 
потока. Переменная thread_local соотносится с потоком во многом так же, 
как обычная статическая переменная — со всей программой.
 mutable - с его помощью можно указать, что отдельный член структуры 
(или класса) может быть изменен, даже если переменная типа структуры 
(или класса) объявлена со спецификатором const: */
struct data
{
char name[30];
mutable int accesses;
};
const data veep = { "Claybourne Clodde", 0, ... };
strcpy(veep.name, "Joye Joux"); // не разрешено
veep.accesses++; // разрешено
/* Квалификатор const структуры ѵеер предотвращает изменение ее 
элементов в программе, но спецификатор mutable, указанный для члена 
accesses, снимает с него это ограничение.
	Сѵ-квалификаторы:
• const
• volatile
 volatile указывает, что значение в ячейке 
памяти может быть изменено, даже если в коде программы нет ничего такого, 
что может модифицировать ее содержимое. 
const указывает, что переменная после инициализации не может быть 
оптимизирована программой. Глобальная переменная со спецификатором 
const по умолчанию имеет внутреннее связывание. const обрабатывается 
так, будто в нем использован спецификатор static: */
const int fingers = 10; // то же самое, что и static const int fingers = 10;
/* Внутреннее связывание также означает, что каждый файл получает собственный
набор констант, а не разделяет их с другими файлами. Каждое определение 
является приватным для файла, который его содержит. Именно поэтому 
определения констант целесообразно поместить в заголовочный файл. Таким 
образом, если включить один и тот же заголовочный файл в два файла исходного 
кода, они оба получат один и тот же набор констант. Если по какой-либо 
причине необходимо, чтобы константа имела внешнее связывание, можно 
воспользоваться ключевым словом extern и переопределить устанавливаемое 
по умолчанию внутреннее связывание: */
extern const int states = 50; // определение с внешним связыванием
/* При объявлении константы внутри функции или блока она получает область 
видимости блока.
	Функции и связывание.
	Язык C++, как и С, не позволяет объявлять одну функцию внутри другой, 
поэтому все функции автоматически получают статическую продолжительность 
хранения, т.е. существуют во время выполнения программы. По умолчанию функции 
имеют внешнее связывание, в том смысле, что могут разделяться между файлами. 
На самом деле в прототипе функции можно указать ключевое слово extern,
отразив, что эта функция определена в другом файле, но это не обязательно.
Можно также ограничить область видимости функции одним файлом, назначив для 
нее внутреннее связывание с помощью ключевого слова static. Это ключевое 
слово должно применяться к прототипу и к определению функции: */
static int private(double x);
static int private(double x)
{
}
/* Это также означает, что то же самое имя можно назначить какой-то другой 
функции в другом файле. Как и в случае с переменными, статическая функция 
переопределяет внешнее определение для файла, содержащего статическое 
объявление. Правило одного определения распространяется также на невстроенные 
функции. Однако каждый файл, использующий функцию, должен содержать прототип 
этой функции. Встроенные функции являются исключением из этого правила и 
позволяют помещать свои определения в заголовочный файл. Таким образом, 
каждый файл, который включает такой заголовочный файл, будет иметь 
определения встроенных функций. Однако язык C++ требует, чтобы все 
встроенные определения для конкретной функции были идентичными.
 Где компилятор C++ ищет функции?
Если прототип функции в данном файле указывает, что функция является 
статической, компилятор ищет ее определение только в этом файле. В противном 
случае компилятор (а также и компоновщик) просматривает все файлы программы. 
Если компилятор находит два определения, он выдает сообщение об ошибке, 
поскольку может существовать только одно определение внешней функции. Если 
компилятору не удается обнаружить ни одного определения этой функции, он 
переходит к поиску в библиотеках.
	Языковое связывание.
Для каждой отдельной функции компоновщику необходимо уникальное символическое 
имя. Для внутренних потребностей компилятор языка С может транслировать имя 
функции С, такое как spiff, в _spiff. Этот прием называется языковым 
связыванием С. Однако в C++ допускается наличие нескольких функций с одним 
и тем же именем, которые тоже должны транслироваться в разные символические 
имена. Таким образом, компилятор C++ инициирует процесс искажения или 
декорирования имен , позволяющий сгенерировать разные символические имена 
для перегруженных функций. Например, spiff(int) может быть преобразовано, 
скажем, в _spiff_i, a spiff(double, double) — в _spiff_d_d. Этот прием 
называется языковым связыванием C++. Если требуется использовать 
предварительно скомпилированную функцию из библиотеки С в программе на C++: */
spiff(22); // обращение к функции spiff(int) из библиотеки С
/* Гипотетическое символическое имя в библиотеке С выглядит как _spiff, 
однако для нашего воображаемого компоновщика соглашение, принятое в отношении 
поиска в C++, диктует поиск символического имени _spiff_i. Можно 
воспользоваться прототипом функции, которое указывает, какой протокол 
следует применять: */
extern "С" void spiff(int); // использовать для поиска имени протокол С
extern void spoff(int); // использовать для поиска имени протокол C++
extern "C++" void spaff(int); // использовать для поиска имени протокол C++

/*	Схемы хранения и динамическое выделение памяти.
В отличие от автоматической памяти, динамическая память не подчиняется 
схеме LIFO. Порядок выделения и освобождения памяти зависит от того, когда 
и как применяются операции new и delete. Как правило, компилятор использует 
три отдельных области памяти: одну для статических переменных (эта область 
может быть разбита дополнительно), одну для автоматических переменных и 
одну для динамической памяти. Несмотря на то что концепции схем хранения 
неприменимы к динамической памяти, они применимы к автоматическим и 
статическим переменным-указателям, используемым для отслеживания 
динамической памяти. */
float *p_fees = new float[20];
/* 80 байтов памяти (предполагая, что тип float занимает 4 байта), 
выделенных операцией new, остаются занятыми до тех пор, пока операция 
delete не освободит их. Однако указатель p_fees перестает существовать, 
когда выполнение программы покидает блок, содержащий его объявление. 
Если требуется, чтобы 80 байтов выделенной памяти стали доступными другой 
функции, необходимо передать или вернуть адрес этой памяти данной функции. 
С другой стороны, если сделать объявление указателя p_fees внешним, то он 
станет доступным всем функциям, которые находятся в файле после этого 
объявления. Используя следующий оператор во втором файле, можно сделать 
указатель доступным и в нем: */
extern float *p_fees;
/*	Инициализация с помощью операции new.
Если требуется создать и инициализировать хранилище для одного из встроенных
скалярных типов, таких как int или double, необходимо указать имя типа и 
инициализирующее значение, заключенное в круглых скобках: */
int *рі = new int (6) ; // *pi устанавливается в 6
double *pd = new double (99.99); // *pd устанавливается в 99.99
/* Синтаксис с круглыми скобками также может использоваться с классами, 
которые имеют подходящие конструкторы.
C++11 позволяет делать следующее: */
struct where {double x; double у; double z;};
where *one = new where {2.5, 5.3, 7.2}; // C++11
int *ar = new int [4] {2,4,6,7}; // C++11
/* В C++11 можно также применять инициализацию с помощью фигурных скобок для
переменных с одиночным значением: */
int *pin = new int {}; // *pi устанавливается в 6
double *pdo = new double {99.99}; // *pd устанавливается в 99.99
/*	Когда new дает сбой?
Может случиться так, что операция new не сможет найти запрошенный объем 
памяти. В настоящее время new генерирует исключение std::bad_alloc. 
	new: операции, функции и заменяющие функции.
Операции new и new[] обращаются к двум функциям: */
void *operator new(std::size_t); // используется new
void *operator new[](std::size_t); // используется new[]
/* Они называются функциями распределения и являются частью глобального 
пространства имен. Подобным же образом, существуют функции освобождения, 
вызываемые операциями delete и delete[]: */
void operator delete(void *) ;
void operator delete[](void *) ;
/* Они используют синтаксис перегрузки операций, рассматриваемый в главе 11.
Здесь std::size_t — это typedef для некоторых подходящих целочисленных 
типов. Базовый оператор, такой как: */
int *pi = new int;
// транслируются примерно в следующее:
int *pi = new (sizeof (int));
// А оператор:
int *pa = new int[40];
// транслируются в такую конструкцию:
int *pa = new (40 *sizeof(int));
/* Оператор с операцией new может также предоставлять инициализирующие 
значения, поэтому в общем случае использование new может сводиться не
только к вызову функции new().
Аналогично, оператор: */
delete pi;
// приводит к следующему вызову функции:
delete (pi) ;
/* В C++ эти функции называются заменяемыми. Это значит, что при наличии 
достаточного опыта и желания можно создать заменяющие функции для new и 
delete, подогнав их под специфические требования. Например, можно было
бы определить заменяющие функции с областью видимости класса и настроить 
их для удовлетворения потребностей в распределении конкретного класса. 
В коде операция new применялась бы как обычно, но вызывала бы заменяющую 
функцию new().
	Операция new с размещением.
Существует разновидность операции new, называемая операцией new с 
размещением, которая позволяет указывать адрес используемого блока.
Чтобы воспользоваться операцией new с размещением, сначала нужно включить
заголовочный файл new, который содержит прототип этой версии new. Затем 
операция new применяется с аргументом, указывающим требуемый адрес.
Операция new с размещением может записываться со скобками или без них. */
#include <new>
struct chaff
{
	char dross[20];
	int slag;
};
char buffer1[50];
char buffer2[500];
int main()
{
	chaff *p1, *p2;
	int *p3, *p4;
// Обычные формы операции new
	p1 = new chaff; // помещение структуры в кучу
	р3 = new int [20]; // помещение массива int в кучу
// Две формы операции new с размещением
	р2 = new (buffer1) chaff; // помещение структуры в область bufferl
	р4 = new (buffer2) int[20]; // помещение массива int в область buffer2
	...
/* Для структуры chaff выделяется область памяти bufferl, а для массива 
из 20 элементов int — область памяти buffer2. */
// newplace.cpp — использование операции new с размещением
#include <iostream>
#include <new> // для операции new с размещением
const int BUF = 512;
const int N = 5;
char buffer[BUF]; // блок памяти
int main()
{
    using namespace std;

    double *pd1, *pd2;
    int i;
	// Вызов обычной и операции new с размещением
    cout << "Calling new and placement new:\n";
    pd1 = new double[N];           // использование кучи
    pd2 = new (buffer) double[N];  // использование массива buffer
    for (i = 0; i < N; i++)
        pd2[i] = pd1[i] = 1000 + 20.0 * i;
    cout << "Memory addresses:\n" << "pd1 in heap: " << pd1 // вывод адресов памяти
         << "; buffer in static: " <<  (void *) buffer  << endl;
    cout << "Memory contents:\n";
    for (i = 0; i < N; i++)		   // вывод содержимого памяти
    {
        cout << "pd1[" << i << "] = " << pd1[i] << " at " << &pd1[i] << "; ";
        cout << "pd2[" << i << "] = " << pd2[i] << " at " << &pd2[i] << endl;
    }
	// Вызов обычной и операции new с размещением во второй раз
    cout << "  Calling new and placement new a second time:\n";
    double *pd3, *pd4;
    pd3= new double[N];            // нахождение нового адреса
    pd4 = new (buffer) double[N];  // перезаписывание старых данных
    for (i = 0; i < N; i++)
        pd4[i] = pd3[i] = 1000 + 40.0 * i;
    cout << "Memory contents:\n";
    for (i = 0; i < N; i++)
    {
        cout << "pd3[" << i << "] = " << pd3[i] << " at " << &pd3[i] << "; ";
        cout << "pd4[" << i << "] = " << pd4[i] << " at " << &pd4[i] << endl;
    }
	// Вызов обычной и операции new с размещением в третий раз
    cout << "  Calling new and placement new a third time:\n";
    delete [] pd1;
    pd1= new double[N];
    pd2 = new (buffer + N * sizeof(double)) double[N]; 
    for (i = 0; i < N; i++)
        pd2[i] = pd1[i] = 1000 + 60.0 * i;
    cout << "Memory contents:\n";
    for (i = 0; i < N; i++)
    {
        cout << "pd1[" << i << "] = " << pd1[i] << " at " << &pd1[i] << "; ";
        cout << "pd2[" << i << "] = " << pd2[i] << " at " << &pd2[i] << endl;
    }
    delete [] pd1;
    delete [] pd3;
    // cin.get();
    return 0;
}
/* Программа имеет вывод:
Calling new and placement new:
Memory addresses:
pd1 in heap: 0x957bc0; buffer in static: 0x406040
Memory contents:
pd1[0] = 1000 at 0x957bc0; pd2[0] = 1000 at 0x406040
pd1[1] = 1020 at 0x957bc8; pd2[1] = 1020 at 0x406048
pd1[2] = 1040 at 0x957bd0; pd2[2] = 1040 at 0x406050
pd1[3] = 1060 at 0x957bd8; pd2[3] = 1060 at 0x406058
pd1[4] = 1080 at 0x957be0; pd2[4] = 1080 at 0x406060
  Calling new and placement new a second time:
Memory contents:
pd3[0] = 1000 at 0x957db0; pd4[0] = 1000 at 0x406040
pd3[1] = 1040 at 0x957db8; pd4[1] = 1040 at 0x406048
pd3[2] = 1080 at 0x957dc0; pd4[2] = 1080 at 0x406050
pd3[3] = 1120 at 0x957dc8; pd4[3] = 1120 at 0x406058
pd3[4] = 1160 at 0x957dd0; pd4[4] = 1160 at 0x406060
  Calling new and placement new a third time:
Memory contents:
pd1[0] = 1000 at 0x957bc0; pd2[0] = 1000 at 0x406068
pd1[1] = 1060 at 0x957bc8; pd2[1] = 1060 at 0x406070
pd1[2] = 1120 at 0x957bd0; pd2[2] = 1120 at 0x406078
pd1[3] = 1180 at 0x957bd8; pd2[3] = 1180 at 0x406080
pd1[4] = 1240 at 0x957be0; pd2[4] = 1240 at 0x406088
----------------------------------------------------
Операция new с размещением действительно помещает массив pd2 в 
массив buffer; обе переменные pd2 и buffer имеют значение 0x406040. 
Тем не менее, они относятся к разным типам; рd1 — это указатель на 
double, тогда как buffer — указатель на char. (именно поэтому в 
программе используется приведение (void *) для buffer; в противном 
случае cout попытается отобразить строку.) Между тем, обычная 
операция new выделяет массиву рd1 адрес памяти с более высоким 
значением — 0x957bc0, который принадлежит динамически управляемой 
куче. Второе обращение к обычной операции new приводит к нахождению 
другого блока памяти — начинающегося с адреса 0x957db0. Однако второе 
обращение к операции new с размещением приводит к использованию того 
же блока памяти, что и прежде. Этот блок начинается с адреса 0x406040.
Важный факт в том, что операция new с размещением просто использует 
адрес, переданный в качестве аргумента; она не анализирует, свободна 
ли указанная область памяти, а также не ищет блок неиспользуемой 
памяти. В результате часть забот об управлении памятью возлагается 
на программиста. Например, при третьем обращении к операции new с 
размещением задается смещение в массиве buffer, чтобы использовалась 
новая область памяти: */
pd2 = new (buffer + N * sizeof(double)) double[N]; // смещение на 40 байт
/* Третий момент касается наличия или отсутствия операции delete. Для 
обычной операции new следующий оператор освобождает блок памяти, 
начинающийся с адреса 0x957bc0; в результате следующее обращение к new 
может повторно использовать тот же самый блок: */
delete [] pd1;
/* В противоположность этому программа из листинга newplace.cpp не 
использует delete для освобождения памяти, выделенной операцией new с 
размещением. В этом случае подобное невозможно. Область памяти, 
указанная переменной buffer, является статической, a delete может 
использоваться только с указателем на область памяти в куче, которая 
выделена обычной операцией new. Массив buffer не подпадает под 
полномочия операции delete, поэтому следующий оператор вызовет 
ошибку времени выполнения: */
delete [] pd2; // не работает
/* Использовать операцию new с размещением можно и другим способом —
комбинировать ее с инициализацией для помещения информации по 
определенному аппаратному адресу.
 В основном операция new с размещением лишь возвращает переданный ей 
адрес, приводя его к типу void *, чтобы его можно было присваивать 
любому типу указателя. Операция new с размещением используется и для 
объектов классов.
Точно так же как обычная операция new вызывает функцию new с одним 
аргументом, стандартная операция new с размещением вызывает функцию new 
с двумя аргументами: */
int *pi = new int; // вызывает new (sizeof (int) )
int *p2 = new(buffer) int; // вызывает new(sizeof(int), buffer)
int *p3 = new(buffer) int[40]; // вызывает new(40*sizeof(int), buffer)
/* Функция new с размещением не является заменяемой, но может быть перегружена.
Ей необходимо передать, по крайней мере, два параметра, первым из которых 
всегда будет */std::size_t /*, обозначающий количество запрашиваемых байт.
Любая такая перегруженная функция называется функцией new с размещением, даже 
если дополнительные параметры не указывают ячейку памяти.
 size_t — это базовый беззнаковый целочисленный memsize-тип, определённый в 
стандартной библиотеке языков C/C++. Является типом результата, возвращаемого 
оператором sizeof. Размер типа выбирается таким образом, чтобы в него можно 
было записать максимальный размер теоретически возможного массива любого типа. 
На 32-битной системе size_t будет занимать 32-бита, на 64-битной - 64-бита. 
Другими словами в тип size_t может быть безопасно помещен указатель (исключение 
составляют указатели на функции классов). Тип size_t обычно применяется для 
счетчиков циклов, индексации массивов, хранения размеров, адресной арифметики.

	Пространства имен.
Имена в C++ могут относиться к переменным, функциям, структурам, 
перечислениям, классам, а также членам классов и структур. Например, две 
библиотеки могут определять классы с именами List, Tree и Node, но 
несовместимым образом. Может потребоваться использовать класс List из одной
библиотеки и класс Tree из другой, при этом каждый из них ожидает 
взаимодействия с собственной версией класса Node. Конфликты подобного рода 
называются проблемами пространств имен.
	Термины.
	Декларативная область — это область, в которой могут делаться объявления. 
Например, глобальную переменную можно объявить вне всех функций. Если объявить 
переменную внутри функции, ее декларативной областью будет самый внутренний блок, 
в котором она объявлена.
	Потенциальная область видимости переменной начинается с точки объявления и
простирается до конца ее декларативной области объявления. Таким образом, 
потенциальная область видимости более ограничена, чем декларативная область,
поскольку нельзя использовать переменную в программе ранее позиции, в которой
она впервые была определена.
	Часть программы, которой фактически доступна данная переменная, называется
областью видимости.	В каждой декларативной области могут быть определены имена, 
не зависящие от имен, объявленных в других декларативных областях. 
	Новое средство пространств имен.
В настоящее время в C++ появилась возможность создавать именованные пространства 
имен за счет определения декларативной области нового вида, одним из основных 
назначений которой является предоставление места для объявления имен. Имена
в одном пространстве имен не конфликтуют с такими же именами, но объявленными
в других пространствах имен. При этом существуют механизмы, которые позволяют
другим частям программы использовать элементы, объявленные в том или ином 
пространстве имен. */
namespace Jack
{
double pail;	// объявление переменной
void fetch();	// прототип функции
int pal;		// объявление переменной
struct Well {...}; // объявление структуры
}
namespace Jill
{
double bucket(double n) { ... } // определение функции
double fetch;	// объявление переменной
int pal;		// объявление переменной
struct Hill {...}; // объявление структуры
}
/* Пространства имен могут находиться на глобальном уровне или внутри других
пространств имен, однако они не могут быть помещены в блок. Следовательно, имя,
объявленное в пространстве имен, по умолчанию имеет внешнее связывание (если
только оно не ссылается на константу).
	Глобальное пространство имен — соответствует декларативной области на 
уровне файла. Следовательно, то, что раньше подразумевалось под глобальными 
переменными, сейчас описывается как часть глобального пространства имен.
Имена в одном пространстве имен не конфликтуют с именами в другом 
пространстве имен. Таким образом, имя fetch в пространстве имен Jack может 
сосуществовать с именем fetch в пространстве Jill, а имя Hill пространства 
Jill — сосуществовать с внешним именем Hill. Правила, регламентирующие 
объявления и определения в пространствах имен, совпадают с правилами 
глобальных объявлений и определений. Пространства имен являются открытыми. 
Это означает, что можно добавлять новые имена в существующие пространства имен.*/
namespace Jill 
{
	char *goose (const char *);
}
namespace Jack
{
	void fetch() // Код этой функции можно разместить далее в этом (или другом)
	{			 // файле, снова указав пространство имен Jack
		...
	}
}
/* Простейший способ доступа к именам заданного пространства имен предусматривает 
использование операции разрешения контекста (::), которая позволяет уточнить имя 
с помощью его пространства имен: */
Jack::pail = 12.34;	// использование переменной
Jill::Hill mole;	// создание структуры типа Hill
Jack::fetch();		// использование функции
/* Имя без добавлений, такое как pail, называется не уточненным именем, в то 
время как имя с указанием пространства имен вроде Jack::pail — уточненным именем.
	Объявления using и директивы using.
Объявление using обеспечивает доступ к отдельным идентификаторам, а 
директива using делает доступным пространство имен в целом. */
using Jill::fetch; /* объявление using
Объявление using добавляет в декларативную область отдельное имя. Например,
объявление using для Jill::fetch в main() добавляет имя fetch в декларативную
область, определенную функцией main(). */
namespace Jill
{
	double bucket(double n) { ... }
	double fetch;
	struct Hill {...};
}
char fetch;
int main ()
{
	using Jill::fetch; // помещение fetch в локальное пространство имен
	double fetch;	// Ошибка! Локальное имя fetch уже существует!
	cin >> fetch;	// чтение значения в переменную Jill::fetch
	cin >> ::fetch;	// чтение значения в глобальную переменную fetch
	...
}
/* Помещение объявления using на внешний уровень приводит к добавлению 
соответствующего имени в глобальное пространство имен: */
void other();
namespace Jill
{
	double bucket(double n) { ... }
	double fetch;
	struct Hill { ... };
}
using Jill::fetch;
int main()
{
	cin >> fetch;
	other ();
}
void other ()
{
	cout << fetch; // вывод значения Jill::fetch
}
/*Таким образом, объявление using делает доступным одиночное имя. В отличие
от этого, директива using делает доступными все имена. Директива using 
создается путем предварения идентификатора пространства имен ключевыми словами 
using namespace. После этого все имена данного пространства становятся доступными 
без необходимости в использовании операции разрешения контекста: */
using namespace Jack; // делает доступными все имена в Jack
/* При размещении директивы на глобальном уровне имена пространства имен 
становятся доступными глобально. */
#include <iostream> // помещает имена в пространство имен std
using namespace std; // делает имена доступными глобально
/* Если поместить директиву using в отдельную функцию, имена станут доступными
только в этой функции. */
int vorn(int m)
{
	using namespace jack; // делает имена доступными в функции vorn()
}
/* Директивы и объявления using увеличивают вероятность конфликта имен.
Если доступны пространства имен jack и jill, то в случае применения операции 
разрешения контекста неопределенность не возникает: */
jack::pal = 3;
jill::pal = 10;
/*Переменные jack::pal и jill::pal имеют отличающиеся идентификаторы, 
относящиеся к разным адресам памяти. Однако при использовании объявлений using
ситуация меняется: */
using jack::pal;
using jill::pal;
pal = 4; /* какая переменная pal имеется в виду? возникает конфликт.
	Сравнение директив using и объявлений using.
Если воспользоваться директивой using для импорта некоторого имени, уже 
объявленного в функции, локальное имя будет скрывать имя из пространства имен 
точно так же, как оно скрывало бы глобальную переменную с тем же самым именем. 
Однако это не мешает применять операцию разрешения контекста: */
namespace Jill 
{
	double bucket(double n) { ... }
	double fetch;
	struct Hill { ... };
}
char fetch;	// глобальное пространство имен
int main ()
{
	using namespace Jill;		// импорт всех имен из пространства
	Hill Thrill;				// создание структуры типа Jill::Hill
	double water = bucket(2);	// использование функции Jill::bucket();
	double fetch;				// это не ошибка; имя Jill::fetch скрывается
	cin >> fetch;				// чтение значения в локальную переменную fetch
	cin >> ::fetch;				// чтение значения в глобальную переменную fetch
	cin >> Jill::fetch; 		// чтение значения в переменную Jill::fetch

int foom()
{
Hill top;			// ОШИБКА
Jill::Hill crest; 	// допустимо
}
/* Здесь в функции main () имя Jill: : fetch помещено в локальное пространство
имен. Оно не имеет локальной области видимости, следовательно, не переопределяет
глобальное имя fetch. Однако локально объявленное имя fetch скрывает 
переменную Jill: :fetch и глобальную переменную fetch. Тем не менее, обе эти 
переменные становятся доступными, если воспользоваться операцией разрешения 
контекста. Хотя директива using в функции рассматривает имена из области имен 
как объявленные вне функции, она не делает их доступными другим функциям в файле.*/
using namespace std; // избегайте, поскольку конструкция слишком неразборчива
// Вместо этого рекомендуется пользоваться следующим подходом:
int x;
std::cin  >> х;
std::cout << х << std::endl;
// Или поступать так:
using std::cin;
using std::cout;
using std::endl;
int x;
 cin >> x;
cout << x << endl;
//	Объявления пространств имен могут быть вложенными, как показано ниже:
namespace elements
{
	namespace fire
	{
		int flame;
	}
	float water;
}
// В этом случае ссылка на переменную flame выглядит как:
elements::fire::flame.
/* Аналогичным образом внутренние имена можно сделать доступными с помощью 
следующей директивы using: */
using namespace elements::fire;
/* Можно также пользоваться директивами и объявлениями using внутри 
пространств имен, как показано ниже: */
namespace myth
{
	using Jill::fetch;
	using namespace elements;
	using std::cout;
	using std::cin;
}
// Для доступа к переменной fetch возможен следующий способ:
std::cin >> myth::fetch;
/* Поскольку переменная является еще и частью пространства имен Jill,
обращение Jill::fetch также допустимо: */
std::cout << Jill::fetch; // вывод значения, прочитанного в myth::fetch
/* При условии отсутствия конфликта имен локальных переменных допустим и 
следующий вариант: */
using namespace myth;
cin >> fetch; // в действительности это std::cin и Jill::fetch
/* Директива using является транзитивной. Считается, что операция ор
транзитивна, если из выражений А ор В и В ор С следует А ор С. Например, 
операция > обладает свойством транзитивности. (Иначе говоря, из того, 
что А больше В и В больше С, следует, что А больше С.) Это означает, что 
выполнение приведенного ниже оператора приводит к помещению пространств 
имен myth и elements в область видимости: */
using namespace myth;
/* Эта единственная директива имеет такой же эффект, что и следующие 
две директивы: */
using namespace myth;
using namespace elements;
/* Для пространства имен можно создать псевдоним. Предположим, что 
имеется пространство имен, определенное так: */
namespace my_very_favorite_things { ... } ;
/* Ниже показано, как сделать имя mvft псевдонимом для 
my_very_favorite_things: */
namespace mvft = my_very_favorite_things;
/* Этот же прием можно применить для упрощения работы с вложенными 
пространствами имен: */
namespace MEF = myth::elements::fire;
using MEF::flame;
/*	Для создания неименованного пространства имен необходимо опустить 
идентификатор после ключевого слова namespace: */
namespace // неименованное пространство имен
{
	int ice;
	int bandycoot;
}
/* Результат этих объявлений будет таким же, как если бы за ними следовала 
директива using. Идентификаторы из неименованного пространства имен нельзя 
использовать нигде, кроме файла, содержащего объявление этого пространства 
имен. */
static int counts; // статическая переменная, внутреннее связывание
int other;
int main ()
{
	...
}
int other()
{
	...
}
// С использованием пространств имен этот код можно переписать так:
namespace
{
	int counts; // статическая переменная, внутреннее связывание
}
int other();
int main()
{
	...
}
int other()
{
	...
}
/* Если функция была перегружена, одно объявление using обеспечит 
импортирование всех ее версий.
	Пространства имен и будущее.
• Используйте переменные в именованных пространствах имен вместо внешних
глобальных переменных.
• Используйте переменные в неименованных пространствах имен вместо 
статических глобальных переменных.
• Если вы разработали библиотеку функций или классов, поместите ее в 
пространство имен. Современный язык C++ уже требует помещения стандартных
библиотечных функций в пространство имен std. Это же распространяется и
на функции, унаследованные из С. Например, заголовочный файл math, с, 
который совместим с языком С, не использует пространства имен, но заголовочный
файл cmath языка C++ предусматривает помещение различных математических
функций в пространство имен std.
• Используйте директиву using только в качестве временного средства адаптации
устаревшего кода к использованию пространств имен.
• Не применяйте директивы using в заголовочных файлах. Прежде всего, этот
прием скрывает имена, которые сделаны доступными. Кроме того, порядок 
следования заголовочных файлов может влиять на поведение программы. Если вы
используете директиву using, помещайте ее после всех директив 
препроцессора #include.
• Для импорта имен отдавайте предпочтение операции разрешения контекста
или объявлению using.
• Для объявлений using отдавайте предпочтение локальной, а не глобальной 
области видимости.
 Заголовочные файлы старого стиля, такие как iostream.h, не работают с 
пространствами имен, а новый заголовочный файл iostream предусматривает 
использование пространства имен std.