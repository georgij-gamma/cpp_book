/* Использование членов класса, которые сами представляют собой объекты другого 
класса — называется включением (containment), или композицией (composition), 
или иерархическим представлением (layering). Включение, закрытое (private) 
наследование и защищенное (protected) наследование обычно используются для 
создания отношений содержит - когда вновь создаваемый класс содержит в себе 
объект другого, уже существующего класса. Шаблоны классов — еще один способ 
повторного использования кода.
	Классы с объектами-членами.
  Класс valarray:
 Класс valarray поддерживается заголовочным файлом valaray и предназначен для 
работы с числовыми значениями (или с классами с аналогичными свойствами). Он
поддерживает операции суммирования содержимого массива и поиск максимального
и минимального значений в массиве. Поскольку класс valarray может работать с 
данными различных типов, он определен как шаблонный класс. При объявлении 
объекта на основе шаблона необходимо указать его конкретный тип: */
valarray<int> q_values;					// массив значений int
valarray<double> weights;				// массив значений double
double gpa[5] = {3.1, 3.5, 3.8, 2.9, 3.3};
valarray<double> v1;						// массив элементов double, размер 0
valarray<int> v2(8);						// массив из 8 элементов int
valarray<int> v3(10, 8);					// массив из 8 элементов int, и каждый равен 10
valarray<double> v4(gpa, 4);				// массив из 4 элементов, равных первым 4 элементам массива gpa
/* Можно создать пустой массив нулевого размера, пустой массив заданного размера, 
массив, всем элементам которого присвоены одинаковые значения, и массив, 
инициализированный значениями из обычного массива. Кроме того, в С++11 можно 
применять списки инициализаторов: */
valarray<int> v5 = {20, 32, 17, 9}; // С++11
/* Ниже описаны некоторые методы класса valarray:
• operator[]() — обеспечивает доступ к отдельным элементам;
• size() — возвращает количество элементов;
• sum()  — возвращает сумму значений элементов;
• max()  — возвращает максимальный элемент;
• min()  — возвращает минимальный элемент.
  Проект класса student.
 В классе Student планируется использовать объект string для представления 
имени и объект valarray<double> для хранения набора оценок. Может возникнуть 
желание породить класс Student от этих двух классов. Это было бы примером 
множественного открытого наследования, возможного в C++, но в данном случае 
это неприемлемо. Дело в том, что отношение класса Student с этими классами
не соответствует модели является. Студент — это не имя и не массив оценок. 
Здесь мы имеем дело с отношением содержит (containment). У студента есть имя, 
и у студента есть набор оценок. Обычно для моделирования отношений содержит в 
C++ используется композиция или включение, когда класс содержит члены, 
являющиеся объектами других классов. Например: */
class Student
{
private:
	string name;			 // используется объект string для имени
	valarray<double> scores;	 // используется объект valarray<double> для оценок
	...
}
/* Класс Student содержит реализацию своих объектов-членов, но не наследует их 
интерфейс. Например, объект Student использует для представления имени реализацию 
string, а не char * name или char name[26]. Однако объект Student не может 
изначально использовать функцию string operator+=() для добавления символов.
При открытом наследовании класс наследует интерфейс и, возможно, реализацию(Чистые
виртуальные функции базового класса могут предоставлять интерфейс без реализации.)
Наличие интерфейса характерно для отношения является. А при композиции класс имеет
реализацию без интерфейса. Отсутствие наследования интерфейса характерно для 
отношения содержит.
 То, что объект класса автоматически не получает интерфейс включаемого объекта, 
полезно для отношения содержит. Например, класс string перегружает операцию
+ для конкатенации двух строк, но выполнять конкатенацию двух объектов Student
бессмысленно. Поэтому в данном случае не имеет смысла использовать открытое 
наследование. Правда, часть интерфейса наследуемого класса может пригодиться и в 
новом классе. Например, можно использовать метод operator<() из интерфейса класса
string для сортировки объектов Student по имени. Для этого потребуется определить 
функцию-член Student::operator<(), внутри которой вызывается функция
string::operator<(). */
// studentc.h -- определение класса Student с использованием включения
#ifndef _STUDENT_H_
#define _STUDENT_H_

#include <iostream>
#include <string>   
#include <valarray>
class Student
{   
private:
    typedef std::valarray<double> ArrayDb;
    std::string name;                       // включенный объект
    ArrayDb scores;                         // включенный объект
    // Закрытый метод для вывода оценок
    std::ostream & arr_out(std::ostream & os) const;
public:
// Для объектов-членов в списке инициализаторов членов конструкторы используют имя члена:
    Student() : name("Null Student"), scores() {}
/* Конструктор, который можно вызвать с одним аргументом, работает как функция неявного 
преобразования типа аргумента в тип класса. Такое поведение нежелательно. */
    // Указание ключевого слова explicit отключает неявное преобразование:
    explicit Student(const std::string & s)             : name(s),       scores()      {}
    explicit Student(int n)                             : name("Nully"), scores(n)     {}
    Student(const std::string & s, int n)               : name(s),       scores(n)     {}
    Student(const std::string & s, const ArrayDb & a)   : name(s),       scores(a)     {}
// name(str) и scores(pd, n) вызывают конструкторы:  string(const char *), valarray<double>(const double *, int)
    Student(const char * str, const double * pd, int n) : name(str),     scores(pd, n) {}
    ~Student() {}
    double Average() const;
    const std::string & Name() const;
    double & operator[](int i);
    double   operator[](int i) const;
// Друзья
    // Ввод
    friend std::istream & operator>>(std::istream & is, Student & stu);     // 1 слово
    friend std::istream & getline   (std::istream & is, Student & stu);     // 1 строка
    // Вывод
    friend std::ostream & operator<<(std::ostream & os, const Student & stu);
};
#endif
/*  Инициализация включенных объектов.
Инициализация членов встроенных типов, например: */
Queue::Queue(int qs) : qsize(qs) {...} // инициализация qsize значением qs
/* Для унаследованных объектов конструкторы используют в списке инициализаторов
членов имя класса, чтобы вызвать конкретный конструктор базового класса. Список 
инициализаторов членов для инициализации порции производного объекта, которая 
взята из базового класса, например: */
hasDMA::hasDMA(const hasDMA & hs) : baseDMA(hs) {...}
// Для объектов-членов в списке инициализаторов членов конструкторы используют имя члена:
Student(const char * str, const double * pd, int n) : name(str), scores(pd, n) {}
/* Каждый элемент в списке инициализации вызывает соответствующий конструктор. Так, элемент
name(str) вызывает конструктор string(const char *), а элемент scores(pd, n)
вызывает конструктор ArrayDb (const double *, int), который в силу определения
typedef на самом деле является таким конструктором: */
valarray <double>(const double *, int)
/* В C++ все объекты-члены унаследованных компонентов должны быть созданы до того, 
как будут созданы все остальные объекты. Значит, без списка инициализаторов C++ 
использует конструктор по умолчанию, определенный для классов объектов-членов.
При наличии более одного объекта в списке инициализаторов эти объекты инициализируются 
в том порядке, в котором они объявлены, а не в порядке, в котором они содержатся в 
списке инициализаторов. Например: */
Student(const char * str, const double * pd, int n) : scores(pd, n), name(str) {}
/* Член name будет инициализирован первым, поскольку он объявлен первым в определении
класса. В данном случае точный порядок инициализации не важен, однако он будет 
существенным, если в коде значение одного члена используется в составе выражения для 
инициализации другого члена.
  Использование интерфейса для включенного объекта.
Интерфейс для включенных объектов не является открытым, но его можно 
использовать внутри методов класса. Например, вот как определить функцию, 
возвращающую среднее значение оценок студента: */
double Student::Average()const					// вызов метода Student
{
	if (scores.size() > 0)						// вызов метода valarray
		return scores.sum() / scores.size();		// вызов методов valarray
	else
		return 0;
}
/* Аналогично можно определить дружественную функцию, которая пользуется 
версией операции << из класса string: */
// Использование версии операции << из класса string
ostream & operator<<(ostream & os, const Student & stu)
{
	os << "Scores for " << stu.name << ":\n";
	...
}
/* Поскольку член stu.name является объектом string, он вызывает функцию
operator<<(ostream &, const strings), являющуюся частью пакета класса string.
Функция operator<<(ostream & os, const Student & stu) должна быть дружественной 
классу Student, чтобы иметь доступ к члену name. (Но можно использовать 
открытый метод Name(), а не закрытый член name.) */
const string & Student::Name() const
{
    return name;
}
/* Аналогично в функции можно было бы применять valarray-реализацию операции<< 
для вывода — правда, ее нет. Поэтому для решения данной задачи в классе 
определен закрытый вспомогательный метод: */
ostream & Student::arr_out(ostream & os) const
{
    int i;
    int lim = scores.size();
    if (lim > 0)
    {
        for (i = 0; i < lim; i++)
        {
            os << scores[i] << " ";
            if (i % 5 == 4)
                os << endl;
        }
        if (i % 5 != 0)
            os << endl;
    }
    else
        os << " empty array ";
    return os; 
}
/* Использование такой вспомогательной функции собирает в одном месте разбросанные 
фрагменты кода и делает код дружественной функции более аккуратным: */
ostream & operator<<(ostream & os, const Student & stu)
{
    os << "Scores for " << stu.name << ":\n";
    stu.arr_out(os);			// использование закрытого метода для scores
    return os;
}
// Использует версию getline(ostream &, const string &) из класса string:
istream & getline(istream & is, Student & stu)
{
    getline(is, stu.name);
    return is;
}
/*	Закрытое наследование.
В C++ имеется и другое средство реализации отношений содержит — закрытое 
наследование. При использовании закрытого наследования открытые (public) и 
защищенные (protected) члены базового класса становятся закрытыми членами 
производного класса — т.е. методы базового класса не переходят в открытый 
интерфейс производного объекта. Однако они могут использоваться внутри 
функций-членов производного класса. При закрытом наследовании класс наследует 
реализацию. Например, если базовым классом для класса Student является класс 
string, класс Student будет содержать компонент унаследованного класса string, 
который можно использовать для хранения строк. А методы класса Student могут 
использовать методы класса string для внутреннего доступа к компоненту string.
Включение добавляет в класс именованный объект-член, а закрытое наследование
добавляет в класс неименованный унаследованный объект. Для обозначения объектов, 
добавленных путем наследования или включения, используется термин подобъект.
 Закрытое наследование обеспечивает те же свойства, что и включение —
реализацию, но не интерфейс. Поэтому его также можно использовать для реализации
отношения содержит.
  Новый вариант класса student.
 Для получения закрытого интерфейса при определении класса необходимо 
использовать ключевое слово private вместо public. (private принимается по 
умолчанию, поэтому отсутствие квалификатора доступа также приведет к закрытому 
наследованию.) Класс Student должен наследовать два класса, поэтому в объявлении 
класса Student следует указать их оба: */
class Student : private std::string, private std::valarray<double>
{
public:
	...
};
/* Наследование от нескольких базовых классов называется множественным 
наследованием. В новом классе не нужны собственные закрытые данные, поскольку оба 
наследуемых базовых класса содержат все необходимые данные-члены. Версия 
примера с включением содержит в качестве членов два явно именованных объекта name и 
score, а версия с закрытым наследованием содержит в качестве унаследованных членов два 
неименованных подобъекта std::string(str), std::valarray<double>. Это первое из главных 
отличий между двумя рассматриваемыми подходами.
  Инициализация компонентов базового класса.
 Наличие неявно унаследованных компонентов вместо объектов-членов влияет на кодирование 
этого примера, поскольку для описания объекта уже нельзя использовать идентификаторы 
name и score. Вместо этого придется вернуться к технологии, применяемой при открытом 
наследовании. В новой версии примера для наследуемых классов должен использоваться 
список инициализаторов членов, в котором для указания конструктора вместо имени члена
применяется имя класса: */					// используются имена классов для наследования:
Student(const char * str, const double * pd, int n) : std::string(str), ArrayDb(pd, n) {}
/* ArrayDb — это typedef для std::valarray<double>.
Единственным отличием между включением и закрытым наследованием является отсутствие 
явно указанных имен объектов и применение имен классов вместо имен членов во 
встроенных конструкторах.
  Доступ к методам базового класса.
 Закрытое наследование позволяет использовать методы базового класса только
внутри методов производного класса. Но иногда необходимо обращаться к методам
базового класса извне. Например, объявление класса Student предполагает 
возможность вызова функции Average().*/
double Student::Average() const
{ /* наследование позволяет применять имя класса и операцию разрешения контекста 
	для вызова методов базовых классов: */
    if (std::valarray<double>::size() > 0)
        return std::valarray<double>::sum() / std::valarray<double>::size();
	...
}
Объект Student
	Объект string
		string::size() /* Доступ с областью видимости класса Student через
открытые методы класса string, вызываемые операцией разрешения контекста. */
	Объект valarray<double>
		valarray<double>::sum() /* Доступ с областью видимости класса Student
через открытые методы класса valarray<double>, вызываемые операцией разрешения контекста.
  Доступ к объектам базового класса.
Операция разрешения контекста позволяет обращаться к методам базового класса.
А что если нужен доступ к самому объекту базового класса? Например, в версии класса
Student с включением метод Name() возвращает член name объекта string. Но при
закрытом наследовании у объекта string нет имени. Как же код класса Student 
может обратиться к внутреннему объекту string? Решением служит приведение типов.
Тип Student порожден от string, поэтому объект Student можно привести к типу string.
Вспомните, что указатель this указывает на вызвавший объект. Тогда *this является 
самим вызвавшим объектом, в данном случае — объектом Student. Чтобы не вызывать 
конструкторы для создания новых объектов, необходимо использовать приведение типа 
для создания ссылок: */
const string & Student::Name() const
{
	return (const string &) *this;
} /* Возвращает ссылку на унаследованный объект string, который 
находится в вызывающем объекте Student.
  Доступ к друзьям базового класса.
 Явное указание имени функции с именем ее класса не работает для дружественных
функций, т.к. дружественная функция не принадлежит этому классу. Но для корректного 
вызова функций можно использовать явное приведение типа к базовому классу. В принципе, 
это та же техника, что и при доступе к объектам базового класса в методах класса. Но 
в случае с друзьями доступно имя объекта Student, поэтому вместо *this в коде 
используется имя объекта. Например: */
ostream & operator<<(ostream & os, const Student & stu)
{
	os << "Scores for " << (const string &) stu << ":\n";
    stu.arr_out(os);  // использование закрытого метода для scores
    return os;
}
/*Если plato — объект типа Student, то показанный ниже оператор вызывает эту
функцию, где stu — ссылка на plato, a os — ссылка на cout: */
cout << plato;
// Следующая строка кода:
os << "Scores for " << (const string &) stu << ":\n";
/* Приведение типа явно преобразует stu в ссылку на объект типа string, а этот тип
вызывает функцию operator<<(ostream &, const string &). Ссылка stu не преобразуется 
автоматически в ссылку на string, поскольку при закрытом наследовании ссылке или 
указателю на базовый класс нельзя присвоить ссылку или указатель на производный 
класс без явного приведения типа. Однако даже при открытом наследовании нужно иметь
явные приведения типов. Одна из причин состоит в том, что без приведения код вроде 
показанного ниже соответствует прототипу дружественной функции, что приводит к 
рекурсивному вызову: */
os << stu;
/* Ещё одна причина: поскольку класс использует множественное наследование, 
компилятор не может определить, в какой базовый класс выполнять преобразование, 
т.к. оба базовых класса поддерживают функцию operator<<(). */
// Использует версию operator>>() из класса string
istream & operator>>(istream & is, Student & stu)
{
    is >> (string &)stu;
    return is;
}
/*  Включение или закрытое наследование?
 Включение проще проследить: в определении класса четко видны явно именованные объекты, 
которые представляют содержащиеся классы, и к этим объектам можно обращаться по именам. 
При наследовании же отношение выглядит более абстрактно. Во-вторых, наследование может 
приводить к трудностям, особенно, если класс наследуется от нескольких базовых классов. 
Может случиться так, что разные базовые классы содержат методы с одинаковыми именами,
или у разных базовых классов общий предок. В общем, при использовании включения меньше 
вероятность столкнуться с проблемами. Включение позволяет иметь несколько подобъектов 
с одинаковыми именами. Если в классе нужны три объекта string, то с помощью включения 
можно определить три отдельных члена string. А наследование позволяет иметь только 
один объект — трудно различить объекты, у которых нет имени.
 Однако у закрытого наследования есть возможности, недостижимые при 
включении. Предположим, что класс содержит защищенные члены, которые могут быть
данными или функциями. Такие члены доступны для производных классов, но не для
всего мира. Если включить этот класс в другой класс с помощью композиции, новый
класс будет как раз частью всего мира, а не наследником, и поэтому не будет иметь
доступ к защищенным членам. Но если использовать наследование, то новый класс
будет наследником, а значит, сможет обращаться к защищенным членам.
Еще одна ситуация, в которой удобно закрытое наследование — переопределение
виртуальных функций. Это привилегия производных, а не содержащих классов. При
закрытом наследовании переопределенные функции могут применяться только внутри класса.
 В общем случае для создания отношения содержит нужно использовать включение. Если же
новому классу нужен доступ к защищенным членам базовых классов или требуется 
переопределить виртуальную функцию, необходимо закрытое наследование.
	Защищенное наследование.
 Защищенное наследование —
это разновидность закрытого наследования. В этом
случае при объявлении базового класса указывается ключевое слово protected: */
class Student : protected std::string, protected std::valarray<double>
{...};
/* При защищенном наследовании открытые и защищенные члены базового класса становятся 
защищенными членами производного класса. Как и при закрытом наследовании, интерфейс 
базового класса доступен в производном классе, но не доступен внешнему миру. Главное 
отличие между защищенным и закрытым наследованием проявляется при порождении от класса, 
который сам является производным классом. При закрытом наследовании класс третьего 
поколения не получает доступа к интерфейсу базовых классов. Это происходит потому, 
что открытые методы базового класса становятся закрытыми в производном классе, и 
доступ к закрытым членам и методам из следующего уровня наследования невозможен. 
При защищенном наследовании открытые методы базового класса становятся защищенными 
членами производного класса и доступны внутри классов следующего уровня наследования.
 Выражение неявное восходящее приведение означает, что указатель или ссылка на базовый 
класс может ссылаться на объект производного класса без явного приведения типа.
  Переопределение доступа с помощью using.
 При защищенном или закрытом порождении открытые члены базового класса
становятся защищенными или закрытыми. Предположим, что нужно создать какой-
то метод базового класса, открытый в производном классе. Одна из возможностей —
определить метод производного класса, использующий метод базового класса. Пусть,
например, нужно, чтобы класс Student мог использовать метод sum() из valarray.
Можно объявить в определении класса метод sum(), а затем определить его 
следующим образом: */
double Student::sum() const 				// открытый метод Student
{
	return std::valarray<double>::sum(); // использует закрытый унаследованный метод
} 
/* Тогда объект Student может вызывать метод Student::sum(), который, в свою
очередь, применяет метод valarray<double>::sum() к встроенному объекту valarray.
Вместо упаковки одной функции в другую можно использовать другой способ —
объявление using, согласно которому конкретный метод базового класса может 
использоваться производным классом, даже если наследование является закрытым.
Предположим, что необходимо применять методы min() и max() из класса valarray 
с классом Student. В этом случае в раздел public файла studenti.h можно 
добавить объявление using: */
class Student : private std::string, private std::valarray<double>
{
public:
	using std::valarray<double>::min;
	using std::valarray<double>::max;
};
/* Объявление using делает методы valarray<double>::min() и valarray<double>::max() 
доступными, как будто это открытые методы класса Student: */
cout << "high score: " << ada[i].max() << endl;
/* Обратите внимание, что объявление using использует только имя члена — без
скобок, сигнатуры функции и возвращаемого типа. Например, чтобы сделать метод
operator[]() из valarray доступным в классе Student, нужно поместить в раздел
private определения класса Student такое объявление using: */
using std::valarray<double>::operator[];
/* После этого будут доступны обе версии — с квалификатором const и без него. Затем
можно удалить существующие прототипы и определения для Student::operator[]().
 Объявление using работает только в случае наследования и не работает при технике
включения. Есть более старый способ переопределения методов базового класса в 
классе, порожденном с помощью закрытого наследования — нужно поместить имя метода
в разделе public класса-наследника, например: */
class Student : private std::string, private std::valarray<double>
{
public:
	std::valarray<double>::operator[]; // переопределен как открытый, достаточно указать имя
};
/* Это похоже на объявление using, но без ключевого слова using. Применять 
такой подход не рекомендуется, поскольку он считается устаревшим.
	Множественное наследование.
Множественное наследование описывает класс, у которого есть несколько базовых
классов. Подобно одиночному наследованию, открытое множественное наследование
выражает отношение является. Например, если имеются классы Waiter и Singer, то
от них можно породить класс SingingWaiter: */
class SingingWaiter : public Waiter, public Singer {...};
/* Оба базовых класса должны сопровождаться ключевым словом public,
т.к. по умолчанию компилятор подразумевает закрытое наследование: */
class SingingWaiter : public Waiter, Singer {...}; // Singer считается закрытым базовым классом
/* Множественное наследование может привнести новые проблемы при программировании —
наследование разных методов с одинаковыми именами от разных базовых классов и 
наследование нескольких экземпляров класса от нескольких взаимосвязанных базовых 
классов. Для устранения этих проблем введены новые правила и варианты синтаксиса. 
Таким образом, использование множественного наследования может оказаться более 
сложным и предрасположенным к проблемам, чем одиночное наследование. */
// worker0.h  -- working classes
#ifndef _WORKER0_H_
#define _WORKER0_H_
#include <string>

class Worker                                // работник — абстрактный базовый класс
{
private:
    std::string fullname;
    long id;
public:
    Worker()                                             : fullname("no one"), id(0L) {}
    Worker(const std::string & s, long n)                : fullname(s),        id(n)  {}
    virtual ~Worker() = 0;                  // чистый виртуальный деструктор
    virtual void Set();
    virtual void Show() const;
};
class Waiter : public Worker                // официант
{
private:
    int panache;
public:
    Waiter()                                             : Worker(),       panache(0) {}
    Waiter(const std::string & s, long n, int p = 0)     : Worker(s, n),   panache(p) {}
    Waiter(const Worker & wk, int p = 0)                 : Worker(wk),     panache(p) {}
    void Set();
    void Show() const;
};
class Singer : public Worker                // певец
{
protected: // ряд внутренних констант, представляющих виды голоса:
    enum {other, alto, contralto, soprano, bass, baritone, tenor};
    enum {Vtypes = 7};
private:
    static char * pv[Vtypes];               // строковые эквиваленты видов голоса
    int voice;
public:
    Singer()                                             : Worker(),     voice(other) {}
    Singer(const std::string & s, long n, int v = other) : Worker(s, n),     voice(v) {}
    Singer(const Worker & wk, int v = other)             : Worker(wk),       voice(v) {}
    void Set();
    void Show() const;
};
#endif
/* Объявления классов включают ряд внутренних констант, представляющих виды голоса. 
Перечисление определяет символические константы alto, contralto и т.д., а в статическом 
массиве рѵ хранятся указатели на строковые эквиваленты в стиле С. В файле реализации, 
осуществляется инициализация этого массива и содержатся определения методов. */
// Методы Singer:
char * Singer::pv[] = {"other", "alto", "contralto",    // указатели на строковые эквиваленты в стиле С
            "soprano", "bass", "baritone", "tenor"};
void Singer::Set()
{
    Worker::Set();
    cout << "Enter number for singer's vocal range:\n"; // Ввод номера вокального диапазона певца
    int i;
    for (i = 0; i < Vtypes; i++)
    {
        cout << i << ": " << pv[i] << "   ";
        if ( i % 4 == 3)
            cout << endl;
    }
    if (i % 4 != 0)
        cout   << endl;
    while (cin >>  voice && (voice < 0 || voice >= Vtypes))
        cout   << "Please enter a value >= 0 and < " << Vtypes << endl;
    while (cin.get() != '\n')
        continue;
}
// worktest.cpp -- тестирование иерархии классов сотрудников:
#include <iostream>
#include "worker0.h"
const int LIM = 4;
int main()
{
    Waiter bob("Bob Apple", 314L, 5);
    Singer bev("Beverly Hills", 522L, 3);
    Waiter w_temp;
    Singer s_temp;

    Worker * pw[LIM] = {&bob, &bev, &w_temp, &s_temp};

    int i;
    for (i = 2; i < LIM; i++)
        pw[i]->Set();
    for (i = 0; i < LIM; i++)
    {
        pw[i]->Show();
        std::cout << std::endl;
    }
    return 0;
}
/* Вроде бы все работает: указатели на Waiter вызывают Waiter::Show() и
Waiter::Set(), а указатели на Singer-Singer::Show() и Singer::Set(). Тем не 
менее, трудности возникают, если нужно добавить класс SingingWaiter, порожденный
от двух классов Singer и Waiter.
  Сколько всего сотрудников?
Начнем с открытого наследования SingingWaiter от классов Singer и Waiter: */
class SingingWaiter : public Singer, public Waiter {...};
/* Поскольку и Singer, и Waiter наследуют компонент Worker, то SingingWaiter
будет иметь два компонента Worker: */
class Singer 		: public Worker {...};
class Waiter 		: public Worker {...};
class SingingWaiter : public Singer, public Waiter {...};
// Объект SingingWaiter наследует два объекта Worker:
Объект SingingWaiter
{
	Подобъект Singer
	{
		Подобъект Worker
		{
			fullname
			id
		}
		pv[Vtypes]
		voice
	}
	Подобъект Waiter
	{
		Пoдoбъeкт Worker
		{
			fullname
			id
		}
		panache
	}
}
/* В обычной ситуации указателю на базовый класс можно присвоить адрес объекта 
производного класса, но теперь эта операция неоднозначна: */
SingingWaiter ed;
Worker * pw = &ed;	// неоднозначность
/* Обычно такое присваивание заносит в указатель на базовый класс адрес объекта
базового класса внутри производного объекта. Но ed содержит два объекта Worker,
из которых нужно выбрать один. Конкретный объект можно указать с помощью 
приведения типа: */
Worker * pw1 = (Waiter *) &ed;	// Worker из Waiter
Worker * pw2 = (Singer *) &ed;	// Worker из Singer
/* Это, безусловно, усложняет использование массива указателей на базовый класс
для ссылок на множество объектов (полиморфизм). С введением множественного наследования 
в C++ появились виртуальные базовые классы, делающие такое наследование возможным.
  Виртуальные базовые классы.
 Виртуальные базовые классы позволяют объекту, порожденному от нескольких 
базовых классов, которые сами имеют общий базовый класс, наследовать только один
объект от этого базового класса. Например, можно сделать класс Worker виртуальным
базовым классом для Singer и Waiter, указав в определениях класса ключевое слово
virtual (virtual и public можно использовать в любом порядке): */
class Singer : virtual public Worker {...};
class Waiter : public virtual Worker {...};
// Затем необходимо определить SingingWaiter, как и раньше:
class SingingWaiter : public Singer, public Waiter {...};
/* Теперь объект SingingWaiter будет содержать лишь одну копию объекта Worker,
а производные объекты Singer и Waiter будут иметь один общий базовый объект
Worker вместо двух его копий. Поскольку объект SingingWaiter теперь
содержит один нодобъект Worker, можно снова использовать полиморфизм. */
// Объект SingingWaiter наследует один объект Worker:
Объект SingingWaiter
{
	Подобъект Worker
	{
		fullname
		id
	}
	Подобъект Singer
	{
		pv[Vtypes]
		voice
	}
	Подобъект Waiter
	{
		panache
	}
}
/* В C++ ключевое слово virtual в виртуальных базовых классах используется для 
новой возможности — это "перегрузка" ключевого слова. Почему нельзя обойтись без 
определения базовых классов виртуальными и сделать виртуальное поведение нормой 
для множественного наследования? Во-первых, бывают случаи, когда нужно иметь 
несколько копий базового класса. Во-вторых, если сделать базовые классы виртуальными, 
программа будет выполнять дополнительную работу — а зачем платить за то, что Вам не 
нужно?
 При добавлении класса SingingWaiter в иерархию класса Worker придется вернуться 
назад и добавить ключевое слово virtual в определения классов Singer и Waiter.
  Новые правила для конструкторов.
 При использовании невиртуальных базовых классов в списке инициализации могут 
присутствовать только конструкторы непосредственных базовых классов.
Однако эти конструкторы, в свою очередь, могут передавать информацию своим 
базовым классам. Например, возможна следующая организация конструкторов: */
class A
{
	int а;
public:
	A(int n = 0) : a(n) {}
	...
};
class B : public A
{
	int b;
public:
	B(int m = 0, int n = 0) : A(n), b(m) {}
	...
};
class С : public В
{
	int с;
public:
	С(int q = 0, int m = 0, int n = 0) : В(m, n), c(q) {}
	...
};
/* Конструктор класса С может вызывать только конструкторы класса В, а конструктор 
В может вызывать только конструкторы из класса А. В примере конструктор С 
использует значение q и передает значения тип обратно конструктору В. Конструктор
В использует значение m и передает значение п конструктору А. Но если Worker будет 
виртуальным базовым классом, автоматическая передача информации работать не будет. 
Рассмотрим, следующий конструктор для случая множественного наследования: */
SingingWaiter(const Worker & wk, int p = 0, int v = Singer::other)
			 : Waiter(wk,p), Singer(wk,v) {}		// неверно
/* Проблема в том, что в данном случае wk автоматически передается в объект
Worker двумя разными путями (через Waiter и Singer). Для устранения возможного
конфликта C++ отключает автоматическую передачу информации через промежуточный 
класс в базовый класс, если он виртуальный. Поэтому вышеприведенный конструктор 
инициализирует члены panache и voice, однако аргумент wk не будет передан в 
подобъект Waiter. Однако компилятор должен создать компонент базового объекта
перед созданием производных компонентов — в данном случае он будет использовать
конструктор по умолчанию Worker. Если для создания виртуального базового класса 
нужен конструктор не по умолчанию, придется явно вызывать соответствующий 
базовый конструктор: */
SingingWaiter(const Worker & wk, int p = 0, int v = Singer::other)
			 : Worker(wk), Waiter (wk,p), Singer(wk,v) {}
/* Здесь явно вызывается конструктор Worker (const Worker & ). Такое использование 
допустимо, а зачастую и необходимо, для виртуальных базовых классов, но ошибочно 
для невиртуальных базовых классов. Если у класса есть непрямой виртуальный базовый 
класс, конструктор этого класса должен явно вызывать конструктор виртуального 
базового класса, за исключением случаев, когда достаточно конструктора по умолчанию 
виртуального базового класса.
  Какой метод использовать?
 Рассмотрим задачу расширения метода Show() для класса SingingWaiter. Предположим,
что новой версии Show() нет, и попытаемся использовать объект SingingWaiter для
вызова унаследованного метода Show(): */
SingingWaiter newhire("Elise Hawks", 2005, 6, soprano);
newhire.Show();		// неоднозначность
/* При одиночном наследовании отсутствие переопределения функции Show() 
приводит к использованию самого последнего наследственного определения этой 
функции. Но в данном случае у каждого прямого предка имеется метод Show(), что делает
этот вызов неоднозначным. Множественное наследование может приводить к неоднозначным 
вызовам функций. Для ясности можно применить операцию разрешения контекста: */
SingingWaiter newhire("Elise Hawks", 2005, 6, soprano);
newhire.Singer::Show();		// использование версии Singer
/* Но лучше переопределить в классе SingingWaiter метод Show(), указав, какую
версию Show() следует использовать. Например, если нужно, чтобы SingingWaiter
пользовался версией из Singer, можно сделать так: */
void SingingWaiter::Show()
{
	Singer::Show();
}
/* Такой способ вызова базового метода из производного метода нормально работает 
для одиночного наследования. Предположим, например, что от класса Waiter(Официант) 
порожден класс HeadWaiter(Старший официант). Можно использовать следующую 
последовательность определений, где каждый производный класс добавляет к информации 
базового класса вывод своей дополнительной информации: */
void Worker::Show() const
{
	cout << "Name: " << fullname << "\n";
	cout << "Employee ID: " << id << "\n";
}
void Waiter::Show() const
{
	Worker::Show();
	cout << "Panache rating: " << panache << "\n";
}
void HeadWaiter::Show() const
{
	Waiter::Show();
	cout << "Presence rating: " << presence << "\n";
}
/* Но для SingingWaiter такой способ не сработает. Показанный метод даст сбой,
поскольку он игнорирует компонент Waiter: */
void SingingWaiter::Show()
{
	Singer::Show();
}
// Это можно исправить, вызвав еще и версию из Waiter:
void SingingWaiter::Show()
{
	Singer::Show();
	Waiter::Show();
}
/* Но тогда имя и идентификатор сотрудника будут выведены дважды, т.к. и
Singer::Show(), и Waiter::Show() вызывают Worker::Show(). Как исправить положение?
Один из способов — воспользоваться модульным подходом вместо инкрементного. То 
есть нужно определить метод, выводящий только компоненты Worker, затем метод, 
выводящий только компоненты Waiter (вместо компонентов Waiter плюс Worker), и, 
наконец, метод, выводящий компоненты Singer. Потом необходимо собрать эти 
компоненты вместе в методе SingingWaiter::Show(). */
void Worker::Data() const
{
	cout << "Name: "	<< fullname  << "\n";
	cout << "Employee ID: " << id << "\n";
}
void Waiter::Data() const
{
	cout << "Panache rating: " << panache << "\n";
}
void Singer::Data() const
{
	cout << "Vocal range: " << pv[voice] << "\n";
}
void SingingWaiter::Data() const
{
	Singer::Data();
	Waiter::Data();
}
void SingingWaiter::Show() const
{
	cout << "Category: singing waiter\n";
	Worker::Data();
	Data();
}
/* Аналогично можно построить и другие методы Show() из соответствующих 
компонентов Data(). При таком подходе объекты по-прежнему вызывают метод Show() 
открытым образом. Но методы Data() должны быть внутренними в классах — т.е. 
вспомогательными методами, обеспечивающими открытый интерфейс. Однако если сделать 
методы Data() закрытыми, то вызов Worker::Data() из кода Waiter будет невозможным.
Это как раз одна из ситуаций, где могут пригодиться защищенные классы. Если 
методы Data() являются защищенными, их можно использовать внутри всех классов
иерархии, но извне они будут недоступны. Другой способ — сделать не закрытыми, 
а защищенными все компоненты данных. Однако использование защищенных методов 
вместо защищенных данных позволяет более точно управлять доступом к данным.
Методы Set(), запрашивающие данные для установки значений объекта, представляют 
похожую проблему. Например, вызов SingingWaiter::Set() должен запрашивать 
информацию для объекта Worker один раз, а не два. Такое же решение необходимо 
и для Show(). Можно определить защищенные методы Get(), которые запрашивают 
информацию только для одного класса, а затем объединить методы Set(), использующие 
методы Get() в качестве строительных блоков. Итак, введение множественного 
наследования с общим предком требует построения виртуальных базовых классов, 
изменения правил для списков инициализации в конструкторах и, возможно, переделки 
классов, если они написаны с учетом множественного наследования.
 Функция strchr() из библиотеки работы со строкам в стиле С: */
while (strchr("wstq", choice) == NULL)
/* Эта функция возвращает адрес первого вхождения символа choice в строку
"wstq" (если символ не найден, возвращается указатель NULL). Такая проверка 
проще, чем оператор if для сравнения с choice каждого символа.*/

/*  Смесь виртуальных и невиртуальных базовых классов.
 Если базовый класс виртуальный, то производный класс содержит один подобъект базового 
класса. Если базовый класс невиртуальный, производный класс содержит несколько 
подобъектов. А если базовые классы смешанные? Например, класс В является виртуальным 
базовым классом для классов С и D, и невиртуальным базовым классом для классов X и Y. 
Предположим также, что класс М порожден от классов С, D, X и Y. В этом случае класс М 
содержит один подобъект класса В для всех виртуальных унаследованных предков (классов 
С и D) и по отдельному под объекту класса В для каждого невиртуального предка (классов 
X и Y). Значит, всего он будет содержать три подобъекта класса В. При наследовании 
одного базового класса несколькими виртуальными и несколькими невиртуальными путями 
производный класс будет содержать один объект базового класса для представления всех 
виртуальных путей и отдельные объекты базового класса для каждого невиртуального пути.
  Виртуальные базовые классы и доминирование.
 Если невиртуальный базовый класс наследует несколько членов (данных или методов) с 
одинаковыми именами от различных классов, указание такого имени без квалификатора класса 
приведет к неоднозначности. Однако если задействованы виртуальные базовые классы, то 
использование имени без квалификатора класса может и не быть неоднозначным. Если одно 
имя доминирует над остальными, его можно применять без квалификатора класса. Имя в 
производном классе доминирует над такими же именами из классов-предков, независимо от
того, родители это или более дальние предки. */
class В
{
public:
	short q();
};
class С : virtual public В
{
public:
	long q();
	int omg();
};
class D : public С {...};
class E : virtual public В
{
private:
	int omg();
};
class F: public D, public E {...};
/* Здесь определение q() из класса С доминирует над таким же определением из класса В, 
поскольку С порожден от В. Значит, методы класса F могут использовать запись q() для 
вызова С::q(). С другой стороны, ни одно определение omg() не может доминировать над 
другими, поскольку ни С, ни Е не являются базовыми классами друг для друга. Поэтому 
попытка использовать в классе F вызов omg() без квалификатора класса приведет к 
неоднозначности. Правила виртуальной неоднозначности не считаются с правилами доступа.
То есть хотя Е::omg() является закрытым и поэтому недоступным непосредственно для 
класса F, запись omg() будет неоднозначной. Аналогично, если даже С::q() будет закрытым,
он будет доминировать над D::q(). В этом случае в классе F возможен вызов В::q(), 
но неуточненный q() будет ссылаться на недоступный метод С::q().
  Обзор множественного наследования.
 Если класс при множественном наследовании без виртуальных базовых классов наследует 
два члена с одинаковыми именами, но от разных классов, то в производном классе для 
различения этих двух членов необходимо использовать квалификаторы класса. Так, 
методы класса BadDude, унаследованные от Gunslinger и PokerPlayer, должны применять 
Gunslinger::draw() и PokerPlayer::draw() для различения методов draw(), унаследованных 
от двух разных классов. Иначе компилятор выдаст сообщение о неоднозначном обращении.
 Если производный класс наследуется от невиртуального базового класса несколькими 
путями, то он наследует по одному объекту базового класса для каждого экземпляра 
базового класса.
 Класс становится виртуальным базовым классом, когда в производном классе
при описании наследования используется ключевое слово virtual: */
class marketing : public virtual reality {...};
/* Главное отличие и причина применения виртуальных базовых классов заключается
в том, что класс, порождаемый от одного или более экземпляров виртуального 
базового класса, наследует только один объект базового класса.
• В производном классе с непрямым виртуальным базовым классом конструкторы
должны непосредственно вызывать конструкторы непрямых базовых классов,
что недопустимо для непрямых виртуальных базовых классов.
• Неоднозначность имен разрешается в соответствии с правилами 
доминирования.
 Сложности возникают тогда, когда производный класс наследуется несколькими путями 
от одного и того же базового класса. Если не ввязываться в такие ситуации, то остается 
лишь при необходимости уточнять унаследованные имена.

	Шаблоны классов.
 Шаблоны предоставляют параметризованные типы — т.е. при создании класса или функции 
можно передать имя типа в качестве аргумента. Передав, к примеру, в шаблон Queue имя
типа int, можно указать компилятору создать класс Queue для хранения в очереди
целых значений.
  Определение шаблона класса. */
typedef unsigned long Item;
class Stack
{
private:
	enum {MAX = 10};				// константа, характерная для класса
	Item items[MAX];				// содержит элементы стека
	int top; 					// индекс вершины стека
public:
	Stack();
	bool isempty() const;
	bool isfull() const;
// push() возвращает false, если стек полон, и true - в противном случае:
bool push(const Item & item);	// добавляет элемент в стек
// pop () возвращает false, если стек пуст, и true - в противном случае:
bool pop(Item & item);			// выталкивает элемент с вершины стека
};
/* При построении шаблона определение класса Stack заменяется определением
шаблона, а функции-члены класса — функциями-членами шаблона. Как и для 
шаблонных функций, шаблонный класс предваряется следующим кодом: */
template <class Type>
/* Ключевое слово template сообщает компилятору, что далее следует определение
шаблона. Часть кода в угловых скобках аналогична списку аргументов в функции.
Можно считать, что ключевое слово class служит именем типа для переменной, 
которая получает тип как значение, а Тип является именем этой переменной.
Слово class не означает, что Тип должно быть классом; это означает только, что
Тип служит в качестве спецификатора обобщенного типа, который будет заменен 
реальным типом при использовании шаблона. Последние реализации C++ позволяют
применять вместо class более точное ключевое слово typename: */
template <typename Type>	// новый вариант
/* При вызове шаблона параметр Тип заменяется конкретным типом вроде int или string.
Внутри определения шаблона имя обобщенного типа можно использовать для указания типа,
который будет храниться в стеке. В случае класса Stack нужно указывать Туре везде,
где в старом определении применялся идентификатор Item из конструкции typedef: */
Item items[MAX];				// содержит элементы стека
// станет выглядеть как:
Type items[MAX];				// содержит элементы стека
/* Аналогично можно заменить методы исходного класса функциями-членами 
шаблона. Каждая функция должна предваряться таким же объявлением шаблона: */
template <class Type>
/* Здесь также необходимо заменить идентификатор Item из конструкции typedef
именем обобщенного типа Туре. Кроме того, квалификатор класса Stack:: нужно 
заменить вариантом Stack<Type>::. Например: */
bool Stack::push(const Item & item)		 {...}
// преобразуется в:
template <class Type>		// или template <typename Type>
bool Stack<Type>::push(const Type & item) {...}
/* Если внутри определения класса определить метод (встроенное определение),
можно опустить преамбулу шаблона и квалификатор класса. Важно понимать, что 
эти шаблоны не являются определениями классов и функций-членов. Это скорее 
указания компилятору C++, как сгенерировать определения класса и функций-членов.
Конкретная актуализация шаблона — например, класс стека для управления объектами
string — называется созданием экземпляра или специализацией. Шаблонные 
функции-члены нельзя размещать в отдельном файле реализации. (Одно время в 
стандарте языка существовало ключевое слово export, которое позволяло такой вынос
в отдельный файл реализации. Поскольку шаблоны не являются функциями, их нельзя 
компилировать отдельно. Шаблоны необходимо применять совместно с запросами на 
создание экземпляров шаблонов. Проще всего это сделать, поместив всю информацию 
о шаблонах в заголовочный файл и включив этот заголовочный файл в файл, 
использующий шаблоны.
  Использование шаблонного класса.
 Просто включение шаблона в программу не генерирует шаблонный класс — необходимо 
запросить создание экземпляра. Для этого потребуется объявить объект с типом
шаблонного класса и заменить имя обобщенного типа конкретным типом. Например,
ниже показано создание двух стеков: */
Stack<int> kernels;		// создание стека для значений int
Stack<string> colonels;	// создание стека для объектов string
/* Встретив эти два определения, компилятор на основе шаблона Stack<Type>
сгенерирует два различных объявления класса и два разных набора методов 
класса. Объявление класса Stack<int> заменит все Туре на int, а объявление класса
Stack<string> заменит все Туре на string. Конечно, используемые алгоритмы
должны согласоваться с типами. К примеру, класс Stack предполагает, что возможно
присваивание одних элементов другим. Это присваивание справедливо для базовых
типов, структур и классов (если не сделать операцию присваивания закрытой), но не
для массивов. Идентификаторы обобщенных типов, такие как Туре в нашем примере, 
называются параметрами типа — т.е. они действуют примерно как переменные, но вместо
присваивания числового значения параметру типа присваивается тип. Поэтому в 
объявлении kernels параметр Туре имеет значение int. Требуемый тип необходимо 
указать явно. В этом заключается отличие от обычных шаблонных функций —
в них компилятор может использовать типы аргументов для определения вида функции,
которую нужно сгенерировать: */
template <class T>
void simple (T t) { cout << t << '\n'; }
...
simple(2);					// генерирует void simple(int)
simple("two");				// генерирует void simple(const char *)
/*  Некорректное использование стека указателей:
 Можно создать стек указателей, но он будет плохо работать без существенной
переделки программ. Компилятор может создать какой угодно класс, однако задача
программиста — правильно его использовать. */
Stack<char *> st;	// создание стека указателей на символы
string ро;			// Вариант 1: оператор меняется на
char * ро;
/* Смысл в том, чтобы для ввода данных с клавиатуры использовать указатель на
char вместо объекта string. Этот подход ошибочен с самого начала — ведь одно 
только создание указателя не выделяет память для хранения входных строк.
Программа скомпилируется нормально, но, скорее всего, завершится аварийно, 
когда с in попытается сохранить введенные данные в неподходящем месте. */
string ро;		// Вариант 2: оператор заменяется на
char ро[40];
/* Здесь выделяется память для входной строки, а переменная ро имеет тип char *,
и поэтому ее можно поместить в стек. Однако массив ведет себя совершенно не так,
как нужно в методе pop(): */
template <class Type>
bool Stack<Type>::pop(Type & item)
{
	if (top > 0)
	{
		item = items [--top];
		return true;
	}
	else
		return false;
}
/* Во-первых, ссылочная переменная item должна ссылаться на lvalue, но не на имя 
массива. Во-вторых, предполагается, что переменной item можно присваивать значения.
Даже если бы переменная item могла ссылаться на массив, невозможно присвоить 
значение имени массива. Так что этот способ тоже не годится. */
string ро; // Вариант 3: оператор заменяется на
char * ро = new char[40];
/* Здесь выделяется память для входной строки, а ро является переменной и поэтому
совместима с кодом метода pop(). Однако здесь мы сталкиваемся с наиболее 
фундаментальной проблемой: имеется только одна переменная ро, и она всегда указывает
на одно и тоже место в памяти. Правда, содержимое памяти меняется при каждом
чтении новой строки, но каждая операция заталкивания помещает в стек один и тот
же адрес. Поэтому при выталкивании данных из стека мы всегда будем получать один
и тот же адрес, и он всегда будет указывать на последнюю строку, прочитанную и 
сохраненную в памяти. Такой стек не сохраняет отдельно каждую новую строку по мере
их ввода и поэтому бесполезен.
  Корректное использование стека указателей:
 Один из способов применения стека указателей — создание в вызывающей программе массива 
указателей, где все указатели указывают на разные строки. Помещение таких указателей в 
стек имеет смысл, т.к. они ссылаются на разные строки. Создание различных указателей —
обязанность вызывающей программы, а не стека. Стек должен просто манипулировать готовыми
указателями, а не создавать их. Использование динамического массива внутри класса и 
аргумента в конструкторе для задания количества элементов: */
#ifndef _STCKTP1_H_
#define _STCKTP1_H_
template <class Type>
class Stack
{
private:
    enum {SIZE = 10};								// размер по умолчанию
    int stacksize;
    Type * items;									// хранит элементы стека
    int top;										// индекс вершины стека
public:
    explicit Stack(int ss = SIZE);	// конструктор по умолчанию (запрещены неявные преоб. в тип класса)
    Stack(const Stack & st);							// явный конструктор копирования
    ~Stack() { delete[] items; }						/* явный деструктор очистки динамической памяти.
Деструктор класса уничтожает массив указателей, а не строки, на которые ссылаются элементы массива. */
    bool isempty() { return top == 0; }
    bool isfull()  { return top == stacksize; }
    bool push(const Type & item);					// добавление item в стек
    bool pop(Type & item);							// выталкивание верхнего элемента в item
    Stack & operator=(const Stack & st);				// явный конструктор присваивания
};
template <class Type>
Stack<Type>::Stack(int ss) : stacksize(ss), top(0)	/* конструктор по умолчанию (запрещены неявные преобр.
в тип класса). Конструктор класса использует операцию new для создания массива, содержащего указатели. */
{													// преобразования в тип класса)
    items = new Type[stacksize];
}
template <class Type>
Stack<Type>::Stack(const Stack & st)					// явный конструктор копирования
{
    stacksize = st.stacksize;
    top = st.top;
    items = new Type[stacksize];
    for (int i = 0; i < top; i++)
        items[i] = st.items[i];
}
template <class Type>
bool Stack<Type>::push(const Type & item)			// добавление item в стек
{
    if (top < stacksize)
    {
        items[top++] = item;
        return true;
    }
    else
        return false;
}
template <class Type>
bool Stack<Type>::pop(Type & item)					// выталкивание верхнего элемента в item
{
    if (top > 0)
    {
        item = items[--top];
        return true;
    }
    else
        return false;
}
template <class Type>
Stack<Type> & Stack<Type>::operator=(const Stack<Type> & st) // явный конструктор присваивания
{ /* прототип объявляет тип, возвращаемый функцией операции присваивания, как ссылку на Stack, 
а само определение шаблонной функции задает тип как Stack<Type>. */
    if (this == &st)
        return *this;
    delete[] items;
    stacksize = st.stacksize;
    top = st.top;
    items = new Type[stacksize];
    for (int i = 0; i < top; i++)
        items[i] = st.items[i];
    return *this; 
}
#endif
// stkoptr1.cpp -- тестирование стека указателей
#include <iostream>
#include <cstdlib>     // for rand(), srand()
#include <ctime>       // for time()
#include "stcktp1.h"
const int Num = 10;
int main()
{
    std::srand(std::time(0));							// рандомизация rand()
    std::cout << "Please enter stack size: ";				// ввод размера стека
    int stacksize;
    std::cin >> stacksize;
    Stack<const char *> st(stacksize);                  // Создание пустого стека размером stacksize
    const char * in[Num] = {                            /* Входной ящик: используется тип const char *, 
    т.к. массив указателей инициализируется набором строковых констант. */
            " 1: Hank Gilgamesh", " 2: Kiki Ishtar",
            " 3: Betty Rocker", " 4: Ian Flagranti",
            " 5: Wolfgang Kibble", " 6: Portia Koop",
            " 7: Joy Almondo", " 8: Xaverie Paprika",
            " 9: Juan Moore", "10: Misha Mache"
            };
    const char * out[Num];                              // Выходной ящик
    int processed = 0;
    int nextin = 0;
    while (processed < Num)
    {
        if (st.isempty())
            st.push(in[nextin++]);
        else if (st.isfull())
            st.pop(out[processed++]);
        else if (std::rand() % 2  && nextin < Num)		// шансы 50 на 50. Случайно сгенерированные 0 
														// и 1 моделируют подбрасывание монеты.
            st.push(in[nextin++]); /* При заталкивании строки в стек просто создается новый указатель на уже 
			существующую строку. То есть создается указатель с адресом существующей строки. */
        else
            st.pop(out[processed++]);	// При выталкивании строки из стека адрес существующей строки 
                                        // копируется в выходной массив.
    }
    for (int i = 0; i < Num; i++)
        std::cout << out[i] << std::endl;

    std::cout << "Bye\n";
    // std::cin.get();
	return 0; 
}
/* Первое объявление является сокращением для второго, но может использоваться только 
внутри области видимости класса. То есть можно применять тип Stack внутри определения 
шаблонов и шаблонных функций, а за пределами класса — например, при указании 
возвращаемых типов и использовании операции разрешения контекста — необходима полная 
форма Stack<Type>.
  Шаблона массива и нетипизированные аргументы.
 Шаблоны часто используются для контейнерных классов, поскольку идея параметров типа 
удачно сочетается с идеей общего способа хранения для различных типов.
Применение аргумента шаблона для задания размера обычного массива: */
//arraytp.h  -- шаблон массива
#ifndef _ARRAYTP_H_
#define _ARRAYTP_H_
#include <iostream>
#include <cstdlib>

template <typename T, int n>   /* Применение аргумента шаблона для задания размера обычного массива.
int n, определяющий конкретный тип, — называется нетипизироваппым параметром, или параметром-выражением. */
class ArrayTP
{
private:
    T ar[n];
public:
    ArrayTP() {};
    explicit ArrayTP(const T & v);			// конструктор копирования (запрещены неявные преобр. в тип класса)
    virtual T & operator[](int i);
    virtual T   operator[](int i) const;
};
template <typename T, int n>
ArrayTP<T,n>::ArrayTP(const T & v)
{
    for (int i = 0; i < n; i++)
        ar[i] = v;
}
template <typename T, int n>
T & ArrayTP<T,n>::operator[](int i)
{
    if (i < 0 || i >= n)
    {
        std::cerr << "Error in array limits: " // выход за пределы допустимого диапазона индекса в массиве
             << i << " is out of range\n";
        std::exit(EXIT_FAILURE);
    }
    return ar[i];
}
template <typename T, int n>
T ArrayTP<T,n>::operator[](int i) const
{
    if (i < 0 || i >= n)
    {
        std::cerr << "Error in array limits: " // выход за пределы допустимого диапазона индекса в массиве
             << i << " is out of range\n";
        std::exit(EXIT_FAILURE);
    }
    return ar[i]; 
}
#endif
/* Аргумент-выражение может быть целочисленного типа, перечислимого типа, ссылкой
или указателем. Поэтому объявление double m является недопустимым, тогда как 
double & rm и double * pm допускаются. Кроме того, код шаблона не может изменять 
значение аргумента или использовать его адрес. Например, в шаблоне АггауТР выражения
п++ или &п не разрешены. При инициализации шаблона значение, используемое для 
аргумента-выражения, должно быть константным выражением.
 Вариант с конструктором Stack использует память типа кучи, управляемую операциями 
new и delete, а вариант с аргументом-выражением — стек памяти для автоматических 
переменных. Второй способ быстрее, особенно в случае множества небольших массивов.
Главный недостаток подхода с аргументами-выражениями состоит в том, что для каждого 
размера массива генерируется собственный шаблон. Так, следующие объявления генерируют
два отдельных определения классов: */
ArrayTP<double, 12> eggweights;
ArrayTP<double, 13> donuts;
/* Тогда как объявления, показанные ниже, генерируют только одно определение класса,
а информация о размере передается конструктору этого класса: */
Stack<int> eggs(12);
Stack<int> dunkers(13);
/* Другое отличие заключается в том, что вариант с конструктором с кучей более гибок, 
поскольку размер массива хранится как член класса (int stacksize), а не жестко 
закодирован в определении. Поэтому можно, например, определить присваивание массива 
одного размера массиву другого размера или создать класс с массивами переменной 
размерности.
  Универсальность шаблонов.
 В шаблонных классах можно применять те же приемы программирования, что и в
обычных классах. Шаблонные классы могут выступать как в качестве базовых классов,
так и компонентов других классов. Например, можно создать шаблон стека на основе 
шаблона массива. Или можно взять шаблон массива и применить его для создания 
массива, элементы которого являются стеками, основанными на шаблоне стека. */
template <typename T>		// или <class T>
class Array
{
private:
	Т entry;
	...
};.

template <typename Type>
class GrowArray : public Array<Type> {...}; // наследование

template <typename Tp>		// шаблон стека на основе шаблона массива
class Stack
{
	Array<Tp> ar;			// использует Array<> в качестве компонента
	...
};
...
Array<Stack<int>> asi;		// массив стеков значений int
/*  Рекурсивное использование шаблонов. */
ArrayTP<ArrayTP<int,5>, 10> twodee;
/* Здесь создается массив twodee, состоящий из 10 элементов, каждый из которых,
в свою очередь, является массивом из пяти целых чисел (int). Эквивалентный 
обычный массив объявляется следующим образом: */
int twodee[10][5];
/* В синтаксисе шаблона размеры массива приведены в порядке, отличном от 
эквивалентного обычного двумерного массива. */
#include <iostream>			// twod.cpp -- создание двумерного массива
#include "arraytp.h"
int main(void)
{
    using std::cout;
    using std::endl;
    ArrayTP<int, 10> sums;
    ArrayTP<double, 10> aves;
    ArrayTP<ArrayTP<int,5>, 10> twodee;	/* для создания одномерного массива, содержащего
                суммы и средние значения для каждого из десяти наборов по пять чисел. */
    int i, j;
    for(i = 0; i < 10; i++)
    {
        sums[i] = 0;
        for(j = 0; j < 5; j++)
        {
            twodee[i][j] = (i + 1) * (j + 1);
            sums[i] += twodee[i][j];
        }
        aves[i] = (double) sums[i] / 10;
    }
    for(i = 0; i < 10; i++)
    {
        for(j = 0; j < 5; j++)
        {
            cout.width(2);
            cout << twodee[i][j] << ' ';
        }
        cout << ": sum = ";
        cout.width(3);	/* приводит к выводу следующего элемента массива в виде 3х символов (если 
    для вывода целого числа не потребуется большая длина).*/
        cout << sums[i] << ", average = " << aves[i] << endl;
    }
    cout << "Done.\n";
    // std::cin.get();
    return 0;
}
// Вывод:
 1  2  3  4  5 : sum =  15, average = 1.5
 2  4  6  8 10 : sum =  30, average = 3
 3  6  9 12 15 : sum =  45, average = 4.5
 4  8 12 16 20 : sum =  60, average = 6
 5 10 15 20 25 : sum =  75, average = 7.5
 6 12 18 24 30 : sum =  90, average = 9
 7 14 21 28 35 : sum = 105, average = 10.5
 8 16 24 32 40 : sum = 120, average = 12
 9 18 27 36 45 : sum = 135, average = 13.5
10 20 30 40 50 : sum = 150, average = 15
Done.
/*  Использование нескольких параметров типа.
 Допускается создание шаблонов с несколькими параметрами типа. */
#include <iostream>		// pairs.cpp -- defining and using a Pair template
#include <string>
template <class T1, class T2>
class Pair
{
private:
    T1 a;
    T2 b;
public:
    T1 & first();
    T2 & second();
    T1 first()  const { return a; }
    T2 second() const { return b; }
    Pair(const T1 & aval, const T2 & bval) : a(aval), b(bval) {}
    Pair() {}
};
template<class T1, class T2>
T1 & Pair<T1,T2>::first()  { return a; }

template<class T1, class T2>
T2 & Pair<T1,T2>::second() { return b; }

int main()
{
    using std::cout;
    using std::endl;
    using std::string;
    Pair<string, int> ratings[4] = 
    {
        Pair<string, int>("The Purpled Duck", 5),
        Pair<string, int>("Jaquie's Frisco Al Fresco", 4),
        Pair<string, int>("Cafe Souffle", 5),
        Pair<string, int>("Bertie's Eats", 3)
    };
    int joints = sizeof(ratings) / sizeof (Pair<string, int>); /* для вызова конструкторов и в качестве
аргумента для sizeof необходимо  выражение Pair<string, int> — поскольку именем класса является
Pair<string, int>, а не Pair. */
    cout << "Rating:\t Eatery\n";                       // вывод рейтингов закусочных
    for (int i = 0; i < joints; i++)
        cout << ratings[i].second() << ":\t "
             << ratings[i].first() << endl;
    cout << "Oops! Revised rating:\n";                  // вывод пересмотренного рейтинга
    ratings[3].first() = "Bertie's Fab Eats";
    ratings[3].second() = 6;
    cout << ratings[3].second() << ":\t "
         << ratings[3].first()  << endl;
    // std::cin.get();
    return 0;
}
/*  Параметры типа по умолчанию в шаблонах.
 Еще одно новое свойство шаблонных классов — возможность указания значений по
умолчанию для параметров типа: */
template<class T1, class T2 = int> class Topo {...};
// В этом случае компилятор использует int в качестве типа Т2, если значение для Т2 отсутствует:
Topo<double, double> m1;		// тип T1 — double, тип Т2 — double
Topo<double> m2;				// тип T1 - double, тип Т2 - int
/* Это свойство часто используется в STL, если типом по умолчанию является класс.
Хотя можно задать значения по умолчанию для типов параметров шаблонных классов, 
для параметров шаблонных функций это сделать нельзя. Зато, значения по умолчанию 
нетипизированных параметров можно указывать как для шаблонных классов, так и для 
шаблонных функций: */
template<class T, int n = 0> void funct(T & t) { t * n; }; /* нетипизированный 
										параметр int со	значением по умолчанию.
Также можно задать умолчание и для первого параметра: */
template <class Type1=int, class Type2 = Type1>
class Pair
{
    Type1 first;
    Type2 second;
};
/* Это значит, что если Вы не передадите никакого аргумента в шаблон, то Type1 
будет типа int, и следовательно Type2 будет также int. Следующее использование: */
Pair<> IntPair; // приведет к инициации следующего класса:
class Pair <int, int> {};
// То же самое возможно и для non-type аргументов по умолчанию на другом non-type аргументе:
template< class T, int ROWS = 8, int COLUMNS = ROWS >
class Matrix
{
    T TheMatrix[ROWS][COLUMNS];
};
/* Однако зависимый параметр шаблона должен быть справа от того, от которого он зависит.
Следующий примеры выдадут ошибки: */
template< class Type1 = Type2, class Type2 = int >		 // ошибка, Type2 не определен
class Pair{};
 
template< class T, int ROWS = COLUMNS, int COLUMNS = 8 > // ошибка, COLUMNS не определен
class Matrix
/*  Специализации шаблона.								  
 Для шаблонов классов, как и шаблонов функций, возможны неявные создания экземпляров,
явные создания экземпляров и явные специализации, которые все вместе также называются
специализациями. Шаблон описывает класс через обобщенный тип, а специализация — это 
объявление класса, сгенерированное для конкретного типа.
  Неявное создание экземпляров.
 При неявном создании экземпляров объявление одного или более объектов задает нужный 
тип, и компилятор генерирует на основе общего шаблона специализированное определение класса: */
ArrayTP<int, 100> stuff;			// неявное создание экземпляра
// Компилятор не создает неявное создание экземпляра класса, пока не потребуется его объект:
ArrayTP<double, 30> *pt;			// указатель, пока еще объекты не нужны
pt = new ArrayTP<double, 30>;	// теперь объект нужен
/* Второй оператор заставляет компилятор сгенерировать определение класса, а 
также объект, созданный согласно этому определению.
  Явное создание экземпляров.
 Компилятор обеспечивает явное создание экземпляра объявления класса, если класс
объявлен с применением ключевого слова template, а также указан необходимый
тип или типы. Объявление класса должно находиться в том же пространстве имен,
что и определение шаблона. Например, следующая строка кода объявляет, что
ArrayTP<string, 100> является классом: */
template class ArrayTP<string, 100>;		// генерирует класс ArrayTP<string, 100>
/* В этом случае компилятор генерирует определение класса, включая определения методов,
даже если не создаются или упоминаются объекты класса. Как и в случае неявного 
создания экземпляров, руководством для генерирования специализации служит общий шаблон.
  Явная специализация.
 Явная специализация - это определение конкретного типа (или типов), который должен 
использоваться вместо общего шаблона. Иногда необходимо изменить шаблон так, чтобы 
он вел себя по-разному при создании экземпляров для различных типов — в этом случае 
можно создать явную специализацию. Предположим, что определен шаблон класса, 
представляющий отсортированный массив, элементы которого сортируются непосредственно 
при занесении в массив: */
template<class T>
class SortedArray {...};
/* Предположим также, что для сравнения значений шаблон использует операцию >.
Она хорошо работает для чисел, а также в случаях, когда Т является типом класса, в
котором определен метод Т::operator>(). Однако такой способ не сработает, если
Т является строкой, представляемой с помощью типа const char *. Вообще говоря,
шаблон будет работать, но строки окажутся отсортированными не по алфавиту, а по
адресам. Поэтому требуется определение класса, где вместо операции > используется
сравнение strcmp(). В этом случае можно указать явную специализацию шаблона —
т.е. шаблон, определенный для одного конкретного типа, а не общего типа. Если 
запросу специализации удовлетворяет и специализированный шаблон, и общий шаблон,
компилятор использует специализированный вариант. Определение специализированного 
шаблона класса имеет вид: */
template<> class ИмяКласса<имя-специализированного-типа> { ... };
// Некоторые старые компиляторы могут распознавать только ранние формы без префикса template <>:
class ИмяКласса<имя-специализированного-типа> { ... };
/* Для создания шаблона SortedArray, специализированного для типа const char *,
в современной нотации нужен примерно такой код: */
template<> class SortedArray<const char *> {...};
/* Теперь запросы шаблона SortedArray для типа const char * будут применять 
специализированное определение вместо более общего определения шаблона: */
SortedArray<int> scores;				// используется общее определение
SortedArray<const char *> dates;		// используется специализированное определение
/*  Частичная специализация.
 Частичная специализация частично ограничивает общность шаблона. Например, используя 
частичную специализацию, можно задать конкретный тип для одного из параметров типа: */
template<class T1, class T2> class Pair {...};	// Общий шаблон
template<class T1> class Pair<T1, int>  {...};	// Специализация, в которой для T2 указан тип int
/* Угловые скобки <>, следующие за ключевым словом template, объявляют 
параметры типов, которые пока еще не специализированы, таким образом, второе 
объявление указывает для T2 тип int, но оставляет параметр T1 открытым. Указание всех 
типов приводит к пустым угловым скобкам и получению завершенной явной специализации: */
template<> class Pair<int, int> {...};	// Специализация, в которой для T1 и T2 указан тип int
/* Если у компилятора есть выбор, он применяет наиболее специальный шаблон. Вот
что произойдет для трех приведенных выше шаблонов: */
Pair<double, double> p1;		// используется общий шаблон Pair<T1, T2>
Pair<double, int> p2;		// используется частичная специализация Pair<T1, int>
Pair<int, int> р3;			// используется явная специализация Pair<int, int>
// Можно частично специализировать существующий шаблон, введя специальную версию для указателей:
template<class Т>			// общая версия
class Feeb {...};
template<class T *>			// частичная специализация с указателем
class Feeb {...};			// измененный код
/* Если предоставить тип, который не является указателем, компилятор задействует
общую версию, а если использовать указатель, компилятор выберет специализацию с указателем: */
Feeb<char>	 fb1;			// используется общий шаблон Feeb (Т — это char)
Feeb<char *>	 fb2;			// используется специализация Feeb Т* (Т — это char)
// Частичная специализация позволяет задавать различные ограничения. Например:
template<class T1, class T2, class T3> class Trio{...};    // Общий шаблон
template<class T1, class T2> class Trio<T1, T2, T2> {...}; // Специализация, когда для Т3 указан Т2
template<class T1> class Trio<T1, T1*, T1*> {...};		  // Специализация, когда для ТЗ и Т2 указан Т1*
// Для этих объявлений компилятор выберет следующие варианты:
Trio<int, short, char *>	   t1;	// используется общий шаблон
Trio<int, short>			   t2;	// используется Trio<T1, T2, T2>
Trio<char, char *, char *> t3;	// используется Trio<T1, T1*, T1*>
/*  Шаблоны-члены.
 Шаблоны могут быть членами структуры, класса или шаблонного класса. Эти 
свойства необходимы библиотеке STL для полного определения своей структуры. */
#include <iostream>								// tempmemb.cpp -- шаблоны-члены
using std::cout;
using std::endl;
template <typename T>
class beta
{
private:
    template <typename V>						// вложенный шаблонный класс-член
    class hold									// доступен только в пределах класса beta
    {
    private:
        V val;
    public:
        hold(V v  = 0) : val(v) {}				// конструктор по умолчанию
        void show() const { cout << val << endl; }
        V Value()   const { return val; }
    };
    hold<T>   q; // шаблонный объект класса hold. q — объект hold, основанный на типе T (параметр шаблона beta)
    hold<int> n; // шаблонный объект класса hold. n — объект hold, основанный на типе int
public:
    beta(T t, int i) : q(t), n(i) {}

    template<typename U> /* шаблонный метод класса beta. Тип (U) определен неявно, с помощью значения 
аргумента при вызове метода, а тип (Т) определен типом создания экземпляра объекта: */
    U blab(U u, T t) { return (n.Value() + q.Value()) * u / t; }

    void Show() const { q.show(); n.show();}
};
int main()
{
    beta<double> guy(3.5, 3);					// присваивает T тип double, a q — тип hold<double>
    cout << "T was set to double\n";				// T установлен в double
    guy.Show();
          // V установлен в Т, который double, затем V установлен в int
    cout << "V was set to T, which is double, then V was set to int\n";
    cout << guy.blab(10, 2.3) << endl;			// назначает U тип int, соответствующий значению 10
    cout << "U was set to int\n";					// U установлен в int
    cout << guy.blab(10.0, 2.3) << endl;			// назначает U тип double, соответствующий значению 10.0
    cout << "U was set to double\n";				// U установлен в double
    cout << "Done\n";
    // std::cin.get();
    return 0; 
}
/* Хотя автоматическое преобразование типов из-за смешения типов приводит к 
вычислению blab() как double, возвращаемое значение, имеющее тип U,должно 
быть int. Поэтому оно усекается до 28, как показано в выводе программы: */
T was set to double
3.5
3
V was set to T, which is double, then V was set to int
28
U was set to int
28.2609
U was set to double
Done
/* В отличие от первого параметра, тип второго параметра не задается вызовом функции.
Например, показанный ниже оператор по-прежнему реализует blah() как blah(int, double),
и значение 3 будет преобразовано в тип double по обычным правилам соответствия 
прототипам функций: */
cout << guy.blab(10, 3) << endl;
// Можно определить шаблонные методы за пределами шаблона beta следующим образом:
template<typename T>
class beta
{
private:
	template<typename V>						// объявление члена
	class hold;
	hold<T> q;
	hold<int> n;
public:
	beta(T t, int i) : q(t), n(i) {}
	template<typename U>						// объявление члена
	U blab(U u, T t);
	void Show() const { q.show(); n.show(); }
};
// Определение члена
template<typename T>
	template<typename V>
		class beta<T>::hold
		{
		private:
			V val;
		public:
			hold(V v = 0) : val(v) {}
			void show() const { std::cout << val << std::endl; }
			V Value() const { return val; }
		};
// Определение члена
template<typename T>
	template<typename U>
		U beta<T>::blab(U u, T t)
		{
			return (n.Value() + q.Value()) * u / t;
		}
/* Определения должны идентифицировать Т, V и U как параметры шаблона. Из-за
вложенности шаблонов необходимо использовать синтаксис: */
template <typename T>
	template <typename V>
// а не синтаксис
template<typename T, typename V>
/* hold и blab в определениях должны быть заданы как члены класса beta<T>, и для
этого применяется операция разрешения контекста.
  Шаблоны как параметры.
 Шаблоны могут иметь параметры, которые сами являются шаблонами. */
template<template <typename T> class Thing>
class Crab
/* Здесь template<typename T> class Thing — параметр-шаблон, причем
template<typename T> class — тип, a Thing — параметр. Например: */
Crab<King> legs;
/* Чтобы оно работало, аргумент шаблона King должен быть шаблонным классом, а
его объявление должно соответствовать объявлению параметра-шаблона Thing: */
template<typename T>
class King {...};
// Затем класс Crab объявляет два объекта:
Thing<int>	  s1;
Thing<double> s2;
/* Предыдущее объявление для legs привело бы к подстановке King<int> вместо
Thing<int> и King<double> вместо Thing<double>. Однако: */
Crab<Stack> nebula;
/* Поэтому в данном случае Thing<int> реализуется как Stack<int>, a Thing<double> —
как Stack<double>. Параметр шаблона Thing заменяется любым шаблонным типом, 
используемым в качестве аргумента шаблона в объявлении объекта Crab. Объявление 
класса Crab основано на трех предположениях о шаблонном классе, представленном 
параметром Thing. Этот класс должен содержать методы push() и pop(), а эти методы 
должны иметь определенный интерфейс. Класс Crab может использовать любой шаблонный 
класс, который соответствует типу Thing и содержит методы push() и pop(). */
#include <iostream>			// tempparm.cpp -- шаблоны как параметры
#include "stcktp1.h"
template<template <typename T> class Thing>
class Crab
{
private:
    Thing<int>		s1;
    Thing<double>	s2;
public:
    Crab() {};
    // Предполагается, что класс thing имеет члены push() и pop():
    bool push(int a, double x)    { return s1.push(a) && s2.push(x); }
    bool pop(int & a, double & x) { return s1.pop(a) && s2.pop(x); }
};
int main()
{
    using std::cout;
    using std::cin;
    using std::endl;
    Crab<Stack> nebula;
// Stack должен соответствовать шаблону template<typename T> class Thing
    int ni;
    double nb;
    cout << "Enter int double pairs, such as 4 3.5 (0 0 to end):\n";
    while(cin >> ni >> nb && ni > 0 && nb > 0)
    {
        if(!nebula.push(ni, nb))
            break;
    }
    while(nebula.pop(ni, nb))
           cout << ni << ", " << nb << endl;
    cout << "Done.\n";
    // cin.get();
    return 0; 
}
// Шаблонные параметры допускается смешивать с обычными параметрами:
template <template<typename T> class Thing, typename U, typename V>
class Crab
{
private:
	Thing<U> s1;
	Thing<V> s2;
	...
/* Сейчас типы, сохраняемые в членах s1 и s2, являются обобщенными, а не жестко
закодированными типами. Поэтому в программе потребуется изменить определение nebula: */
Crab<Stack, int, double> nebula; // T=Stack, U=int, V=double
/* Шаблонный параметр Т является шаблонным типом, а параметры типов U и V —
нешаблонными типами.

  Шаблонные классы и друзья.
У объявлений шаблонных классов также могут быть друзья, которые принадлежат
одной из трех перечисленных ниже категорий:
• Нешаблонные друзья.
• Связанные шаблонные друзья — тип друга определяется типом класса при 
создании его экземпляра.
• Не связанные шаблонные друзья — все специализации друга являются друзьями
для всех специализаций класса.
  Нешаблонные дружественные функции для шаблонных классов. */
template <class T>
class HasFriend
{
public:
	friend void counts();	// дружественная для всех созданий экземпляров HasFriend
};
/* Функция counts() объявляется дружественной для всех возможных созданий 
экземпляров шаблона. Например, она будет дружественной для класса HasFriend<int>
и для класса HasFriend<string>. Функция counts() не вызывается объектом (она 
является дружественной, а не функцией-членом) и она не принимает каких-либо 
объектных параметров. Каким же образом она обращается к объекту HasFriend? 
Существует несколько вариантов:
- Она может иметь доступ к глобальному объекту;
- она может иметь доступ к локальным объектам через глобальный указатель;
- она может создать собственные объекты;
- она может иметь доступ к статическим членам-данным, расположенным отдельно от объекта.
Предположим, что для дружественной функции требуется создать аргумент типа
шаблонного класса. Возможно ли, например, следующее объявление друга? */
friend void report(HasFriend &); // невозможно, объект HasFriend не может существовать.
/* Существуют только конкретные специализации, такие как HasFriend<short>. Для
создания аргумента типа шаблонного класса необходимо указать специализацию, например: */
template <class T>
class HasFriend
{
	friend void report(HasFriend<T> &);		// связанный друг шаблона
};
// Представьте себе специализацию, генерируемую при объявлении объекта конкретного типа:
HasFriend<int> hf;
// Компилятор заменит параметр шаблона Т на int, и объявление друга примет следующий вид:
class HasFriend<int>
{
	friend void report(HasFriend<int> &);	// связанный друг шаблона
};
/* To есть функция report() с параметром HasFriend<int> становится дружественной
для класса HasFriend<int>. Аналогично, функция report() с параметром HasFriend<double>
будет перегруженной версией report(), которая является дружественной ДЛЯ класса
HasFriend<double>. report() — нешаблонная функция: шаблоном является лишь ее параметр.
Это означает, что для использования друзей необходимо определить явные специализации: */
void report(HasFriend<short> &)	{...}; // явная специализация для short
void report(HasFriend<int> &)	{...}; // явная специализация для int
// frnd2tmp.cpp -- шаблонный класс с нешаблонными друзьями
#include <iostream>
using std::cout;
using std::endl;
template <typename T>
class HasFriend
{
private:
    T item;
    static int ct;
public:
    HasFriend(const T & i) : item(i) {ct++;}    // при создании объекта одного типа меняется 
                                               // статический член его конкретной специализаций
    ~HasFriend()  {ct--; }
    friend void counts();
    friend void reports(HasFriend<T> &);       // template parameter
};
template <typename T>                   // Каждая специализация имеет собственный статический член данных ct
int HasFriend<T>::ct = 0;

void counts()                           // Нешаблонный друг для всех классов HasFriend<T>
{   // выводит значения ct из двух конкретных специализаций:
    cout << "int count: "    << HasFriend<int>::ct    << "; ";
    cout << "double count: " << HasFriend<double>::ct << endl;
}
void reports(HasFriend<int> & hf)       	// Нешаблонный друг для класса HasFriend<int>
{
    cout << "HasFriend<int>: "    << hf.item << endl;
}
void reports(HasFriend<double> & hf)    	// Нешаблонный друг для класса HasFriend<double>
{
    cout << "HasFriend<double>: " << hf.item << endl;
}
int main()
{
    cout << "No objects declared: ";    	// объекты пока не объявлены
    counts();
    HasFriend<int> hfi1(10);
    cout << "After hfi1 declared: ";    	// после объявления hfi1
    counts();
    HasFriend<int> hfi2(20);
    cout << "After hfi2 declared: ";    	// после объявления hfi2
    counts();
    HasFriend<double> hfdb(10.5);
    cout << "After hfdb declared: ";    	// после объявления hfdb
    counts(); 
    reports(hfi1);
    reports(hfi2);
    reports(hfdb);
    // std::cin.get();
    return 0; 
}
/*  Связанные шаблонные функции, дружественные шаблонным классам.
 Можно сделать дружественные функции также шаблонами. В частности, 
можно создать связанных друзей шаблона — чтобы каждая специализация класса 
получала соответствующую специализацию друга. Этот прием немного сложнее, чем 
в случае нешаблонных друзей, и состоит из трех шагов. На первом шаге перед 
определением класса необходимо объявить каждую шаблонную функцию: */
template <typename T> void counts();
template <typename T> void report(T &);
/* Затем внутри функции нужно снова объявить шаблоны в качестве друзей. Вот операторы,
которые объявляют специализации, основанные на типе параметра шаблонного класса: */
template <typename TT>
class HasFriendT
{
	friend void counts<TT>();
	friend void report<>(HasFriendT<TT> &);
};
/* Угловые скобки <> в объявлениях означают специализации шаблона. В случае report() 
скобки <> могут быть пустыми, т.к. аргумент типа шаблона можно получить из аргумента 
функции HasFriendT<TT>. Но возможен и такой вариант: */
report< HasFriendT<TT> >(HasFriendT<TT> &)
/* Функция counts() не имеет параметров, поэтому для определения ее специализации 
нужно задействовать аргумент шаблона <ТТ>. Обратите внимание, что ТТ — тип
параметра для класса HasFriendT. Чтобы понять эти объявления, лучше представить,
чем они станут при объявлении объекта конкретной специализации. Например: */
HasFriendT<int> squack;
// Компилятор подставит вместо ТТ тип int и сгенерирует следующее определение класса:
class HasFriendT<int>
{
	friend void counts<int>();
	friend void reporto(HasFriendT<int> &);
	...
};
/* Одна специализация основана на типе ТТ, который преобразуется в int, а другая —
на HasFriendT<TT>, который преобразуется в HasFriendT<int>. Таким образом, 
специализации шаблона counts<int>() и report< HasFriendT<int> >() объявлены как
друзья класса HasFriendT<int>.
 Третье требование, которому должна удовлетворять программа — она должна содержать 
определения шаблонов для друзей. */
#include <iostream>					// tmp2tmp.cpp -- шаблонные друзья для шаблонного класса
using std::cout;
using std::endl;
// Прототипы шаблонов
template <typename T> void counts();
template <typename T> void report(T &);
// Шаблонный класс
template <typename TT>
class HasFriendT
{
private:
    TT item;
    static int ct;
public:
    HasFriendT(const TT & i) : item(i) {ct++;}
    ~HasFriendT() { ct--; }
    friend void counts<TT>();
    friend void report<>(HasFriendT<TT> &);
};
template <typename T>
int HasFriendT<T>::ct = 0;
// Определения дружественных функций для шаблона
template <typename T>
void counts()
{
    cout << "template size: " << sizeof(HasFriendT<T>) << "; ";	// размер шаблона
    cout << "template counts(): " << HasFriendT<T>::ct << endl;	// counts() из шаблона
}
template <typename T>
void report(T & hf)
{
    cout << hf.item << endl;
}
int main()
{ /* Поскольку вызовы функции counts() не содержат параметров, из которых компилятор мог бы вывести 
требуемую специализацию, в этих вызовах используются формы count<int>() и count<double>(). */
    counts<int>();
    HasFriendT<int>     hfi1(10);
    HasFriendT<int>     hfi2(20);
    HasFriendT<double>  hfdb(10.5);
// в вызовах reports() компилятор может определять специализацию на основе типа аргумента^
    report(hfi1);                         // генерирует report(HasFriendT<int> &)
    report(hfi2);                         // генерирует report(HasFriendT<int> &)
    report(hfdb);                         // генерирует report(HasFriendT<double> &)
    cout << "counts<int>() output:\n";      // вывод из counts<int>()
    counts<int>();
/* counts<double> сообщает размер шаблона, отличный от выводимого counts<int> — т.е. каждому типу Т
соответствует собственная дружественная функция count(). */
    cout << "counts<double>() output:\n";   // вывод из counts<double>()
    counts<double>();
    // std::cin.get();
    return 0;
}
/*  Не связанные шаблонные функции, дружественные шаблонным классам.
 У не связанных друзей параметры типа для шаблонов друзей отличаются от параметров 
типа для шаблонных классов: */
template <typename T>
class ManyFriend
{
	template <typename С, typename D> friend void show2(C &, D &);
};
// Вызов show2(hfil, hfi2) соответствует следующей специализации:
void show2<ManyFriend<int> &, ManyFriend<int> &>(ManyFriend<int> & с, ManyFriend<int> & d);
/* Поскольку данная функция является другом для всех специализаций ManyFriend,
она имеет доступ к членам item всех специализаций. Однако она использует доступ
только к объектам ManyFriend<int>. Аналогично, вызов show2(hfd, hfi2) соответствует
такой специализации: */
void show2<ManyFriend<double> &, ManyFriend<int> &>(ManyFriend<double> & с, ManyFriend<int> & d);
/* Эта функции также является другом для всех специализаций ManyFriend и 
использует доступ к члену item объекта ManyFriend<int>, а также к члену
item объекта ManyFriend<double>. */
// manyfrnd.cpp -- не связанная шаблонная функция, дружественная шаблонному классу
#include <iostream>
using std::cout;
using std::endl;
template <typename T>
class ManyFriend
{
private:
    T item;
public:
/* У не связанных друзей параметры типа для шаблонов друзей отличаются от параметров 
типа для шаблонных классов: */
    ManyFriend(const T & i) : item(i) {}
    template <typename C, typename D> friend void show2(C &, D &);
};
template <typename C, typename D> void show2(C & c, D & d)
{
    cout << c.item << ", " << d.item << endl;
}
int main()
{
    ManyFriend<int> hfi1(10);
    ManyFriend<int> hfi2(20);
    ManyFriend<double> hfdb(10.5);
    cout << "hfi1, hfi2: ";
    show2(hfi1, hfi2);
    cout << "hfdb, hfi2: ";
    show2(hfdb, hfi2);
    // std::cin.get();
    return 0;
}
/*  Псевдонимы шаблонов (С++11).
 Бывает удобно, особенно при построении шаблонов, создавать псевдонимы для типов.
Конструкция typedef позволяет создавать псевдонимы для специализаций шаблонов: */
// Определение трех псевдонимов с помощью typedef
typedef std::array<double,		12> arrd;
typedef std::array<int,			12> arri;
typedef std::array<std::string,	12> arrst;
arrd gallons;		// gallons	имеет тип std::array<double,		12>
arri days;			// days		имеет тип std::array<int,			12>
arrst months;		// months	имеет тип std::array<std::string,	12>
/* Но если приходится постоянно писать код, содержащий такие описания typedef, то 
лучше использовать шаблон для получения семейства псевдонимов. Вот как это выглядит: */
template<typename T>				// шаблон для создания
using arrtype = std::array<T,12>;	// нескольких псевдонимов
/* Ниже объявлен псевдоним шаблона arrtype, который можно применять вместо
спецификатора типа: */ 
arrtype<double> gallons;				// gallons	имеет тип std::array<double,		12>
arrtype<int> days;					// days		имеет тип std::array<int,			12>
arrtype<std::string> months;			// months	имеет тип std::array<std::string,	12>
/* Короче говоря, arrtype<T> означает тип std::array<T, 12>.
В C++11 синтаксис using = можно использовать и не для шаблонов. В таких 
случаях он эквивалентен typedef: */
typedef const char * pc1;			// синтаксис typedef
using pc2 = const char *;			// синтаксис using =
typedef const int  *(*pa1)[10];		// синтаксис typedef
using pa2 = const int *(*)[10];		// синтаксис using =
/* В C++11 появилось еще одно дополнение — шаблон с переменным числом аргументов
(variadic template), который позволяет определить шаблонный класс или шаблонную
функцию с переменным количеством инициализаторов.
	Требования: шаблоны функции.
Следующая функция отобразит в консоли значение предоставленного типа (используя std::cout):*/
template<typename T>
void DisplayValue(T tValue)
{
   std::cout << tValue;
}
// Следующий набор вызовов выполнится успешно:
DisplayValue(20);			// <int>
DisplayValue("Это текст");	// <const char*>
DisplayValue(20.4 * 3.14);	// <double>
/* Поскольку ostream (тип cout) имеет перегруженный оператор<< для всех базовых 
типов, то этот код будет нормально работать для типов int, char* и double. Здесь 
будет происходить неявный вызов одной из перезагрузок оператора<<.
Теперь попробуем определить новую структуру, в которой будет 2 поля: */
struct Currency
{
   int Dollar;
   int Cents;
}
// Попытаемся использовать этот тип вместе с шаблоном функции DisplayValue:
Currency c;
c.Dollar = 10;
c.Cents  = 54;
DisplayValue(c);
/* Для этого вызова Вы будете завалены сообщениями об ошибках со стороны компилятора, 
потому что следующая строка не сможет скомпилироваться для инстанциации DisplayValue с 
типом Currency: */
std::cout << tValue;		// tValue теперь имеет тип Currency
/*Visual C++ начнет сообщать об ошибках так:
error C2679: binary ' << ' : no operator found which takes a right-hand operand of 
type 'Currency' (or there is no acceptable conversion)
В настоящий момент у Вас есть несколько доступных опций для решения проблемы:
• Не вызывать DisplayValue для типа Currency, и вместо этого написать другую функцию 
DisplayCurrencyValue. Именно это и делают большинство программистов после того, как они 
не смогли выполнить задачу с оригинальным вариантом DisplayValue, когда она вызывается с 
типом Currency. Делать так - значит признать поражение, и не использовать силу шаблонов 
C++. Не делайте так!
• Модифицировать класс ostream, и добавить к нему новый член (например оператор<<), 
который может принимать тип Currency. Но у Вас нет свободы поступать так, потому что 
ostream определен в одном из стандартных заголовков C++. Однако с глобальной функцией, 
которая берет типы ostream и Currency, Вы можете сделать это.
• Модифицируйте Ваш собственный класс Currency, так чтобы cout << tValue мог 
завершиться успешно.
Короче говоря, Вам нужно упростить одно из следующего: */
ostream::operator<<(Currency value); // упрощенный синтаксис
ostream::operator<<(std::string value);
ostream::operator<<(double value);
/* Первая версия весьма возможна, но синтаксис несколько сложноват. Определение 
пользовательской функции должно принимать как тип ostream, так и тип Currency, так 
чтобы cout << currency_object; мог сработать.
 Вторая версия требует понимания std::string и будет медленнее и сложной в реализации.
 Третья версия удовлетворяет требованиям настоящего момента, и проще других двух версий. 
Это означает, что тип Currency будет преобразован в double, и каждый раз, когда это 
будет потребовано, преобразованные данные будут переданы в вызов cout. И вот это решение: */
struct Currency
{
	int Dollar;
	int Cents; 
	operator double()
	{
	return Dollar + (double)Cents/100;
	}
};
/* Обратите внимание, что весь результат будет поставляться на выход в значении типа double.
Таким образом, для объекта Currency{12, 72} этот перезагруженный оператор (функциональный 
оператор double()) вернет 12.72. Компилятор теперь будет счастлив, поскольку теперь есть 
преобразование из Currency в один из типов, который может принять ostream::operator<< .
И таким образом следующий вызов для типа Currency: */
std::cout << tValue;
// будет развернут как:
std::cout << tValue.operator double();	// std::cout << (double)tValue;
// И поэтому следующий вызов будет работать:
Currency c;
DisplayValue(c);
/* Вы видите, что простой вызов функции вовлекает несколько операций с помощью компилятора:
• Инстанциация DisplayValue для типа Currency.
• Вызов copy-конструктора для класса Currency, поскольку тип T был передан по значению, а не по ссылке.
• В попытке найти лучший вариант для вызова оператора cout << будет вовлечен оператор преобразования 
Currency::operator double. */
template< typename TYPE >
void PrintTwice(TYPE data)
{
    cout << "Удвоенное значение: " << data * 2 << endl;
}
// Когда Вы сделаете её вызов так:
PrintTwice(c); // c является типом Currency
/* то выражение data * 2 в PrintTwice сработает, поскольку тип Currency предусматривает такую возможность. 
Оператор cout может быть составлен компилятором так: */
cout << "Удвоенное значение: " << data.operator double() * 2 << endl;
/* Когда Вы удалите перегруженный оператор double() из класса Currency, компилятор будет жаловаться, 
что у него нет оператора operator*, или любой возможности вычислить выражение. Если Вы поменяете 
class (struct) Currency так: */
struct Currency
{
	int Dollar;
	int Cents;
	/*УДАЛЕНО : operator double();*/
	double operator*(int nMultiplier)
	{
		return (Dollar+(double)Cents/100) * nMultiplier;
	}
};
/* то компилятор снова будет счастлив. Но выполнение этого приведет к тому, что DisplayValue 
не сможет инстанцироваться для Currency. Причина проста: cout << tValue не будет допустима.
Что если предоставить как преобразование для double, так и оператор умножения? Потерпит ли 
неудачу вызов PrintTwice для типа Currency? Возможный ответ был бы да, компиляция не сработает, 
поскольку для компилятора будет двусмысленность при вызове: */
cout << "Удвоенное значение: " << data * 2 << endl; // Неоднозначность: что же вызвать 
                                                  // - оператор конверсии или оператор* ?
/* Однако нет, компиляция не потерпит неудачу, и будет сделан вызов оператора*. Могут быть 
вызваны все другие возможные подпрограммы преобразования, если компилятор не найдет наилучшего 
кандидата. БОльшая часть понятий, упомянутых здесь, приходят из основного свода правил языка C++,
и не находится под покровом принципов шаблонов. Нижележащий тип может предоставить оператор 
преобразования (наподобие преобразования int или преобразования строки), но не должен 
предоставлять конверсии в избытке. Таким образом для класса Currency будет достаточной только 
конверсия double (и/или в строку) - здесь нет необходимости давать перезагрузку (двоичного) оператора*.
Следующий шаблон функции: */
template< typename T >
T Add(T n1, T n2)
{
   return n1 + n2;
}
/* потребовал бы, чтобы у T был в наличии оператор+, который берет аргументы одного типа, и 
возвращает тот же самый тип. В классе Currency class Вы должны реализовать это вот так: */
Currency operator+(Currency);	// Для упрощения без const
/* Если Вы не реализуете оператор+ в классе Currency, сохраните в этом классе оператор 
преобразования double, и вызовете функцию Add так: */
Currency c1, c2, c3;
c3 = Add(c1,c2);
/* то получите некую странную ошибку:
error C2440: 'return' : cannot convert from 'double' to 'Currency'.
Причины две:
• n1 + n2 приведут к тому, что будет вызван оператор double() для двух переданных объектов 
(implicit conversion, неявное преобразование). Таким образом, n1+n2 становится просто 
выражением double+double, и результат этого выражения также будет double.
• Поскольку конечное значение имеет тип double, и то же самое значение должно быть возвращено 
из функции Add, то компилятор попытается преобразовать double в Currency. Поскольку в классе 
Currency нет конструктора, который принимает double, то получается ошибка.
 Для этой ситуации класс Currency может предоставить конструктор (конструктор преобразования), 
который будет принимать тип double. Это целесообразно, поскольку Currency теперь может 
предоставить оба преобразования: в double и из double. Предоставление оператора+ только ради
шаблона функции Add не имеет большого смысла.













