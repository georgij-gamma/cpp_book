/*Ссылки используются в качестве параметров функции, при этом имя 
переменной в функции становится псевдонимом переменной в вызывающей программе.*/
void swapr(int & a, int & b);
void swapp (int *p, int *q);
/*Различие состоит в том, что вариант с указателем требует применения 
операции разыменования (*) во всех случаях, когда функция использует переменные р и q.
Ссылочную переменную необходимо инициализировать при ее определении.
	При условии, что ссылочный параметр является const, компилятор генерирует временную 
переменную в двух ситуациях:
• когда тип фактического аргумента выбран правильно, но сам параметр не 
является lvalue;
• когда тип фактического параметра выбран неправильно, но может быть 
преобразован в правильный тип.
	lvalue, представляет собой объект 
данных, на который можно ссылаться по адресу. Например, переменная, элемент 
массива, член структуры, ссылка и разыменованный указатель —
все они являются lvalue.
К lvalue не относятся литеральные константы (кроме строк в двойных кавычках, 
которые представлены своими адресами) и выражения, состоящие из нескольких 
элементов.
	Если передаваемый функции аргумент не является lvalue или не совместим по типу с 
соответствующим ссылочным параметром const, C++ создает анонимную переменную требуемого 
типа, присваивает ей значение передаваемого функции аргумента, и делает так, чтобы 
параметр ссылался на эту переменную.
	Причины объявлять ссылочные аргументы как ссылки на констатные данные:
• Использование const защищает от внесения в программы ошибок, приводящих к 
непреднамеренному изменению данных.
• Использование const позволяет функции обрабатывать фактические аргументы как с 
const, так и без const. При этом функция, в прототипе которой квалификатор const 
опущен, может принимать только неконстантные данные.
• Использование ссылки const позволяет функции генерировать и использовать временные 
переменные по мере необходимости.
Исходный ссылочный тип (объявленный с использованием &) называется ссылкой lvalue.
	Для отображения содержимого структуры, не изменяя её, в 
функциях применяется ссылочный параметр const. В таком случае структуру можно
было бы передать по значению, однако использование ссылки более экономично с
точки зрения времени и памяти, чем создание копии исходной структуры.
	Причины использовать ссылочные аргументы:
• чтобы позволить изменять объект данных в вызывающей функции;
• чтобы ускорить работу программы за счет передачи ссылки вместо полной 
копии объекта данных.
	***
	В каких случаях следует использовать ссылку, указатель или передачу по значению? 
	1. Функция использует передаваемые данные без их изменения в перечисленных
ниже ситуациях:
• Если объект данных небольшой, например, такой как встроенный тип данных
или некрупная структура, передавайте его по значению.
• Если объект данных представляет собой массив, используйте указатель, 
поскольку это единственный вариант. Объявите указатель с квалификатором const.
• Если объект данных является структурой приемлемого размера, используйте
const-указатель или const-ссылку для увеличения эффективности программы.
В этом случае удастся сохранить время и пространство, необходимое для 
копирования структуры или строения класса. Объявите указатель или ссылку с 
квалификатором const.
• Если объект данных является объектом класса, используйте ссылку с 
квалификатором const. Семантика строения класса часто требует применения ссылки.
Эта главная причина добавления этого новшества в язык C++. Таким образом,
стандартом является передача объектов класса по ссылке.
	2. Функция изменяет данные вызывающей функции в следующих ситуациях:
• Если объект данных относится к одному из встроенных типов, используйте 
указатель. Если в коде встретилось выражение вида fixit (&х), где х имеет тип int,
это явно означает, что функция должна изменять значение х.
• Если объект данных представляет собой массив, остается один выбор — указатель.
• Если объект данных является структурой, можно использовать ссылку или указатель.
• Когда объект данных представляет собой объект класса, следует применять ссылку.
	Могут существовать причины для других решений. Например, объект сіn 
	использует ссылки на базовые типы данных, поэтому
вместо записи сіn » &n можно применять запись сіn » n.
	***
	Аргументы по умолчанию
	Аргумент по умолчанию представляет собой значение, которое
используется автоматически, если соответствующий фактический параметр в вызове
функции не указан.*/
char * left (const char * str, int n = 1) // функция должна возвращать новую строку,
{										  // т.к. нужно сохранить исходную строку неизменной,
										  // использовать квалификатор const для первого аргумента.
if (n < 0)
	n = 0;
char *p = new char[n+l];
int i;
for (i = 0; i < n && str[i]; i++ )
	p[i] = str[i]; // копирование символов
while (i <= n)
	p[i++] = '\0'; // установка остальных символов строки в '\0'
return p;
}
/*	Перегрузка функций
	Полиморфизм функций, или перегрузка функций, 
предоставляет возможность использовать несколько функций с одним
и тем же именем. Ключевую роль в перегрузке функций играет список аргументов, который 
называется сигнатурой функции.
	Значение без const можно присвоить переменной const, но не наоборот.
	Именно сигнатура, а не тип функции, делает возможным ее 
перегрузку: */
long gronk(int n, float m); // одинаковые сигнатуры, поэтому
double gronk(int n, float m); // объявления не допускаются
/*В C++ нельзя перегружать функцию gronk () подобным образом. Можно иметь 
различные возвращаемые типы, но только при условии, что сигнатуры функций 
отличаются: */
long gronk(int n, float m) ; // различные сигнатуры, поэтому
double gronk(float n, float m) ; // объявления допустимы

/* Перегрузка ссылочных параметров */
void sink(double & rl); // соответствует изменяемому lvalue
void sank(const double & r2) ; // соответствует изменяемому
// или константному lvalue, rvalue
void sunk(double && r3); // соответствует rvalue
/*Ссылочный параметр lvalue по имени rl соответствует изменяемому аргументу lvalue, 
такому как переменная double. Константный ссылочный параметр lvalue по имени r2 
соответствует изменяемому аргументу, константному аргументу lvalue и аргументу rvalue, такому как
сумма двух значений double. И, наконец, ссылка rvalue по имени гЗ соответствует rvalue.
Обратите внимание, что r2 может соответствовать той же разновидности аргументов, как
rl и rЗ. Возникает вопрос, а что случится, если перегрузить функцию с этими тремя типами
параметров? Ответ заключается в том, что будет предпринят поиск более точного 
соответствия:*/
void staff(double & rs); // соответствует изменяемому lvalue
voit staff(const double & res); // соответствует rvalue,
// константному lvalue
void stove(double & rl); // соответствует изменяемому lvalue
void stove(const double & r2); // соответствует константному lvalue
void stove(double && r3); // соответствует rvalue
/* Это позволяет настраивать поведение функции на основе того, каковой является природа
аргумента — lvalue, const или rvalue:*/
double x = 55.5;
const double у = 32.0;
stove(x); // вызывает stove(double &)
stove(у); // вызывает stove(const double &)
stove(x+y); // вызывает stove(double &&)
/* Если, скажем, опустить функцию stove (double &&), то stove (x+y) взамен 
приведет к вызову stove(const double &).
	Перегрузку целесообразно использовать для функций, которые выполняют в 
основном одни и те же действия, но с различными типами данных.
	Декорированием имен или искажением имен - это когда имя каждой функции 
шифруется на основе типов формальных параметров, указанных в прототипе функции.
Например:*/
long MyFunctionFoo(int, float);
// будет декодировано:
?MyFunctionFoo@@YAXH // может отличаться в разных компиляторах

/*	Шаблон функции — это обобщенное описание функции; т.е. шаблон
определяет функцию в терминах обобщенного типа, вместо которого может быть
подставлен определенный тип данных, такой как int или double. Передавая шаблону 
тип в качестве параметра, можно заставить компилятор сгенерировать функцию для 
этого конкретного типа.
	Шаблон для осуществления обмена значениями: */
template <typename AnyType>
void Swap(AnyType &a, AnyType &b)
{
AnyType temp;
temp = а;
а = b;
b = temp;
}
/* Первая строка указывает, что устанавливается шаблон, а произвольный тип 
данных получает имя AnyType. Ключевые слова template и typename являются 
обязательными; при этом вместо typename можно использовать ключевое слово class. 
Кроме того, должны присутствовать угловые скобки. Имя типа может быть любым 
(в этом примере — AnyType).
 Шаблоны должны использоваться в тех случаях, когда необходимы функции, 
 применяющие один и тот же алгоритм к различным типам данных. 
 Шаблоны функций не сокращают размеры исполняемых файлов.
 Преимущество шаблонов состоит в упрощении процесса генерации нескольких
определений функции, а также в увеличении его надежности.
	Перегруженные шаблоны
Не все аргументы шаблонов обязательно должны иметь обобщенный тип.
Не для всех типов в шаблоне алгоритм выглядит совершенно одинаково.*/
template <typename T>
void Swap(T &a, T &b) 
{
    T temp;
    temp = a;
    a = b;
    b = temp;
}

template <typename T>
void Swap(T a[], T b[], int n)
{
    T temp;
    for (int i = 0; i < n; i++)
    {
        temp = a[i];
        a[i] = b[i];
        b[i] = temp;
    }
}
/* Ограничения шаблонов
В приведенном ниже операторе предполагается, что для типа Т определена 
операция умножения, а это не так в случае, когда Т —
массив, указатель или структура: */
Т с = а*b;
/* Легко получить шаблон функции, который не может обрабатывать 
определенные типы. Иногда обобщение имеет смысл, даже если обычный 
синтаксис C++ не допускает его. Например, сложение структур, содержащих
координаты позиции, вполне оправдано, несмотря на то, что операция + 
для структур не определена.
	Явные специализации
 Можно предоставить специализированное определение функции, 
называемое явной специализацией, которое содержит требуемый код.
• Одно и то же имя может применяться для нешаблонной функции, шаблонной
функции и явной специализации шаблона, а также всех перегруженных версий
всего перечисленного.
• Прототип и определение явной специализации должно быть предварено
template <>, а также указывать имя обобщенного типа данных.
• Специализация переопределяет обычный шаблон, а нешаблонная функция 
переопределяет и специализацию, и шаблон.*/
struct job // например структура
{
	char name[40] ;
	double salary;
	int floor;
};

void Swap(job &, job &); // Прототип нешаблонной функции

template <typename T> // Прототип шаблона обобщенной функции
void Swap(T &, T &) ;

template <> void Swap<job> (job &, job &); // Явная специализация для типа job

/* Если существует более одного из перечисленных прототипов, компилятор отдает 
предпочтение нешаблонной версии перед явными специализациями и шаблонными 
версиями, и предпочитает явную специализацию перед версией, сгенерированной 
из шаблона.
	Конструкция <job> в выражении Swap<job> необязательна, поскольку типы 
аргументов функции указывают, что это специализация для структуры job.
Поэтому прототип может иметь и такой вид: */
template <> void Swap(job &, job &) ; // упрощенная форма

/*	Создание экземпляров и специализация
	Включение шаблона функции в код само по себе не приводит к генерации 
определения функции. Когда компилятор использует шаблон при генерации 
определения функции для определенного типа данных, результат называется 
созданием экземпляра шаблона. Шаблон — это не определение функции, но 
определенный экземпляр шаблона, например использующий int, является определением 
функции. Такой вид создания экземпляров шаблонов называется неявным созданием 
экземпляров, поскольку компилятор выясняет необходимость в построении 
определения, обнаруживая тот факт, что в программе используется функция 
Swap() с параметрами int.
	Явное создание экземпляров означает возможность дать компилятору прямую 
команду создать определенный экземпляр, например, Swap<int>(). Синтаксис 
предусматривает объявление с использованием нотации <> для указания типа и 
предварение объявления ключевым словом template: */
template void Swap<int>(int, int); // явное создание экземпляра

/* Два объявления ниже означают следующее: "не применять шаблон функции 
Swap(), чтобы сгенерировать определение функции; вместо этого воспользоваться 
отдельным специализированным определением функции, явно сформулированным 
для типа int". */
template <> Swap<int>(int &, int &); // явная специализация
template <> Swap(int &, int &) ; // эквивалентная явная специализация
/* Эти прототипы должны быть ассоциированы с собственными определениями 
функций. В объявлении явной специализации после ключевого слова template 
следует конструкция <>. В объявлении явного создания экземпляра она опускается.
	Попытка одновременного использования в одном файле или, в более общем 
случае — в компилируемом модуле, как явного создания экземпляра, так и 
явной специализации для одного и того же типа (типов) приведет к ошибке!
	Пример: шаблон */
template <class T>
Т Add(T а, Т b) // передача по значению
{
	return a + b;
}

int m = 6;
double x = 10.2;
/* не даст соответствия с вызовом функции Add(x, m), поскольку 
шаблон ожидает, что оба аргумента функции относятся к одному и тому же 
типу.*/
cout << Add<double>(x, m) << endl; // явное создание экземпляра
/* Но использование Add<double>(x, m) приводит к созданию экземпляра для 
типа double, и тип аргумента m приводится к double для соответствия второму 
параметру функции Add<double>(double, double).*/
// Пример:
template <typename T> // Прототип шаблона обобщенной функции
void Swap(T &, T &) ;
// Вызов:
Swap<double>(m, x) ; // не работает
/* В данном случае код работать не будет, т.к. первый формальный параметр, 
имея тип double &, не может ссылаться на переменную m типа int.
	Неявное и явное создание экземпляров, а также явная специализация, 
вместе называются специализацией, они представляют определение функции, в 
основу которого положены специфические типы данных.
	Пример: */
template <class T>		// прототип шаблона обобщенной функции
void Swap (T &, Т &) ;  // (для неявных экземпляров шаблона)

template <> void Swap<int>(job &, job &); // явная специализация для job

int main(void)
{
template void Swap<char> (char &, char &); // явное создание экземпляра для char
short a, b;
Swap(a,b); // неявное создание экземпляра шаблона для short
job n, m
swap (n, m) ; // использование явной специализации для job
char g, h
swap (g, h) ; // использование явного создания экземпляра шаблона для char
}
/* Когда компилятор обнаруживает явное создание экземпляра для char, он 
использует определение шаблона, чтобы сгенерировать версию функции Swap(), 
предназначенную для типа char. В остальных вызовах Swap() компилятор 
сопоставляет шаблон с используемыми в вызове фактическими аргументами. 
Например, когда компилятор обнаруживает вызов функции Swap(a,b), он генерирует 
версию этой функции для типа short, поскольку оба аргумента принадлежат этому 
типу. Когда компилятор обнаруживает вызов функции Swap(n, m), он использует 
отдельное определение (явную специализацию), предоставленное для типа job. 
Когда компилятор достигает вызова функции Swap(g, h), он применяет 
специализацию шаблона, которая уже была сгенерирована во время обработки 
явного создания экземпляра.
	Разрешение перегрузки.
• Фаза 1. Составьте список функций-кандидатов. Таковыми являются функции и
шаблоны функций с таким же именем, как у вызываемой функции.
• Фаза 2. Беря за основу список функций-кандидатов, составьте список 
подходящих функций. Таковыми являются функции с корректным количеством 
аргументов, для которых существует неявная последовательность преобразований
типов. Она включает случай точного совпадения типа каждого фактического
аргумента с типом соответствующего формального аргумента. Например, при
вызове функции с аргументом типа float это значение может быть приведено
к типу double для соответствия типу double формального параметра, а шаблон
может сгенерировать экземпляр функции для типа float.
• Фаза 3. Проверьте наличие наиболее подходящей функции. Если она есть, 
используйте ее. В противном случае вызов функции является ошибочным.
	Пример вызова функции с единственным аргументом: */
may('В'); // фактический аргумент имеет тип char
/* Прежде всего, компилятор отмечает все кандидаты, каковыми являются функции
и шаблоны функций с именем may(). Затем он находит среди них те, которые могут
быть вызваны с одним аргументом. Например, в этом случае проверку пройдут 
следующие функции, поскольку они имеют одно и то же имя и могут использоваться с
одним аргументом: */
void may(int); // #1
float may (float, float = 3); // #2
void may(char); // #3
char * may(const char *) ; // #4
char may (const char &) ; // #5
template<class T> void may (const T &) ; // #6
template<class T> void may(T *); // #7
/* При этом учитываются только сигнатуры, а не типы возвращаемых значений. 
Два кандидата (#4 и #7) из списка не подходят, поскольку целочисленный тип 
данных не может быть преобразован неявно (т.е. без явного приведения типов) 
в тип указателя. Оставшийся шаблон подходит, т.к. может быть использован для 
генерирования специализации, где в качестве Т принимается тип char. В итоге 
остается пять функций-кандидатов, каждая из которых может использоваться, так 
как если бы она была единственной объявленной функцией. Далее компилятор 
должен определить, какая из функций-кандидатов в наибольшей степени 
соответствует критерию отбора. Он анализирует преобразования, необходимые 
для того, чтобы аргумент обращения к функции соответствовал аргументу наиболее 
подходящего кандидата. В общем случае порядок следования от наилучшего к
наихудшему варианту можно представить следующим образом:
1. Точное соответствие, при этом обычные функции имеют приоритет перед 
шаблонами.
2. Преобразование за счет расширения (например, автоматические 
преобразования char и short в int и float в double).
3. Преобразование с помощью стандартных преобразований (например, 
преобразование int в char или long в double).
4. Преобразования, определяемые пользователем, такие как те, что определены в
объявлениях классов.
Например, функция #1 предпочтительнее функции #2, поскольку преобразование
char в int является расширением (см. главу 3), в то время как char в float —
это стандартное преобразование (также описанное в главе 3). Функции #3, #5 и #6 
предпочтительнее функций #1 и #2, т.к. они являются точными соответствиями. 
Функции #3 и #5 предпочтительнее варианта #6, потому что последний 
представляет собой шаблон.
	Точные соответствия и наилучшие соответствия
 Тривиальные преобразования, допустимые при точном соответствии:
 
Из фактического аргумента		В формальный аргумент
	Туре								Туре &
	Туре &								Туре
	Туре[]								*Туре
Туре(список-аргументов)			Туре(*)(список-аргументов)
	Type							const Type
	Type							volatile Type
	Туре *							const Type *
	Туре *							volatile Type *

Например, фактический аргумент int является точным соответствием 
формальному параметру int &. Туре может быть чем-то подобным char &,
так что эти правила включают преобразование char & в const char &. Запись 
Туре(список-аргументов) означает, что имя функции как фактический аргумент 
соответствует указателю на функцию, переданному в качестве формального 
параметра, при условии, что оба они имеют один и тот же возвращаемый тип и 
список аргументов.

*/