// str1.cpp -- введение в класс string
#include <iostream>
#include <string>

// Использование различных конструкторов класса string
int main()
{
    using namespace std;
    string one("Lottery Winner!");          // ctor #1
/* Инициализация объекта string обычной строкой в стиле С и её вывод на экран с помощью 
перегруженной операции<< */
    cout << "one: " << one << endl;         // overloaded <<
    string two(20, '$');                    // ctor #2
// Инициализирует объект two типа string строкой, состоящей из 20 символов $
    cout << "two: " << two << endl;
    string three(one);                      // ctor #3
// Конструктор копирования инициализирует объект three типа string объектом one этого же типа
    cout << "three: " << three << endl;
// Перегруженная операция += дописывает строку " Oops!" к строке one:
    one += " Oops!";								// overloaded +=
/* Операция += имеет несколько перегрузок и с ее помощью можно добавлять как 
объекты string, так и отдельные символы. */
    cout << "one: " << one << endl;
/* Операция = тоже является перегружаемой, что позволяет присвоить объекту типа string другой
объект этого же типа, строку в стиле С или простое значение типа char. */
    two = "Sorry! That was ";
/* Перегрузка операции [], позволяет обращаться к отдельным символам объекта типа string,
используя нотацию массива: */
    three[0] = 'P';
// Конструктор по умолчанию создает пустую строку, которой впоследствии может быть присвоено значение:
    string four;                            // ctor #4
/* Операция + используется для создания временного объекта string, который затем с помощью
перегруженной операции = присваивается объекту four: */ 
    four = two + three;                     // overloaded +, =
/* Операция + объединяет два операнда в один объект типа string. Эта операция имеет несколько
перегрузок, поэтому второй операнд может быть объектом типа string, строкой в стиле С или
значением типа char. */
    cout << "four: " << four << endl;
    char alls[] = "All's well that ends well";
/* Конструктор принимает в качестве аргументов строку в стиле С и 
целочисленное значение, которое указывает количество копируемых символов: */
    string five(alls, 20);                  // ctor #5
/* Если количество символов превышает длину строки в стиле С, запрошенное количество символов все
равно копируется. Поэтому замена значения 20 значением 40 в приведенном примере привела бы к
копированию в конец строки five пятнадцати бессмысленных символов. */
    cout << "five: " << five << "!\n";
// Использует шаблон template<class Iter> string(Iter begin, Iter end); в качестве аргумента:
    string six(alls + 6, alls + 10);        // ctor #6
/* begin и end выступают в роли указателей на начало и конец диапазона памяти. Конструктор применяет
значения элементов памяти, хранящиеся между позициями, указанными аргументами begin и end, для 
инициализации создаваемого им объекта типа string. Запись [begin, end), заимствованная из математики,
означает, что диапазон включает в себя begin, но не включает end. end указывает на позицию, следующую
за последним значением, которое должно быть использовано. Поскольку имя массива является указателем,
значения alls + 6 и alls + 10 будут иметь тип char *, и поэтому в шаблоне тип Iter заменяется типом char* .*/
    cout << "six: " << six  << ", ";
/* Следующий код работать не будет: string seven(five + 6, five + 10);
Причина в том, что имя объекта, в отличие от имени массива, не является адресом объекта. Следовательно,
five — не указатель, и выражение fіѵе + 6 не имеет смысла. Однако five[6] является значением типа char,
поэтому выражение &five[6] — это адрес, который может использоваться в качестве аргумента конструктора: */
    string seven(&five[6], &five[10]);      // ctor #6 again
    cout << "seven: " << seven << "...\n";
/* Копирует 16 символов из объекта four в объект eight, начиная с
седьмой позиции (восьмого символа) объекта four: */
    string eight(four, 7, 16);              // ctor #7
    cout << "eight: " << eight << " in motion!" << endl;
    return 0;
}