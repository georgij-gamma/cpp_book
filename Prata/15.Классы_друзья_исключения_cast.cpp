/* 	Дружественные классы.
 Другом может быть класс. В этом случае все методы дружественного класса имеют 
доступ к закрытым и защищенным методам исходного класса. Но в качестве 
дружественных функций класса можно указать и лишь отдельные функции-члены 
другого класса. Класс сам определяет, какие функции, функции-члены или классы 
являются для него друзьями; дружественные отношения нельзя навязать извне.
  Дружественные функции-члены.
 Можно сделать дружественными лишь отдельные члены класса, а не весь класс 
целиком. Понадобится следить за порядком различных определений и объявлений: */
class Tv
{
	...
	friend void Remote::set_chan(Tv & t, int c);
};
/* Однако для обработки этого оператора компилятор уже должен просмотреть 
определение класса Remote. Иначе он не будет знать, что Remote является классом,
а setchan() — методом этого класса. Это наводит на мысль поместить определение
Remote перед определением Тѵ. Но методы класса Remote ссылаются на объекты Тѵ,
а это значит, что определение Тѵ должно находиться перед определением Remote.
Избежать циклических ссылок позволяет упреждающее (предварительное) объявление.
Для этого перед определением Remote необходимо вставить следующий оператор: */
class Tv; 				// упреждающее объявление
// В результате получится вот что:
class Tv; 				// упреждающее объявление
class Remote { ... };
class Tv { ... };
// А можно ли вместо этого применить такой порядок?
class Remote; 			// упреждающее объявление
class Tv { ... };
class Remote { ... };
/* Оказывается, что нельзя. Причина в том, что, как было сказано, когда компилятор
видит, что метод класса Remote объявлен как дружественный в объявлении класса Тѵ,
он должен уже просмотреть объявление всего класса Remote и, в частности, метода
set_chan(). Есть и другая сложность. В объявлении Remote: */
void onoff (Tv & t) { t.onoff(); }
/* Здесь вызывается метод Тѵ, и поэтому компилятор должен заранее просмотреть
объявление класса Тѵ, чтобы знать, какие методы он содержит. Но, как мы видели,
за этим объявлением должно следовать объявление Remote. Решением в данном случае
может быть объявление методов Remote до определения класса Тѵ и их 
непосредственные определения после класса Тѵ: */
class Тѵ; // упреждающее объявление
class Remote { ... }; // методы, использующие Тѵ, в виде только прототипов
class Тѵ { ... };
// Определения методов Remote
Прототипы Remote выглядят следующим образом:
void onoff (Tv & t);
/* Для обработки этого прототипа компилятору нужно лишь знать, что Тѵ является
классом, и упреждающее объявление предоставляет ему эту информацию. Когда 
компилятор дойдет до непосредственных определений методов, объявление класса Тѵ
им уже прочитано, и он будет располагать информацией, необходимой для компиляции
этих методов. Ключевое слово inline в определениях методов также позволяет 
сделать методы встроенными. */
// tvfm.h -- классы Тѵ и Remote и дружественная функция-член
#ifndef TVFM_H_
#define TVFM_H_
class Tv;                                   // упреждающее объявление
class Remote
{
public:
    enum State { Off, On            };
    enum       { MinVal,MaxVal = 20 };
    enum       { Antenna, Cable     };
    enum       { TV, DVD            };
private:
    int mode;                               // управление TV или DVD
public:
    Remote(int m = TV) : mode(m) {}
    bool volup      (Tv & t);               // только прототип
    bool voldown    (Tv & t);
    void onoff      (Tv & t);
    void chanup     (Tv & t);
    void chandown   (Tv & t);
    void set_mode   (Tv & t);
    void set_input  (Tv & t);
    void set_chan   (Tv & t, int c);
};

class Tv
{
public:
    friend void Remote::set_chan(Tv & t, int c);    // дружественный лишь отдельный член класса Remote
    enum State { Off, On            };
    enum       { MinVal,MaxVal = 20 };
    enum       { Antenna, Cable     };
    enum       { TV, DVD            };
    Tv(int s = Off, int mc = 125) : state(s), volume(5), maxchannel(mc), channel(2), mode(Cable), input(TV) {}
    void onoff()                    { state = (state == On) ? Off : On; } // {state ^= 1;} // XOR
    bool ison() const               { return   state == On; }
    bool volup();                                   // громкость++
    bool voldown();                                 // громкость--
    void chanup();                                  // канал++
    void chandown();                                // канал--
    void set_mode()                 { mode  = (mode  == Antenna) ? Cable : Antenna; }
    void set_input()                { input = (input == TV)      ? DVD   : TV;      }
    void settings() const;                          // отображение всех настроек
private:
    int state;                                      // On или Off
    int volume;                                     // дискретные уровни громкости
    int maxchannel;                                 // максимальное количество каналов
    int channel;                                    // текущий канал
    int mode;                                       // эфирное или кабельное телевидение
    int input;                                      // TV или DVD
};
// Методы Remote как встроенные функции:
inline bool Remote::volup     (Tv & t)        { return t.volup();   } // громкость++
inline bool Remote::voldown   (Tv & t)        { return t.voldown(); } // громкость--
inline void Remote::onoff     (Tv & t)        { t.onoff();          } // вкл/выкл
inline void Remote::chanup    (Tv & t)        { t.chanup();         } // канал++
inline void Remote::chandown  (Tv & t)        { t.chandown();       } // канал--
inline void Remote::set_mode  (Tv & t)        { t.set_mode();       } // настр.источника Antenna/Cable
inline void Remote::set_input (Tv & t)        { t.set_input();      } // настр.входа DVD/TV
inline void Remote::set_chan  (Tv & t, int c) { t.channel = c;      } // настр.текущий канал
#endif
/* Встроенные функции имеют внутреннее связывание, т.е. определения функций 
должны находиться в том же файле, где они используются. Здесь встроенные 
определения находятся в заголовочном файле, поэтому при включении этого файла 
в файл, использующий определения, эти определения попадут в нужное место.
Можно поместить определения и в файл реализации, но тогда нужно удалить 
ключевое слово inline, чтобы выполнялось внешнее связывание функций.
  Дружественные отношения.
 Некоторые методы класса Remote могут, воздействовать на объект Тѵ, а некоторые
методы класса Тѵ могут воздействовать на объект Remote. Этого можно добиться, 
сделав классы дружественными друг другу. То есть Тѵ будет другом для Remote, a 
Remote будет другом для Тѵ. Метод класса Тѵ, использующий объект Remote, 
может быть объявлен до объявления класса Remote, но должен быть определён после 
объявления, чтобы у компилятора была вся информация, необходимая для компиляции
метода. Структура кода будет выглядеть следующим образом: */
class Tv
{
friend class Remote;
public:
	void buzz(Remote & r);
	...
};
class Remote
{
friend class Tv;
public:
	void Bool volup(Tv & t) { t.volup(); }
	...
};
inline void Tv::buzz(Remote & r) { ... }
/* Поскольку объявление Remote расположено после объявления Тѵ, метод
Remote::volup() можно определить в объявлении класса. Однако метод Тѵ::buzz()
должен быть определен вне объявления класса Тѵ, чтобы это определение находилось
после объявления класса Remote. Если нет необходимости вставлять встроенное 
определение buzz(), его нужно определить в отдельном файле с определениями методов.
  Общие друзья.
 Когда функции нужен доступ к приватным данным двух разных классов, по идее такая 
функция должна быть функцией-членом каждого из этих классов, но это невозможно. 
Она может быть членом одного класса и другом другого. Но иногда лучше сделать ее 
дружественной обоим классам. Предположим, что имеется класс Probe, представляющий 
некий программируемый измерительный прибор, и класс Analyzer, представляющий 
программируемый анализатор. У каждого прибора есть внутренние часы, и их нужно 
синхронизировать. */
class Analyzer; // упреждающее объявление
class Probe
{
	friend void sync(Analyzer & a, const Probe & p); // синхронизация а с р
	friend void sync(Probe & p, const Analyzer & a); // синхронизация pea
};
class Analyzer
{
	friend void sync(Analyzer & a, const Probe & p); // синхронизация а с р
	friend void sync(Probe & p, const Analyzer & a); // синхронизация р с а
};
// Определение дружественных функций:
inline void sync(Analyzer & a, const Probe & p) { ... }
inline void sync(Probe & p, const Analyzer & a) { ... }
/* Когда компилятор доходит до объявлений друзей в объявлении класса Probe, он, в
силу наличия упреждающего объявления, уже знает, что Analyzer является классом.
	Вложенные классы.
 C++ позволяет помещать объявление класса внутрь другого класса. Класс, объявленный 
внутри другого класса, называется вложенным классом. Вложенные классы ограничивают 
область видимости имен пределами класса и позволяют избежать конфликта имен. 
Функции-члены класса, содержащего вложенное объявление, могут создавать и 
использовать объекты вложенного класса. Извне взаимодействовать с вложенными 
классами можно, только если они объявлены в открытой части класса и только с 
использованием операции разрешения контекста. Не путайте вложение классов и 
включение. Включение означает наличие объекта класса в качестве члена другого 
класса. Вложение не создает член класса, а определяет тип, который известен 
лишь локально в объемлющем классе. Обычно вложенные классы создаются как 
вспомогательные при реализации другого класса, чтобы избежать конфликта имен: */
class Queue
{
private:
// Определения области действия класса
// Node — это вложенное определение структуры, локальное для данного класса
	struct Node { Item item; struct Node *next; };
	...
};
/* Поскольку структура — это класс, члены которого по умолчанию являются 
общедоступными, Node действительно представляет собой вложенный класс. Однако это
определение не использует возможности вложенных классов. В частности, у него нет
явного конструктора. Давайте восполним этот недостаток. Сначала нужно найти, где 
в примере Queue создается объект Node. Просмотрев объявление класса и определения 
методов, можно увидеть, что единственное место, где создаются объекты Node —
это метод enqueue(): */
bool Queue: :enqueue (const Item & item)
{
	if (isfull())
		return false;
	Node * add = new Node; // создание узла
	// В случае сбоя операция new генерирует исключение std::bad_alloc
	add->item = item; // установка указателей на узлы
	add->next = NULL;
}
/* В этом коде после создания объекта Node его членам явно присваиваются 
значения. Такие действия уместнее выполнять в конструкторе. Зная, где и как 
понадобится конструктор, можно написать соответствующее определение: */
class Queue
{ // Объявления с областью видимости класса
// Node — вложенный класс, локальный по отношению к данному
	class Node
	{
	public:
		Item item;
		Node * next;
		Node (const Item & i) : item(i), next(0) {}
	};
	...
}; // Теперь перепишем метод enqueue() с применением конструктора:
bool Queue::enqueue (const Item & item)
{
	if (isfull())
	return false;
	Node * add = new Node(item); // создание и инициализация узла
// В случае сбоя операция new генерирует исключение std::bad_alloc
}
/* Это сделает код enqueue() немного короче и надежнее, поскольку инициализация
проводится автоматически, и программисту не нужно запоминать все необходимые
действия. В данном примере конструктор определен в объявлении класса. Если потребуется
определить его в файле методов, то тогда определение должно учитывать, что класс
Node определен внутри класса Queue. Это делается с помощью двух операций 
разрешения контекста: */
Queue::Node::Node(const Item & i) : item(i), next(0) {}
/*  Вложенные классы и доступ.
 С вложенными классами связаны два вида доступа. Во-первых, место объявления
вложенного класса определяет его область видимости — т.е. указывает, какие части
программы могут создавать объекты этого класса. Во-вторых, как и для любого другого
класса, доступ к членам класса определяют открытый, закрытый и защищенный 
разделы класса. Место и способ использования вложенного класса зависят как от области
видимости класса, так и от управления доступом.
  Область видимости.
 Если вложенный класс определен в закрытом разделе другого класса, он известен
только объемлющему классу. В последнем примере это относится к классу Node, 
вложенному в объявление класса Queue. Члены класса Queue могут использовать объекты
Node и указатели на объекты Node, а другие части программы даже не подозревают о
существовании класса Node. Если от Queue будет порожден другой класс, то Node для
этого класса будет также невидим, поскольку производный класс не имеет прямого
доступа к закрытой части базового класса.
 Если вложенный класс объявлен в защищенном разделе другого класса, он будет видимым 
для этого класса, но не видимым извне. Поскольку вложенный класс известен во всем 
базовом классе, вовне его нужно использовать с квалификатором класса. */
class Team					// Команда
{
public:
	class Coach { ... };		// Тренер
...
}
// Для создания объекта Coach вне класса Team можно поступить следующим образом:
Team::Coach forhire;			// создание объекта Coach за пределами класса Team
/* Подобные рассуждения об области видимости применимы и к вложенным 
структурам и перечислимым типам. Многие программисты используют открытые 
перечислимые типы для задания констант класса, которые могут применяться в клиентских
классах. Например, как уже было показано, многие реализации классов, созданные
для поддержки средства iostream, используют эту технику для создания различных
вариантов форматирования.
 Свойства области видимости для вложенных классов, структур и перечислений: */
----------------------------------------------------------------------------------------------------
					|Доступен для		|Доступен для класса,	|							|
Где определен:		|вложенного класса:	|порожденного от		|Доступен извне:			|
____________________|___________________|вложенного класса:		|___________________________|
Закрытый раздел		|		Да			|		Нет				|	Нет						|
Защищенный раздел	|		Да			|		Да				|	Нет						|
Открытый раздел		|		Да 			|		Да				|Да,с квалификатором класса	|
----------------------------------------------------------------------------------------------------
/* Управление доступом.
 Если класс оказывается в области видимости, вступают в действие правила 
управления доступом. Для вложенных классов действуют те же правила доступа, что и
для обычных классов. Объявление класса Node внутри объявления класса Queue не
дает классу Queue привилегированный доступ к Node, как и классу Node при доступе
к Queue. To есть объект класса Queue может обращаться только к открытым членам
объекта Node. По этой причине в примере с Queue все члены класса Node сделаны
открытыми. Это идет вразрез с обычной практикой, когда члены данных создаются
закрытыми, но класс Node не виден за пределами класса Queue, поскольку объявлен в
его закрытой части. Значит, методы Queue могут непосредственно обращаться к 
членам Node, а клиенты, использующие класс Queue, не могут. Место объявления 
класса определяет область видимости этого класса. Если какой-то класс находится 
в области видимости, доступ программы к членам вложенного класса определяется 
обычными правилами доступа — открытый, закрытый, защищенный, дружественный.
  Вложение в шаблонах. */
// queuetp.h — шаблон очереди с вложенным классом
#ifndef QUEUETP_H_
#define QUEUETP_H_
template <class Item>
class QueueTP
{
private:
    enum {Q_SIZE = 10};
    class Node                              // Node - определение вложенного класса:
    {
    public:
        Item item;
        Node * next;
// занесение значения в часть данных узла; занесение в указатель на следующий узел NULL или nullptr:
        Node(const Item & i) : item(i), next(0) {}
    };
// Закрытые члены класса
    Node * front;                           // указатель на начало QueueTp
    Node * rear;                            // указатель на конец  QueueTp
    int items;                              // текущее количество элементов в QueueTp
    const int qsize;                        // максимальное количество элементов в QueueTp
/* Упреждающие объявления для предотвращения открытого копирования. Этот код переопределяет 
стандартные определения методов, которые в противном случае генерируются автоматически. 
Поскольку это закрытые методы, они не могут вызываться внешним кодом: */
    QueueTP(const QueueTP & q)  : qsize(0)  {}
    QueueTP & operator=(const QueueTP & q)  { return *this; }
public:
    QueueTP(int qs = Q_SIZE);               // создание очереди с предельным размером qs
    ~QueueTP();
    bool isempty() const                    { return items == 0;     } // проверка на пустоту
    bool isfull() const                     { return items == qsize; } // проверка на заполнение
    int queuecount() const                  { return items;          } // определения количества элементов
    bool enqueue(const Item &item);         // добавление item в конец
    bool dequeue(Item &item);               // удаление item из начала
};
// Методы QueueTP:
template <class Item>
QueueTP<Item>::QueueTP(int qs) : qsize(qs)
{
    front = rear = 0;                       // or nullptr
    items = 0;
}
template <class Item>
QueueTP<Item>::~QueueTP()                   // явный деструктор поочередно удаляет все узлы, начиная с начала списка
{
    Node * temp;
    while (front != 0)                      // пока очередь не пуста
    {
        temp = front;                       // сохранение адреса первого элемента
        front = front->next;                // сдвиг указателя на следующий элемент
        delete temp;                        // удаление предыдущего первого
    }
}
// Добавление элемента в очередь
template <class Item>
bool QueueTP<Item>::enqueue(const Item & item)
{
	if (isfull())			                // если очередь уже полна
		return false;                       // завершить программу
	Node * add = new Node(item);	        	// создание узла; при неудачном выполнении операция new
                                            // генерирует исключение std::bad_alloc.
	items++;					            	// увеличить счетчик элементов (items) на единицу
	if (front == NULL)		                // если очередь пуста,
		front = add;		                // элемент помещается в начало
	else						            // иначе он помещается в конец 
		rear->next = add; /* Присоединить узел в конец очереди; этот процесс состоит из двух частей:
1. Созданный узел привязывается к другим узлам в списке. Для этого в указатель next предыдущего 
   конечного узла заносится ссылка на новый конечный узел.
2. В указатель-член rear объекта QueueTp заносится ссылка на новый узел, чтобы иметь доступ 
   непосредственно к последнему узлу. Если очередь пуста, то ссылку на новый узел необходимо 
   поместить и в указатель front. (Если в очереди всего один узел, то он является и начальным, и конечным.) */			
	rear = add;				                // указатель конца указывает на новый узел
    return true;
}
// Помещение первого элемента в переменную item и удаление его из очереди
template <class Item>
bool QueueTP<Item>::dequeue(Item & item)
{
	if (front == NULL)		// если очередь уже пуста, завершить программу
		return false;
	item = front->item;		/* часть данных узла front(первый элемент из очереди) заносится в item —
ссылочную переменную, переданную в метод. */
	items--;					// уменьшить счетчик элементов (items) на единицу
	Node * temp = front;		// сохранение местоположения первого элемента (адреса front) для последующего удаления
	front = front->next;		/* Удалить узел из очереди: сдвиг указателя начала на следующий элемент. В 
указатель-член front объекта QueueTp заносится указатель на следующий узел, адрес которого находится в front->next. */
	delete temp;			// удаление предыдущего первого элемента
	if (items == 0)			// если список теперь пуст, то занести в rear значение NULL. (Начальный 
		rear = NULL;		// указатель уже равен NULL после установки front->next).
    return true; 
}
#endif
// Класс Node определен через общий тип Item. Поэтому при наличии объявления:
QueueTp<double> dq;
// Node будет содержать значения типа double, а объявление:
QueueTp<char> cq;
/* приведет к тому, что Node будет хранить значения типа char. Эти два класса
Node определены в двух раздельных классах QueueTP, поэтому конфликт имен
не возникает, и один узел имеет тип QueueTP<double>::Node, а другой —
тип QueueTP<char>::Node.
	Исключения.
 
























