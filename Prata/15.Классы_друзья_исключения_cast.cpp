/* 	Дружественные классы.
 Другом может быть класс. В этом случае все методы дружественного класса имеют 
доступ к закрытым и защищенным методам исходного класса. Но в качестве 
дружественных функций класса можно указать и лишь отдельные функции-члены 
другого класса. Класс сам определяет, какие функции, функции-члены или классы 
являются для него друзьями; дружественные отношения нельзя навязать извне.
  Дружественные функции-члены.
 Можно сделать дружественными лишь отдельные члены класса, а не весь класс 
целиком. Понадобится следить за порядком различных определений и объявлений: */
class Tv
{
	...
	friend void Remote::set_chan(Tv & t, int c);
};
/* Однако для обработки этого оператора компилятор уже должен просмотреть 
определение класса Remote. Иначе он не будет знать, что Remote является классом,
а setchan() — методом этого класса. Это наводит на мысль поместить определение
Remote перед определением Тѵ. Но методы класса Remote ссылаются на объекты Тѵ,
а это значит, что определение Тѵ должно находиться перед определением Remote.
Избежать циклических ссылок позволяет упреждающее (предварительное) объявление.
Для этого перед определением Remote необходимо вставить следующий оператор: */
class Tv; 				// упреждающее объявление
// В результате получится вот что:
class Tv; 				// упреждающее объявление
class Remote { ... };
class Tv { ... };
// А можно ли вместо этого применить такой порядок?
class Remote; 			// упреждающее объявление
class Tv { ... };
class Remote { ... };
/* Оказывается, что нельзя. Причина в том, что, как было сказано, когда компилятор
видит, что метод класса Remote объявлен как дружественный в объявлении класса Тѵ,
он должен уже просмотреть объявление всего класса Remote и, в частности, метода
set_chan(). Есть и другая сложность. В объявлении Remote: */
void onoff (Tv & t) { t.onoff(); }
/* Здесь вызывается метод Тѵ, и поэтому компилятор должен заранее просмотреть
объявление класса Тѵ, чтобы знать, какие методы он содержит. Но, как мы видели,
за этим объявлением должно следовать объявление Remote. Решением в данном случае
может быть объявление методов Remote до определения класса Тѵ и их 
непосредственные определения после класса Тѵ: */
class Тѵ; // упреждающее объявление
class Remote { ... }; // методы, использующие Тѵ, в виде только прототипов
class Тѵ { ... };
// Определения методов Remote
Прототипы Remote выглядят следующим образом:
void onoff (Tv & t);
/* Для обработки этого прототипа компилятору нужно лишь знать, что Тѵ является
классом, и упреждающее объявление предоставляет ему эту информацию. Когда 
компилятор дойдет до непосредственных определений методов, объявление класса Тѵ
им уже прочитано, и он будет располагать информацией, необходимой для компиляции
этих методов. Ключевое слово inline в определениях методов также позволяет 
сделать методы встроенными. */
// tvfm.h -- классы Тѵ и Remote и дружественная функция-член
#ifndef TVFM_H_
#define TVFM_H_
class Tv;                                   // упреждающее объявление
class Remote
{
public:
    enum State { Off, On            };
    enum       { MinVal,MaxVal = 20 };
    enum       { Antenna, Cable     };
    enum       { TV, DVD            };
private:
    int mode;                               // управление TV или DVD
public:
    Remote(int m = TV) : mode(m) {}
    bool volup      (Tv & t);               // только прототип
    bool voldown    (Tv & t);
    void onoff      (Tv & t);
    void chanup     (Tv & t);
    void chandown   (Tv & t);
    void set_mode   (Tv & t);
    void set_input  (Tv & t);
    void set_chan   (Tv & t, int c);
};

class Tv
{
public:
    friend void Remote::set_chan(Tv & t, int c);    // дружественный лишь отдельный член класса Remote
    enum State { Off, On            };
    enum       { MinVal,MaxVal = 20 };
    enum       { Antenna, Cable     };
    enum       { TV, DVD            };
    Tv(int s = Off, int mc = 125) : state(s), volume(5), maxchannel(mc), channel(2), mode(Cable), input(TV) {}
    void onoff()                    { state = (state == On) ? Off : On; } // {state ^= 1;} // XOR
    bool ison() const               { return   state == On; }
    bool volup();                                   // громкость++
    bool voldown();                                 // громкость--
    void chanup();                                  // канал++
    void chandown();                                // канал--
    void set_mode()                 { mode  = (mode  == Antenna) ? Cable : Antenna; }
    void set_input()                { input = (input == TV)      ? DVD   : TV;      }
    void settings() const;                          // отображение всех настроек
private:
    int state;                                      // On или Off
    int volume;                                     // дискретные уровни громкости
    int maxchannel;                                 // максимальное количество каналов
    int channel;                                    // текущий канал
    int mode;                                       // эфирное или кабельное телевидение
    int input;                                      // TV или DVD
};
// Методы Remote как встроенные функции:
inline bool Remote::volup     (Tv & t)        { return t.volup();   } // громкость++
inline bool Remote::voldown   (Tv & t)        { return t.voldown(); } // громкость--
inline void Remote::onoff     (Tv & t)        { t.onoff();          } // вкл/выкл
inline void Remote::chanup    (Tv & t)        { t.chanup();         } // канал++
inline void Remote::chandown  (Tv & t)        { t.chandown();       } // канал--
inline void Remote::set_mode  (Tv & t)        { t.set_mode();       } // настр.источника Antenna/Cable
inline void Remote::set_input (Tv & t)        { t.set_input();      } // настр.входа DVD/TV
inline void Remote::set_chan  (Tv & t, int c) { t.channel = c;      } // настр.текущий канал
#endif
/* Встроенные функции имеют внутреннее связывание, т.е. определения функций 
должны находиться в том же файле, где они используются. Здесь встроенные 
определения находятся в заголовочном файле, поэтому при включении этого файла 
в файл, использующий определения, эти определения попадут в нужное место.
Можно поместить определения и в файл реализации, но тогда нужно удалить 
ключевое слово inline, чтобы выполнялось внешнее связывание функций.
  Дружественные отношения.
 Некоторые методы класса Remote могут, воздействовать на объект Тѵ, а некоторые
методы класса Тѵ могут воздействовать на объект Remote. Этого можно добиться, 
сделав классы дружественными друг другу. То есть Тѵ будет другом для Remote, a 
Remote будет другом для Тѵ. Метод класса Тѵ, использующий объект Remote, 
может быть объявлен до объявления класса Remote, но должен быть определён после 
объявления, чтобы у компилятора была вся информация, необходимая для компиляции
метода. Структура кода будет выглядеть следующим образом: */
class Tv
{
friend class Remote;
public:
	void buzz(Remote & r);
	...
};
class Remote
{
friend class Tv;
public:
	void Bool volup(Tv & t) { t.volup(); }
	...
};
inline void Tv::buzz(Remote & r) { ... }
/* Поскольку объявление Remote расположено после объявления Тѵ, метод
Remote::volup() можно определить в объявлении класса. Однако метод Тѵ::buzz()
должен быть определен вне объявления класса Тѵ, чтобы это определение находилось
после объявления класса Remote. Если нет необходимости вставлять встроенное 
определение buzz(), его нужно определить в отдельном файле с определениями методов.
  Общие друзья.
 Когда функции нужен доступ к приватным данным двух разных классов, по идее такая 
функция должна быть функцией-членом каждого из этих классов, но это невозможно. 
Она может быть членом одного класса и другом другого. Но иногда лучше сделать ее 
дружественной обоим классам. Предположим, что имеется класс Probe, представляющий 
некий программируемый измерительный прибор, и класс Analyzer, представляющий 
программируемый анализатор. У каждого прибора есть внутренние часы, и их нужно 
синхронизировать. */
class Analyzer; // упреждающее объявление
class Probe
{
	friend void sync(Analyzer & a, const Probe & p); // синхронизация а с р
	friend void sync(Probe & p, const Analyzer & a); // синхронизация pea
};
class Analyzer
{
	friend void sync(Analyzer & a, const Probe & p); // синхронизация а с р
	friend void sync(Probe & p, const Analyzer & a); // синхронизация р с а
};
// Определение дружественных функций:
inline void sync(Analyzer & a, const Probe & p) { ... }
inline void sync(Probe & p, const Analyzer & a) { ... }
/* Когда компилятор доходит до объявлений друзей в объявлении класса Probe, он, в
силу наличия упреждающего объявления, уже знает, что Analyzer является классом.
	Вложенные классы.
 C++ позволяет помещать объявление класса внутрь другого класса. Класс, объявленный 
внутри другого класса, называется вложенным классом. Вложенные классы ограничивают 
область видимости имен пределами класса и позволяют избежать конфликта имен. 
Функции-члены класса, содержащего вложенное объявление, могут создавать и 
использовать объекты вложенного класса. Извне взаимодействовать с вложенными 
классами можно, только если они объявлены в открытой части класса и только с 
использованием операции разрешения контекста. Не путайте вложение классов и 
включение. Включение означает наличие объекта класса в качестве члена другого 
класса. Вложение не создает член класса, а определяет тип, который известен 
лишь локально в объемлющем классе. Обычно вложенные классы создаются как 
вспомогательные при реализации другого класса, чтобы избежать конфликта имен: */
class Queue
{
private:
// Определения области действия класса
// Node — это вложенное определение структуры, локальное для данного класса
	struct Node { Item item; struct Node *next; };
	...
};
/* Поскольку структура — это класс, члены которого по умолчанию являются 
общедоступными, Node действительно представляет собой вложенный класс. Однако это
определение не использует возможности вложенных классов. В частности, у него нет
явного конструктора. Давайте восполним этот недостаток. Сначала нужно найти, где 
в примере Queue создается объект Node. Просмотрев объявление класса и определения 
методов, можно увидеть, что единственное место, где создаются объекты Node —
это метод enqueue(): */
bool Queue: :enqueue (const Item & item)
{
	if (isfull())
		return false;
	Node * add = new Node; // создание узла
	// В случае сбоя операция new генерирует исключение std::bad_alloc
	add->item = item; // установка указателей на узлы
	add->next = NULL;
}
/* В этом коде после создания объекта Node его членам явно присваиваются 
значения. Такие действия уместнее выполнять в конструкторе. Зная, где и как 
понадобится конструктор, можно написать соответствующее определение: */
class Queue
{ // Объявления с областью видимости класса
// Node — вложенный класс, локальный по отношению к данному
	class Node
	{
	public:
		Item item;
		Node * next;
		Node (const Item & i) : item(i), next(0) {}
	};
	...
}; // Теперь перепишем метод enqueue() с применением конструктора:
bool Queue::enqueue (const Item & item)
{
	if (isfull())
	return false;
	Node * add = new Node(item); // создание и инициализация узла
// В случае сбоя операция new генерирует исключение std::bad_alloc
}
/* Это сделает код enqueue() немного короче и надежнее, поскольку инициализация
проводится автоматически, и программисту не нужно запоминать все необходимые
действия. В данном примере конструктор определен в объявлении класса. Если потребуется
определить его в файле методов, то тогда определение должно учитывать, что класс
Node определен внутри класса Queue. Это делается с помощью двух операций 
разрешения контекста: */
Queue::Node::Node(const Item & i) : item(i), next(0) {}
/*  Вложенные классы и доступ.
 С вложенными классами связаны два вида доступа. Во-первых, место объявления
вложенного класса определяет его область видимости — т.е. указывает, какие части
программы могут создавать объекты этого класса. Во-вторых, как и для любого другого
класса, доступ к членам класса определяют открытый, закрытый и защищенный 
разделы класса. Место и способ использования вложенного класса зависят как от области
видимости класса, так и от управления доступом.
  Область видимости.
 Если вложенный класс определен в закрытом разделе другого класса, он известен
только объемлющему классу. В последнем примере это относится к классу Node, 
вложенному в объявление класса Queue. Члены класса Queue могут использовать объекты
Node и указатели на объекты Node, а другие части программы даже не подозревают о
существовании класса Node. Если от Queue будет порожден другой класс, то Node для
этого класса будет также невидим, поскольку производный класс не имеет прямого
доступа к закрытой части базового класса.
 Если вложенный класс объявлен в защищенном разделе другого класса, он будет видимым 
для этого класса, но не видимым извне. Поскольку вложенный класс известен во всем 
базовом классе, вовне его нужно использовать с квалификатором класса. */
class Team					// Команда
{
public:
	class Coach { ... };		// Тренер
...
}
// Для создания объекта Coach вне класса Team можно поступить следующим образом:
Team::Coach forhire;			// создание объекта Coach за пределами класса Team
/* Подобные рассуждения об области видимости применимы и к вложенным 
структурам и перечислимым типам. Многие программисты используют открытые 
перечислимые типы для задания констант класса, которые могут применяться в клиентских
классах. Например, как уже было показано, многие реализации классов, созданные
для поддержки средства iostream, используют эту технику для создания различных
вариантов форматирования.
 Свойства области видимости для вложенных классов, структур и перечислений: */
----------------------------------------------------------------------------------------------------
					|Доступен для		|Доступен для класса,	|							|
Где определен:		|вложенного класса:	|порожденного от		|Доступен извне:			|
____________________|___________________|вложенного класса:		|___________________________|
Закрытый раздел		|		Да			|		Нет				|	Нет						|
Защищенный раздел	|		Да			|		Да				|	Нет						|
Открытый раздел		|		Да 			|		Да				|Да,с квалификатором класса	|
----------------------------------------------------------------------------------------------------
/* Управление доступом.
 Если класс оказывается в области видимости, вступают в действие правила 
управления доступом. Для вложенных классов действуют те же правила доступа, что и
для обычных классов. Объявление класса Node внутри объявления класса Queue не
дает классу Queue привилегированный доступ к Node, как и классу Node при доступе
к Queue. To есть объект класса Queue может обращаться только к открытым членам
объекта Node. По этой причине в примере с Queue все члены класса Node сделаны
открытыми. Это идет вразрез с обычной практикой, когда члены данных создаются
закрытыми, но класс Node не виден за пределами класса Queue, поскольку объявлен в
его закрытой части. Значит, методы Queue могут непосредственно обращаться к 
членам Node, а клиенты, использующие класс Queue, не могут. Место объявления 
класса определяет область видимости этого класса. Если какой-то класс находится 
в области видимости, доступ программы к членам вложенного класса определяется 
обычными правилами доступа — открытый, закрытый, защищенный, дружественный.
  Вложение в шаблонах. */
// queuetp.h — шаблон очереди с вложенным классом
#ifndef QUEUETP_H_
#define QUEUETP_H_
template <class Item>
class QueueTP
{
private:
    enum {Q_SIZE = 10};
    class Node                              // Node - определение вложенного класса:
    {
    public:
        Item item;
        Node * next;
// занесение значения в часть данных узла; занесение в указатель на следующий узел NULL или nullptr:
        Node(const Item & i) : item(i), next(0) {}
    };
// Закрытые члены класса
    Node * front;                           // указатель на начало QueueTp
    Node * rear;                            // указатель на конец  QueueTp
    int items;                              // текущее количество элементов в QueueTp
    const int qsize;                        // максимальное количество элементов в QueueTp
/* Упреждающие объявления для предотвращения открытого копирования. Этот код переопределяет 
стандартные определения методов, которые в противном случае генерируются автоматически. 
Поскольку это закрытые методы, они не могут вызываться внешним кодом: */
    QueueTP(const QueueTP & q)  : qsize(0)  {}
    QueueTP & operator=(const QueueTP & q)  { return *this; }
public:
    QueueTP(int qs = Q_SIZE);               // создание очереди с предельным размером qs
    ~QueueTP();
    bool isempty() const                    { return items == 0;     } // проверка на пустоту
    bool isfull() const                     { return items == qsize; } // проверка на заполнение
    int queuecount() const                  { return items;          } // определения количества элементов
    bool enqueue(const Item &item);         // добавление item в конец
    bool dequeue(Item &item);               // удаление item из начала
};
// Методы QueueTP:
template <class Item>
QueueTP<Item>::QueueTP(int qs) : qsize(qs)
{
    front = rear = 0;                       // or nullptr
    items = 0;
}
template <class Item>
QueueTP<Item>::~QueueTP()                   // явный деструктор поочередно удаляет все узлы, начиная с начала списка
{
    Node * temp;
    while (front != 0)                      // пока очередь не пуста
    {
        temp = front;                       // сохранение адреса первого элемента
        front = front->next;                // сдвиг указателя на следующий элемент
        delete temp;                        // удаление предыдущего первого
    }
}
// Добавление элемента в очередь
template <class Item>
bool QueueTP<Item>::enqueue(const Item & item)
{
	if (isfull())			                // если очередь уже полна
		return false;                       // завершить программу
	Node * add = new Node(item);	        	// создание узла; при неудачном выполнении операция new
                                            // генерирует исключение std::bad_alloc.
	items++;					            	// увеличить счетчик элементов (items) на единицу
	if (front == NULL)		                // если очередь пуста,
		front = add;		                // элемент помещается в начало
	else						            // иначе он помещается в конец 
		rear->next = add; /* Присоединить узел в конец очереди; этот процесс состоит из двух частей:
1. Созданный узел привязывается к другим узлам в списке. Для этого в указатель next предыдущего 
   конечного узла заносится ссылка на новый конечный узел.
2. В указатель-член rear объекта QueueTp заносится ссылка на новый узел, чтобы иметь доступ 
   непосредственно к последнему узлу. Если очередь пуста, то ссылку на новый узел необходимо 
   поместить и в указатель front. (Если в очереди всего один узел, то он является и начальным, и конечным.) */			
	rear = add;				                // указатель конца указывает на новый узел
    return true;
}
// Помещение первого элемента в переменную item и удаление его из очереди
template <class Item>
bool QueueTP<Item>::dequeue(Item & item)
{
	if (front == NULL)		// если очередь уже пуста, завершить программу
		return false;
	item = front->item;		/* часть данных узла front(первый элемент из очереди) заносится в item —
ссылочную переменную, переданную в метод. */
	items--;					// уменьшить счетчик элементов (items) на единицу
	Node * temp = front;		// сохранение местоположения первого элемента (адреса front) для последующего удаления
	front = front->next;		/* Удалить узел из очереди: сдвиг указателя начала на следующий элемент. В 
указатель-член front объекта QueueTp заносится указатель на следующий узел, адрес которого находится в front->next. */
	delete temp;			// удаление предыдущего первого элемента
	if (items == 0)			// если список теперь пуст, то занести в rear значение NULL. (Начальный 
		rear = NULL;		// указатель уже равен NULL после установки front->next).
    return true; 
}
#endif
// Класс Node определен через общий тип Item. Поэтому при наличии объявления:
QueueTp<double> dq;
// Node будет содержать значения типа double, а объявление:
QueueTp<char> cq;
/* приведет к тому, что Node будет хранить значения типа char. Эти два класса
Node определены в двух раздельных классах QueueTP, поэтому конфликт имен
не возникает, и один узел имеет тип QueueTP<double>::Node, а другой —
тип QueueTP<char>::Node.
	Исключения.
 При выполнении программ иногда встречаются ситуации, препятствующие их нормальному 
продолжению. Например, программа может попытаться открыть недоступный файл, 
запросить памяти больше, чем доступно в данный момент, или столкнуться со 
значением, которое она не может обработать. Исключения в C++ предлагают мощный и 
гибкий механизм обработки таких ситуаций. 
  ВЫЗОВ abort().
 Вызов функции abort() происходит, если один аргумент равен другому с обратным знаком. 
Прототип функции abort() находится в заголовочном файле cstdlib (или stdlib.h).
В типичной реализации при ее вызове в стандартный поток ошибок (тот же самый, который
используется объектом сегг) отправляется сообщение вроде "abnormal program termination" 
("аварийное завершение программы"), и выполнение программы прекращается. Кроме
того, операционной системе или родительскому процессу возвращается значение, 
зависящее от реализации и означающее аварийное завершение. Выводит ли функция
abort () содержимое файловых буферов (области памяти, используемые для хранения 
данных при операциях с файлами) или нет, также зависит от реализации. Можно
использовать функцию exit (), которая точно выводит содержимое буферов —
правда, без вывода сообщения. */
#include <iostream>					// error1.cpp -- использование функции abort()
#include <cstdlib>
double hmean(double a, double b);
int main()
{
    double x, y, z;

    std::cout << "Enter two numbers: ";                        // запрос на ввод двух чисел
    while (std::cin >> x >> y)
    {
        z = hmean(x,y);                                      // среднее гармоническое двух чисел
        std::cout << "Harmonic mean of " << x << " and " << y
            << " is " << z << std::endl;                      // вывод среднего гармонического
        std::cout << "Enter next set of numbers <q to quit>: "; // запрос следующих двух чисел
    }
    std::cout << "Bye!\n";
    return 0;
}
double hmean(double a, double b)
{
    if (a == -b)                                              // если один аргумент равен другому с обратным знаком
    {
        std::cout << "untenable arguments to hmean()\n";        // неверные аргументы для hmean()
        std::abort();                                        // аварийное завершение программы
    }
    return 2.0 * a * b / (a + b); 
}
/* Если у равно х с обратным знаком, вычисление по формуле приведет к делению на ноль —
совершенно неприемлемая операция. Многие новейшие компиляторы выполняют деление на ноль,
получая в результате специальное значение в формате с плавающей точкой, которое обозначает
бесконечность. В cout это значение отображается как Inf, inf, INF или что-то в этом роде.
Ясно, что лучше создать код, который ведет себя одинаково в любой системе.
  Возврат кода ошибки.
 Для определения возникшей проблемы удобнее не просто прекращение выполнения программы,
а использование значения, возвращаемого функцией. Например, член get(void) класса ostream
обычно возвращает ASCII-код очередного введенного символа, однако в случае достижения 
конца файла он возвращает специальное значение EOF. Для hmean() этот подход не годится:
любое числовое значение является допустимым возвращаемым значением, и не существует 
специального значения для индикации проблемы. В этой ситуации можно в качестве аргумента 
функции применять указатель или ссылку — это позволяет вернуть значение в вызывающую 
программу, и на основе этого значения определить успешность выполнения функции. 
Разновидность такого приема используется в семействе istream перегруженных операций >>.
Информируя вызывающую программу об успехе или неудаче, можно предпринять действия, 
отличные от аварийного завершения программы. */
// error2.cpp -- возврат кода ошибки
#include <iostream>
#include <cfloat>  // (или float.h) для DBL_MAX
bool hmean(double a, double b, double * ans);
int main()
{
    double x, y, z;

    std::cout << "Enter two numbers: ";                             // запрос на ввод двух чисел
    while (std::cin >> x >> y)
    {
        if (hmean(x,y,&z))
            std::cout << "Harmonic mean of " << x << " and " << y   // вывод среднего гармонического
                      << " is " << z << std::endl;
        else
            std::cout << "One value should not be the negative "    // одно значение не может быть равно
                      << "of the other - try again.\n"             // другому с обратным знаком
                      << z << std::endl;
        std::cout << "Enter next set of numbers <q to quit>: ";     // запрос следующих двух чисел
    }
    std::cout << "Bye!\n";
    return 0;
}
bool hmean(double a, double b, double * ans)
{
    if (a == -b)                                        // если один аргумент равен другому с обратным знаком
    {
        *ans = DBL_MAX;
        return false;
    }
    else
    {
        *ans = 2.0 * a * b / (a + b);
        return true;
    }
}
/* Еще один вариант сохранения возвращаемых значений — применение глобальных
переменных. Функция, в которой возможны проблемы, в аварийных ситуациях может
заносить в глобальную переменную определенное значение, а вызывающая программа
может проверить эту переменную.
	Механизм исключений.
В языке C++ исключение — это реакция на нештатную ситуацию, возникшую во
время выполнения программы, например, при делении на ноль. Исключения позволяют 
передать управление из одной части программы в другую. Для управления 
исключениями доступны три компонента:
• генерация исключения;
• перехват исключения обработчиком;
• использование блока try.
 Можно изменить функцию hmean(), чтобы она генерировала исключение вместо вызова 
функции abort(). В сущности, оператор throw является оператором перехода, поскольку 
при этом управление передается операторам в другом месте программы. Ключевое слово 
throw является признаком генерации исключения. После него указывается значение —
например, символьная строка или объект, — обозначающее природу исключения.
Программа перехватывает исключение с помощью обработчика исключений, расположенного
в том месте программы, где исключение необходимо обработать. Ключевое слово catch 
означает перехват исключения. Обработчик исключения начинается с ключевого слова 
catch, за которым следует объявление типа (в круглых скобках), представляющее тип 
исключения, которому оно соответствует. За ними в фигурных скобках располагается 
блок кода, выполняющего необходимые действия. Ключевое слово catch вместе с типом 
исключения играет роль метки, определяющей точку в программе, куда должно быть 
передано управление при возникновении исключения. Обработчик исключения называется 
также блоком catch или блоком перехвата. Блок try представляет собой блок кода, в 
котором активизируются определенные исключения. За ним следуют один или несколько 
блоков catch. Блок try начинается с ключевого слова try, а за ним в фигурных 
скобках находится код, в котором отслеживаются исключения. */
#include <iostream>					// error3.cpp -- using an exception
double hmean(double a, double b);
int main()
{
    double x, y, z;
    std::cout << "Enter two numbers: ";                         // запрос на ввод двух чисел
    while (std::cin >> x >> y)
    { /* Если какой-то оператор в этом блоке приведет к генерации исключения, то обработка исключения 
произойдет в блоках catch, следующих за этим блоком try. Если программа вызовет hmean() где-нибудь вне 
этого (или любого другого) блока try, она не сможет обработать исключение. */
        try
        {                                                     // начало блока try
            z = hmean(x,y);
        }                                                     // конец блока try
        catch (const char * s)                                // начало обработчика исключений
        {
            std::cout << s << std::endl;
            std::cout << "Enter a new pair of numbers: ";       // запрос на ввод новой пары чисел
            continue;
        }                                                    // конец обработчика исключений
        std::cout << "Harmonic mean of " << x << " and " << y  // вывод среднего гармонического
                  << " is " << z << std::endl;
        std::cout << "Enter next set of numbers <q to quit>: "; // запрос следующих двух чисел
    }
    std::cout << "Bye!\n";
    return 0;
}
double hmean(double a, double b)
{
    if (a == -b)
        throw "bad hmean() arguments: a = -b not allowed";      // оператор перехода (генерация исключения)
    return 2.0 * a * b / (a + b); 
}
/* Вместо возврата управления вызывающей программе оператор throw заставляет программу
возвращаться по текущей цепочке вызовов функций до тех пор, пока не будет найден
блок try. В данном случае оператор throw передает управление обратно в main(). Здесь 
программа ищет обработчик исключения (следующий за блоком try), который соответствует 
типу сгенерированного исключения. Блок catch это не функция, а обработчик и выражение 
char * s означает, что обработчик соответствует строковым исключениям. Такое объявление 
s аналогично определению аргумента функции, и если возникшее исключение соответствует этому 
объявлению, оно присваивается s, а затем программа выполняет код внутри фигурных скобок.
Если программа выполнила все операторы внутри блока try без возникновения исключений, 
она пропускает все блоки catch и переходит к выполнению операторов, следующих за 
обработчиками исключений. То, что оператор continue переносит управление в начало цикла, 
говорит о том, что обработчик является частью цикла, и что строка catch ведет себя как 
метка, направляющая поток выполнения программы. Если функция сгенерирует исключение, 
но нет ни одного блока try или соответствующего обработчика, то по умолчанию программа 
вызовет функцию abort(), однако такое поведение можно изменить.
  Использование объектов в качестве исключений.
 Обычно функции, которые генерируют исключения, создают объекты. 
Преимущество такого подхода — возможность применения разных типов исключений для
различения функций и ситуаций, генерирующих исключения. Кроме того, объект 
может содержать произвольную информацию, которая помогает определить причины,
вызвавшие исключение. На основе этой информации блок catch может определить,
какие действия следует предпринять. */
class bad_hmean
{
private:
	double v1;
	double v2;
public:
	bad_hmean(int a = 0, int b = 0) : v1(a), v2(b) {}
	void mesg();
};
inline void bad_hmean::mesg()
{
	std::cout << "hmean(" << v1 << ", " << v2 << "): "
			  << "invalid arguments: a = -b\n"; 		// недопустимые аргументы
}
/* Объект bad_hmean можно инициализировать значениями, переданными в hmean(),
а для сообщения о возникшей проблеме удобен метод mesg(). Здесь вызывается 
конструктор bad_hmean(), который инициализирует объект для
сохранения значений аргументов: */
if (а == -b)
	throw bad_hmean(a, b);
// Если после блока try идут два блока catch подряд:
try { 							// начало блока try
	}							// конец блока try
catch (bad_hmean & bg) {...}		// начало блока catch
catch (bad_gmean & hg) {...}		// конец блока catch
/* Если hmean() сгенерирует исключение bad_hmean, его перехватит первый блок
catch. Если же gmean() сгенерирует исключение bad_gmean, оно пройдет через 
первый блок catch и будет перехвачено вторым. */
#include <iostream>		// exc_mean.h  -- классы исключений для hmean() и gmean()
class bad_hmean	
{
private:
    double v1;
    double v2;
public:					// используются открытые данные и метод:
    bad_hmean(double a = 0, double b = 0) : v1(a), v2(b){}
    void mesg();
};
inline void bad_hmean::mesg()
{   
    std::cout << "hmean(" << v1 << ", " << v2 <<"): "
              << "invalid arguments: a = -b\n";             // неверные аргументы
}
class bad_gmean
{
public:
    double v1;
    double v2;			// возвращает строку в стиле С:
    bad_gmean(double a = 0, double b = 0) : v1(a), v2(b){}  // аргументы gmean() должны быть >= 0
    const char * mesg();
};
inline const char * bad_gmean::mesg()
{  
    return "gmean() arguments should be >= 0\n";
}
// error4.cpp -- использование классов исключений
#include <iostream>
#include <cmath>        // или math.h, пользователям UNIX может потребоваться флаг -lm
#include "exc_mean.h"
// Прототипы функций
double hmean(double a, double b);
double gmean(double a, double b);
int main()
{
    using std::cout;
    using std::cin;
    using std::endl;
    double x, y, z;
    cout << "Enter two numbers: ";                              // запрос на ввод двух чисел
    while (cin >> x >> y)
    {
        try {
            z = hmean(x,y);                                   // начало блока try
            cout << "Harmonic mean of " << x << " and " << y    // вывод среднего гармонического
                << " is " << z << endl;
            cout << "Geometric mean of " << x << " and " << y   // вывод среднего геометрического
                << " is " << gmean(x,y) << endl;
            cout << "Enter next set of numbers <q to quit>: ";  // ввод следующей пары чисел '
        }                                                    // end of try block
        catch (bad_hmean & bg)          // использование объекта bad_hmean // начало блока catch
        {
            bg.mesg();                  // используются открытые данные и метод
            cout << "Try again.\n";                            // необходимо повторить попытку
            continue;                   // пропускает остаток цикла и переходит к его началу
        }
        catch (bad_gmean & hg)          // использование объекта bad_gmean
        {
            cout << hg.mesg();          // возвращает строку в стиле С
            cout << "Values used: " << hg.v1 << ", "            // используемые значения
                 << hg.v2 << endl;
            cout << "Sorry, you don't get to play any more.\n";  // завершение работы
            break;                      // прекращение цикла
        }                                                     // end of catch block
    }
    cout << "Bye!\n";
    return 0;
}
double hmean(double a, double b)
{
    if (a == -b)                    // неверные аргументы
        throw bad_hmean(a,b);       // использование объекта bad_hmean
    return 2.0 * a * b / (a + b);
}
double gmean(double a, double b)
{
    if (a < 0 || b < 0)             // аргументы gmean() должны быть >= 0
        throw bad_gmean(a,b);       // использование объекта bad_gmean
    return std::sqrt(a * b); 
}
/* Обработчик bad_hmean использует оператор continue, a обработчик bad_gmean —
оператор break. Поэтому при обнаружении недопустимых данных в функции hmean() 
программа пропускает остаток цикла и переходит к его началу, а недопустимые 
данные в функции gmean() приводят к прекращению цикла. Подобным образом программа 
определяет, какое исключение возникло (по типу исключения), и выбирает реакцию 
на исключение.
  Спецификации исключений в С++11.
 Спецификациями исключений, которые были добавлены в С++98, но в C++11 объявлены
устаревшими. Это значит, что данное средство включено в стандарт, однако
может быть изъято из него в будущем, поэтому лучше его не использовать. */
double harm(double a) throw(bad_thing);	// может сгенерировать исключение bad_thing
double marm(double)   throw();			// не генерирует исключения
/* Часть throw() — со списком типов или без него — является спецификацией 
исключений, и она должна присутствовать как в прототипе, так и в определении 
функции. Новое ключевое слова noexcept, которое указывает, что функция не 
генерирует исключений: */
double marm() noexcept;	// marm() не генерирует исключений
/* Существует также операция noexcept(), которая сообщает, может ли ее аргумент
генерировать исключения. Она возвращает false, если операнд может сгенерировать 
исключение, и true — в противном случае. Например: */
int hilt(int);
int halt(int) noexcept;
/* Выражение noexcept(hilt) вычисляется как false, поскольку объявление hilt()
не гарантирует, что исключение не будет сгенерировано. Однако noexcept(halt) 
вычисляется как true.
  Раскручивание стека.
 Если блок try не содержит непосредственного вызова функции, генерирующей исключение,
но он вызывает функцию, которая, в свою очередь, обращается к функции, генерирующей 
исключение, то управление передается из функции, в которой возникает исключение, в 
функцию, содержащую блок try и обработчики. Это называется раскручиванием стека.
Обычно при вызове функции информация о ней заносится в стек. В частности, в стеке 
сохраняется адрес инструкции вызывающей функции (адрес возврата). Когда вызываемая 
функция завершает свою работу, программа использует этот адрес для определения точки, 
с которой нужно продолжить выполнение программы. Аргументы функции также сохраняются 
в стеке и трактуются как автоматические переменные. Если вызванная функция создает 
новые автоматические переменные, то они тоже сохраняются в стеке. Если вызванная 
функция вызывает другую функцию, то ее информация также добавляется в стек и т.д. 
Когда выполнение функции завершается, управление передается по адресу, сохраненному 
в момент вызова этой функции, а вершина стека освобождается. То есть обычно функция 
возвращает управление в функцию, которая ее вызвала, при этом каждая функция при 
завершении освобождает свои автоматические переменные. Если автоматической переменной 
является объект класса, то вызывается соответствующий деструктор класса.
 Если функция вместо нормального завершения прерывает свою работу с генерацией 
исключения, при этом программа, как положено, очищает стек, но вместо перехода на 
ближайший адрес возврата в стеке программа продолжает очищать стек, пока не достигнет 
адреса возврата, который находится в блоке try. Затем управление передается в 
обработчики исключений за этим блоком, а не оператору, следующему за вызовом функции.
Это процесс и называется раскручиванием стека. Операция throw, как и при возврате из 
функции, для всех автоматических объектов, которые находятся в стеке, вызываются 
деструкторы. Только при возврате из функции обрабатываются объекты, помещенные в 
стек лишь этой функцией, а оператор throw обрабатывает объекты, помещенные в стек 
целой цепочкой вызовов функций между блоком try и этим throw. Без раскручивания 
стека оператор throw не вызвал бы деструкторы для автоматических объектов, помещенных 
в стек промежуточными вызовами функций. */
#include <iostream>		// error5.cpp -- раскручивание стека
#include <cmath>		// или math.h, пользователям UNIX может потребоваться флаг -lm
#include <string>
#include "exc_mean.h"
class demo
{
private:
    std::string word;
public:
    demo(const std::string & str)
    {
        word = str;
        std::cout << "demo " << word << " created\n";       // строка создана
    }
    ~demo()
    {
        std::cout << "demo " << word << " destroyed\n";     // строка уничтожена
    }
    void show() const
    {
        std::cout << "demo " << word << " lives!\n";        // строка существует
    }
}; 
// Прототипы функций:
double hmean(double a, double b);
double gmean(double a, double b);
double means(double a, double b);
int main()
{
    double x, y, z;
	{
        demo d1("found in block in main()"); /* создаёт объект типа demo ("разговорчивый" класс,
    сообщающий, когда используются его конструктор и деструктор). */
        std::cout << "Enter two numbers: ";
        while (std::cin >> x >> y)								// запрос на ввод двух чисел
        {   // try перехватывает оба исключения bad_hmean и bad_gmean
               try {                                            // начало блока try
                   z = means(x,y);
                   std::cout << "The mean mean of " << x << " and "
                        << y << " is " << z << std::endl;			// вывод среднего из средних
                   std::cout << "Enter next pair: ";				// ввод следующей пары
               }												// конец блока try
               catch (bad_hmean & bg)                           // начало блока catch
               {
                   bg.mesg(); /* Повторно сгенерированное исключение добирается до main(), где захватывается
        и обрабатывается соответствующим блоком catch. */
                   std::cout << "Try again.\n";					// необходимо повторить попытку
                   continue;
               }                  
               catch (bad_gmean & hg)							// перехватывает исключение и завершает цикл
               {
                   std::cout << hg.mesg();
                   std::cout << "Values used: " << hg.v1 << ", " 
                             << hg.v2 << std::endl;
                   std::cout << "Sorry, you don't get to play any more.\n";
                   break;
               }                                                // конец блока catch
        }
        d1.show();
    }
    std::cout << "Bye!\n";
    return 0;
}
double hmean(double a, double b)
{
    if (a == -b)
        throw bad_hmean(a, b);
    return 2.0 * a * b / (a + b);
}
double gmean(double a, double b)
{
    if (a < 0 || b < 0)
        throw bad_gmean(a,b);
    return std::sqrt(a * b); 
}
double means(double a, double b)            // means() в свою очередь, вызывает hmean() и gmean()
{
    double am, hm, gm;
    demo d2("found in means()"); /* создаёт объект типа demo ("разговорчивый" класс, сообщающий, когда
используются его конструктор и деструктор). */
    am = (a + b) / 2.0;                     // среднее арифметическое
    try     // try перехватывает только исключение bad_hmean
    {
        hm = hmean(a, b);                   // вызывает hmean()
        gm = gmean(a, b);                   /* вызывает gmean(). Поскольку means() не перехватывает это
исключение, она передает его дальше в main(), и никакой код из means() больше не выполняется. Но и в 
этом случае при раскручивании стека освобождаются локальные автоматические переменные, в частности,
вызывается деструктор для d2. */
    }
    catch (bad_hmean & bg)                  // начало блока catch
    {
        bg.mesg();
        std::cout << "Caught in means()\n";
        throw;  // завершает выполнение means() и передает исключение в main(). повторная генерация исключения
    }           // вызывается деструктор для d2
    d2.show();
    return (am + hm + gm) / 3.0;
}
/* Если блок catch вызовет, скажем, exit(EXIT_FAILURE), а не break, 
программа завершится немедленно.
  Дополнительные свойства исключений.
 Механизм throw-catch имеет много общего с аргументами и механизмом
возврата функций, но существуют и отличия:
1. Оператор возврата из функции передает управление вызвавшей функции, а 
оператор throw передает управление по цепочке в первую функцию, содержащую
комбинацию try-catch, которая перехватывает данное исключение.
2. Когда компилятор генерирует исключение, он всегда создает временную копию,
даже если спецификатор исключения и блок catch задают ссылку: */
class problem {...};
...
void super() throw (problem)
{
	...
	if (oh_no)
	{
		problem oops;	// создание объекта исключения
		throw oops;		// генерация исключения
		...
	}
...
try
{
	super();
}
catch(problem & p) { /*операторы*/ }
/* Здесь р ссылается на копию oops, а не на сам oops. Это хорошо, потому что
после завершения метода super() исключение oops уже не существует. Удобнее 
объединить создание исключения с оператором throw: */
throw problem();		// создание и генерация стандартного объекта problem
/* Зачем в коде используется ссылка, если throw генерирует копию. Ведь обычно
ссылочные величины возвращаются, чтобы не создавать копию объекта. Однако 
ссылки обладают еще одним важным свойством: ссылка на базовый класс может 
ссылаться на объекты производных классов. Предположим, что существует 
коллекция типов исключений, которые связаны наследованием. В этом случае в
спецификации исключения нужна только ссылка на базовый тип, которая будет 
соответствовать любому исключению, сгенерированному производными объектами.
Если имеется иерархия классов исключений, и разные типы исключений нужно 
обрабатывать по-разному, то ссылка на базовый класс может перехватывать все
объекты семейства, но объект производного класса может перехватить только объект
этого класса и классов, производных от него. Сгенерированный объект будет 
перехвачен первым же соответствующим блоком catch. Значит, блоки catch следует 
располагать в порядке, обратном порождению: */
class bad_1 {...};
class bad_2 : public bad_1 {...};
class bad_3 : public bad_2 {...};
...
void duper() throw(bad_1)
{
	...
	if(oh_no)
		throw bad_1();
	if(rats)
		throw bad_2();
	if(drat)
		throw bad_3();
}
...
try
{
	duper();
}
catch(bad_3 & be) { /*операторы*/ }
catch(bad_2 & be) { /*операторы*/ }
catch(bad_1 & be) { /*операторы*/ }
/* Если обработчик bad_1 & будет первым, он перехватит исключения bad_1, bad_2
и bad_3. При обратном порядке расположения обработчиков исключение bad_3 будет
перехвачено обработчиком bad_3 &. Если имеется иерархия наследования классов 
исключений, необходимо расположить блоки catch в таком порядке, чтобы исключение
самого последнего производного класса перехватывалось первым, а исключение
базового класса — последним.
 Можно перехватить исключение, даже не зная его тип. Хитрость заключается в 
использовании многоточия вместо типа исключения: */
catch(...) { /*операторы*/ }		// перехватывает исключение любого типа
/* Если тип некоторых исключений известен, такую универсальную ловушку можно
расположить в конце блока catch — вроде default в операторе switch: */
try
{
	duper();
}
catch(bad_3 &be)
{ /*операторы*/ }
catch(bad_2 &be)
{ /*операторы*/ }
catch(bad_1 &be)
{ /*операторы*/ }
catch(bad_hmean & h)
{ /*операторы*/ }
catch(...)			// перехват всего, что осталось
{ /*операторы*/ }
/* Вместо ссылок можно перехватывать непосредственно объекты исключений.
Ловушка для базового класса будет перехватывать объекты производного класса, но
свойства, характерные для производного объекта, при этом будут скрыты. Поэтому
будут использоваться виртуальные методы базового класса.
  Класс exception.
 В заголовочном файле exception (ранее exception, h или except, h) определен класс
exception, который служит в C++ базовым классом для других классов исключений.
В коде можно генерировать объект exception или применять класс exception в 
качестве базового класса. Среди виртуальных функций-членов имеется функция what(),
возвращающая строку, природа которой зависит от реализации. Поскольку этот метод
виртуальный, его можно переопределить в производном классе: */
#include <exception>
class bad_hmean : public std::exception
{
public:
	const char * what() { return "bad arguments to hmean()"; }
};
class bad_gmean : public std::exception
{
public:
	const char * what() { return "bad arguments to gmean()"; }
};
/* Если нет необходимости в индивидуальной обработке этих производных 
исключений, их можно перехватить в обработчике базового класса: */
try {...}
catch(std::exception & e)
{
	cout << e.what() << endl;
}
/* Или же можно перехватывать различные типы исключений по отдельности.
В библиотеке C++ определено много типов исключений, основанных на классе
exception.
  Классы исключений stdexcept.
 Классы logic_error и runtime_error, оба общедоступно порожденные от exception: */
class logic_error : public exception
{
public:
	explicit logic_error(const strings what_arg);
	...
};
class domain_error : public logic_error
{
public:
	explicit domain_error(const strings what_arg);
	...
};
/* Конструкторы принимают в качестве аргумента объект string; этот аргумент 
содержит символьные данные в виде строки стиля С, которую возвращает метод what().
Семейство logic_error, описывает типичные логические ошибки. У каждого класса 
имеется конструктор, как у logic_error, который позволяет указать строку, 
возвращаемую методом what():
 -Область определения обратной функции, арксинуса, является отрезком от -1 до +1,
а область возвращаемых значений — от -п до +n. Если написать функцию, которая 
передает аргумент в функцию std::asin(), то эта функция может сгенерировать объект
domain_error, если аргумент окажется вне области определения от -1 до +1.
 -Исключение invalid_argument сообщает, что функции было передано непредвиденное 
значение. Например, если функция ожидает получить строку, состоящую только из 
символов '1' или '0', она может сгенерировать исключение invalid_argument, если 
обнаружит в строке другой символ.
 -Исключение length_error используется, если для какого-то действия недостаточно 
памяти. Например, класс string содержит метод append(), который генерирует
исключение length_error, если результирующая строка получится длиннее максимально
допустимой величины.
 -Исключение out_of_bounds обычно служит для обозначения ошибок индексации.
Например, можно определить класс, подобный массиву, для которого operator()[]
сгенерирует исключение out_of_bounds в том случае, если применяемый индекс 
является недопустимым для этого массива.
  Семейство runtime_error предназначено для ошибок, которые могут возникнуть
во время выполнения программы, но не могут быть предсказаны и выявлены заранее:
 -Ошибка потери значимости (underflow_error) может возникнуть в вычислениях с 
плавающей точкой. Существует наименьшая ненулевая положительная величина,
которая может быть представлена типом с плавающей точкой. Вычисления, при которых 
возникают меньшие значения, приведут к генерации исключения потери значимости.
 -Ошибка переполнения (overflow_error) возникает для целых типов или типов с 
плавающей точкой, если абсолютная величина результата превышает максимально 
возможное значение для этих типов.
-Результат вычисления может лежать вне допустимого диапазона без потери значимости
или переполнения, в этом случае можно использовать исключение range_error.
 Исключение из семейства logicerror отражает проблему, которую предположительно 
можно устранить в коде программы, а исключение из семейства runtime_error — ошибку,
избежать которой нельзя. Отношения наследования позволяют при желании объединить 
эти классы воедино. Например, следующий код перехватывает исключение out_of_bounds
отдельно, обрабатывает остальное семейство исключений logic_error как группу, а 
семейство объектов runtime_error и все оставшиеся объекты, производные от exception, 
обрабатывает коллективно: */
try  {...}
catch(out_of bounds & oe)	// перехват ошибки out_of_bounds отдельно
{...}
catch(logic_error & oe)		// перехват остальных ошибок семейства logic_error
{...}
catch(exception & oe)		// перехват runtime_error и других объектов exception коллективно
{...}
/* Если какой-либо из этих библиотечных классов не соответствует Вашим требованиям,
от logic_error или runtime_error можно породить новый класс исключения, который 
войдет в общую иерархию.
  Исключение bad_alloc и операция new.
 В C++ проблемы, возникающие во время выделения памяти с помощью операции new, 
обрабатываются путем генерации в new исключения bad_alloc. Заголовочный файл new 
включает объявление класса badalloc, открыто унаследованного от класса exception. */
#include <iostream>		// newexcp.cpp — исключение bad_alloc
#include <new>
#include <cstdlib>		// для exit(), EXIT_FAILURE
struct Big
{
    double stuff[20000];
};
int main()
{
    Big * pb;
    try
    {
        std::cout << "Trying to get a big block of memory:\n";	// Попытка выделения крупного блока памяти
        pb = new Big[10000];                               	// 1,600,000,000 bytes
        std::cout << "Got past the new request:\n";           	// вывод результатов запроса new
    }
    catch (std::bad_alloc & ba)                            	// произошло исключение
    {
        std::cout << "Caught the exception!\n";
        std::cout << ba.what() << std::endl;		// метод what() возвращает строку "std::bad_alloc"
        exit(EXIT_FAILURE);
    }
    std::cout << "Memory successfully allocated\n";          	// память успешно выделена
    pb[0].stuff[0] = 4;
    std::cout << pb[0].stuff[0] << std::endl;
    delete [] pb;
    return 0; 
}
/* Если программа выполнилась без ошибок, можно попробовать увеличить объем
запрашиваемой памяти.
  Нулевой указатель и операция new.
 В текущем стандарте языка имеется альтернативный вариант new, который
по-прежнему возвращает нулевой указатель. Он используется примерно так: */
int * pi = new (std::nothrow)  int;
int * pa = new (std::nowthrow) int[500];
// Эта форма позволяет переписать основную часть листинга 15.13 следующим образом:
Big * pb;
pb = new (std::nothrow) Big[10000]; // 1,600,000,000 bytes
if (pb == NULL)
{
	cout << "Could not allocate memory. Bye.\n";
	exit(EXIT_FAILURE);
}
/*  Исключения, классы и наследование.
 Исключения, классы и наследование взаимодействуют несколькими способами.
Во-первых, можно породить один класс исключения от другого класса, как это 
сделано в стандартной библиотеке C++. Во-вторых, можно добавить исключения в классы,
вставив объявление класса исключения в определение класса. В-третьих, такое 
вложенное объявление может быть унаследовано и само служить базовым классом.*/
#ifndef _SALES_H_		// sales.h  -- исключения и наследование
#define _SALES_H_
#include <stdexcept>
#include <string>
class Sales
{
public:
    enum { MONTHS = 12 };                       // может быть статической константой
    class bad_index : public std::logic_error   // может сохранять недопустимые значения индексов и
    {                                           // сообщать о них.
    private:
        int bi;                                 // недопустимое значение индекса
    public:                                     // Ошибка индекса в объекте Sales:
        explicit bad_index(int ix, const std::string & s = "Index error in Sales object\n");
        int bi_val() const { return bi; }
        virtual ~bad_index() throw() {}         // виртуальный деструктор использует спецификацию исключения
    };
    explicit Sales(int yy = 0);
    Sales(int yy, const double * gr, int n);
    virtual ~Sales() {}
    int Year() const { return year; }
    virtual double operator[](int i) const;     // для доступа к хранимым в объекте отдельным элементам массива
    virtual double & operator[](int i); // и для генерации исключения, если индекс массива выходит за допустимые пределы
private:
    double gross[MONTHS];
    int year;
};
class LabeledSales : public Sales
{
  public:
    class nbad_index : public Sales::bad_index  // порожден от bad_index и может дополнительно сохранять и выводить 
    {                                           // метки объектов LabeledSales.
    private:
        std::string lbl;
    public:
        nbad_index(const std::string & lb, int ix, const std::string & s = "Index error in LabeledSales object\n");
        const std::string & label_val() const { return lbl; }
        virtual ~nbad_index() throw() {}        // виртуальный деструктор использует спецификацию исключения
     };
    explicit LabeledSales(const std::string & lb = "none", int yy = 0);
    LabeledSales(const std::string & lb, int yy, const double * gr, int n);
    virtual ~LabeledSales()  {}
    const std::string & Label() const { return label; }
    virtual double operator[](int i) const;
    virtual double & operator[](int i);
private:
    std::string label;
};
#endif
// sales.cpp -- реализация Sales
#include "sales.h"
using std::string;
Sales::bad_index::bad_index(int ix, const string & s ) : std::logic_error(s), bi(ix) {}
Sales::Sales(int yy)
{
    year = yy;
    for (int i = 0; i < MONTHS; ++i)
        gross[i] = 0;
}
Sales::Sales(int yy, const double * gr, int n)
{
    year = yy;
    int lim = (n < MONTHS)? n : MONTHS;
    int i;
    for (i = 0; i < lim; ++i)
        gross[i] = gr[i];
    // for i > n and i < MONTHS
    for ( ; i < MONTHS; ++i)
        gross[i] = 0;
}
double Sales::operator[](int i) const
{
    if(i < 0 || i >= MONTHS)
        throw bad_index(i);     // генерация исключения, если индекс массива выходит за допустимые пределы
    return gross[i];
}
double & Sales::operator[](int i)
{
    if(i < 0 || i >= MONTHS)
        throw bad_index(i);     // генерация исключения, если индекс массива выходит за допустимые пределы
    return gross[i];
}
LabeledSales::nbad_index::nbad_index(const string & lb, int ix, const string & s ) : Sales::bad_index(ix, s)
{
    lbl = lb;
}
LabeledSales::LabeledSales(const string & lb, int yy)                              : Sales(yy)
{
    label = lb;
}
LabeledSales::LabeledSales(const string & lb, int yy, const double * gr, int n)    : Sales(yy, gr, n)
{
    label = lb;
}
double LabeledSales::operator[](int i) const
{    if(i < 0 || i >= MONTHS)
        throw nbad_index(Label(), i); // генерация исключения, если индекс массива выходит за допустимые пределы
    return Sales::operator[](i);
}
double & LabeledSales::operator[](int i)
{
    if(i < 0 || i >= MONTHS)
        throw nbad_index(Label(), i); // генерация исключения, если индекс массива выходит за допустимые пределы
    return Sales::operator[](i);
}
// use_sales.cpp  -- вложенные исключения
#include <iostream>
#include "sales.h"
int main()
{
    double vals1[12] =
    {
        1220, 1100, 1122, 2212, 1232, 2334,
        2884, 2393, 3302, 2922, 3002, 3544
    };
    double vals2[12] =
    {
        12, 11, 22, 21, 32, 34,
        28, 29, 33, 29, 32, 35
    };
    Sales sales1(2011, vals1, 12);
    LabeledSales sales2("Blogstar", 2012, vals2, 12 );
    std::cout << "First try block:\n";
    try                                                           // первый блок try
    {
        int i;
        std::cout << "Year = "  << sales1.Year()  << std::endl;     // год
        for (i = 0; i < 12; ++i)
        {
            std::cout << sales1[i] << ' ';
            if (i % 6 == 5)
                std::cout << std::endl;
        }
        std::cout << "Year = "  << sales2.Year()  << std::endl;     // год
        std::cout << "Label = " << sales2.Label() << std::endl;     // метка
        for (i = 0; i <= 12; ++i)
        {
            std::cout << sales2[i] << ' ';                         // пытается выйти за пределы массива(<=)
            if (i % 6 == 5)
                std::cout << std::endl;
        }
        std::cout << "End of try block 1.\n";                       // конец первого блока try
    }
    catch(LabeledSales::nbad_index & bad)
    {
        std::cout << bad.what();
        std::cout << "Company: "   << bad.label_val() << std::endl; // компания
        std::cout << "bad index: " << bad.bi_val()    << std::endl; // недопустимый индекс
    }
    catch(Sales::bad_index & bad)
    {
        std::cout << bad.what();
        std::cout << "bad index: " << bad.bi_val()    << std::endl; // недопустимый индекс
    }
    std::cout << "\nNext try block:\n";
    try                                                           // второй блок try
    {
        sales2[2] = 37.5;
        sales1[20] = 23345;                                        // пытается выйти за пределы массива([20])
        std::cout << "End of try block 2.\n";                       // конец второго блока try
    }
    catch(LabeledSales::nbad_index & bad)
    {
        std::cout << bad.what();
        std::cout << "Company: "   << bad.label_val() << std::endl; // компания
        std::cout << "bad index: " << bad.bi_val()    << std::endl; // недопустимый индекс
    }
    catch(Sales::bad_index & bad)
    {
        std::cout << bad.what();
        std::cout << "bad index: " << bad.bi_val()    << std::endl; // недопустимый индекс
    }
    std::cout << "done\n";
    return 0;
}
/*  Потеря исключений.
 















