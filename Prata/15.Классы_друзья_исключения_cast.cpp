/* 	Дружественные классы.
 Другом может быть класс. В этом случае все методы дружественного класса имеют 
доступ к закрытым и защищенным методам исходного класса. Но в качестве 
дружественных функций класса можно указать и лишь отдельные функции-члены 
другого класса. Класс сам определяет, какие функции, функции-члены или классы 
являются для него друзьями; дружественные отношения нельзя навязать извне.
  Дружественные функции-члены.
 Можно сделать дружественными лишь отдельные члены класса, а не весь класс 
целиком. Понадобится следить за порядком различных определений и объявлений: */
class Tv
{
	...
	friend void Remote::set_chan(Tv & t, int c);
};
/* Однако для обработки этого оператора компилятор уже должен просмотреть 
определение класса Remote. Иначе он не будет знать, что Remote является классом,
а setchan() — методом этого класса. Это наводит на мысль поместить определение
Remote перед определением Тѵ. Но методы класса Remote ссылаются на объекты Тѵ,
а это значит, что определение Тѵ должно находиться перед определением Remote.
Избежать циклических ссылок позволяет упреждающее (предварительное) объявление.
Для этого перед определением Remote необходимо вставить следующий оператор: */
class Tv; 				// упреждающее объявление
// В результате получится вот что:
class Tv; 				// упреждающее объявление
class Remote { ... };
class Tv { ... };
// А можно ли вместо этого применить такой порядок?
class Remote; 			// упреждающее объявление
class Tv { ... };
class Remote { ... };
/* Оказывается, что нельзя. Причина в том, что, как было сказано, когда компилятор
видит, что метод класса Remote объявлен как дружественный в объявлении класса Тѵ,
он должен уже просмотреть объявление всего класса Remote и, в частности, метода
set_chan(). Есть и другая сложность. В объявлении Remote: */
void onoff (Tv & t) { t.onoff(); }
/* Здесь вызывается метод Тѵ, и поэтому компилятор должен заранее просмотреть
объявление класса Тѵ, чтобы знать, какие методы он содержит. Но, как мы видели,
за этим объявлением должно следовать объявление Remote. Решением в данном случае
может быть объявление методов Remote до определения класса Тѵ и их 
непосредственные определения после класса Тѵ: */
class Тѵ;				// упреждающее объявление
class Remote { ... };	// методы, использующие Тѵ, в виде только прототипов
class Тѵ { ... };
...// Определения методов Remote
// Прототипы Remote выглядят следующим образом:
void onoff (Tv & t);
/* Для обработки этого прототипа компилятору нужно лишь знать, что Тѵ является
классом, и упреждающее объявление предоставляет ему эту информацию. Когда 
компилятор дойдет до непосредственных определений методов, объявление класса Тѵ
им уже прочитано, и он будет располагать информацией, необходимой для компиляции
этих методов. Ключевое слово inline в определениях методов также позволяет 
сделать методы встроенными. */
// tvfm.h -- классы Тѵ и Remote и дружественная функция-член
#ifndef TVFM_H_
#define TVFM_H_
class Tv;                                   // упреждающее объявление
class Remote
{
public:
    enum State { Off, On            };
    enum       { MinVal,MaxVal = 20 };
    enum       { Antenna, Cable     };
    enum       { TV, DVD            };
private:
    int mode;                               // управление TV или DVD
public:
    Remote(int m = TV) : mode(m) {}
    bool volup      (Tv & t);               // только прототип
    bool voldown    (Tv & t);
    void onoff      (Tv & t);
    void chanup     (Tv & t);
    void chandown   (Tv & t);
    void set_mode   (Tv & t);
    void set_input  (Tv & t);
    void set_chan   (Tv & t, int c);
};

class Tv
{
public:
    friend void Remote::set_chan(Tv & t, int c);    // дружественный лишь отдельный член класса Remote
    enum State { Off, On            };
    enum       { MinVal,MaxVal = 20 };
    enum       { Antenna, Cable     };
    enum       { TV, DVD            };
    Tv(int s = Off, int mc = 125) : state(s), volume(5), maxchannel(mc), channel(2), mode(Cable), input(TV) {}
    void onoff()                    { state = (state == On) ? Off : On; } // {state ^= 1;} // XOR
    bool ison() const               { return   state == On; }
    bool volup();                                   // громкость++
    bool voldown();                                 // громкость--
    void chanup();                                  // канал++
    void chandown();                                // канал--
    void set_mode()                 { mode  = (mode  == Antenna) ? Cable : Antenna; }
    void set_input()                { input = (input == TV)      ? DVD   : TV;      }
    void settings() const;                          // отображение всех настроек
private:
    int state;                                      // On или Off
    int volume;                                     // дискретные уровни громкости
    int maxchannel;                                 // максимальное количество каналов
    int channel;                                    // текущий канал
    int mode;                                       // эфирное или кабельное телевидение
    int input;                                      // TV или DVD
};
// Методы Remote как встроенные функции:
inline bool Remote::volup     (Tv & t)        { return t.volup();   } // громкость++
inline bool Remote::voldown   (Tv & t)        { return t.voldown(); } // громкость--
inline void Remote::onoff     (Tv & t)        { t.onoff();          } // вкл/выкл
inline void Remote::chanup    (Tv & t)        { t.chanup();         } // канал++
inline void Remote::chandown  (Tv & t)        { t.chandown();       } // канал--
inline void Remote::set_mode  (Tv & t)        { t.set_mode();       } // настр.источника Antenna/Cable
inline void Remote::set_input (Tv & t)        { t.set_input();      } // настр.входа DVD/TV
inline void Remote::set_chan  (Tv & t, int c) { t.channel = c;      } // настр.текущий канал
#endif
/* Встроенные функции имеют внутреннее связывание, т.е. определения функций 
должны находиться в том же файле, где они используются. Здесь встроенные 
определения находятся в заголовочном файле, поэтому при включении этого файла 
в файл, использующий определения, эти определения попадут в нужное место.
Можно поместить определения и в файл реализации, но тогда нужно удалить 
ключевое слово inline, чтобы выполнялось внешнее связывание функций.
  Дружественные отношения.
 Некоторые методы класса Remote могут, воздействовать на объект Тѵ, а некоторые
методы класса Тѵ могут воздействовать на объект Remote. Этого можно добиться, 
сделав классы дружественными друг другу. То есть Тѵ будет другом для Remote, a 
Remote будет другом для Тѵ. Метод класса Тѵ, использующий объект Remote, 
может быть объявлен до объявления класса Remote, но должен быть определён после 
объявления, чтобы у компилятора была вся информация, необходимая для компиляции
метода. Структура кода будет выглядеть следующим образом: */
class Tv
{
friend class Remote;
public:
	void buzz(Remote & r);
	...
};
class Remote
{
friend class Tv;
public:
	void Bool volup(Tv & t) { t.volup(); }
	...
};
inline void Tv::buzz(Remote & r) { ... }
/* Поскольку объявление Remote расположено после объявления Тѵ, метод
Remote::volup() можно определить в объявлении класса. Однако метод Тѵ::buzz()
должен быть определен вне объявления класса Тѵ, чтобы это определение находилось
после объявления класса Remote. Если нет необходимости вставлять встроенное 
определение buzz(), его нужно определить в отдельном файле с определениями методов.
  Общие друзья.
 Когда функции нужен доступ к приватным данным двух разных классов, по идее такая 
функция должна быть функцией-членом каждого из этих классов, но это невозможно. 
Она может быть членом одного класса и другом другого. Но иногда лучше сделать ее 
дружественной обоим классам. Предположим, что имеется класс Probe, представляющий 
некий программируемый измерительный прибор, и класс Analyzer, представляющий 
программируемый анализатор. У каждого прибора есть внутренние часы, и их нужно 
синхронизировать. */
class Analyzer; // упреждающее объявление
class Probe
{
	friend void sync(Analyzer & a, const Probe & p); // синхронизация а с р
	friend void sync(Probe & p, const Analyzer & a); // синхронизация pea
};
class Analyzer
{
	friend void sync(Analyzer & a, const Probe & p); // синхронизация а с р
	friend void sync(Probe & p, const Analyzer & a); // синхронизация р с а
};
// Определение дружественных функций:
inline void sync(Analyzer & a, const Probe & p) { ... }
inline void sync(Probe & p, const Analyzer & a) { ... }
/* Когда компилятор доходит до объявлений друзей в объявлении класса Probe, он, в
силу наличия упреждающего объявления, уже знает, что Analyzer является классом.
	Вложенные классы.
 C++ позволяет помещать объявление класса внутрь другого класса. Класс, объявленный 
внутри другого класса, называется вложенным классом. Вложенные классы ограничивают 
область видимости имен пределами класса и позволяют избежать конфликта имен. 
Функции-члены класса, содержащего вложенное объявление, могут создавать и 
использовать объекты вложенного класса. Извне взаимодействовать с вложенными 
классами можно, только если они объявлены в открытой части класса и только с 
использованием операции разрешения контекста. Не путайте вложение классов и 
включение. Включение означает наличие объекта класса в качестве члена другого 
класса. Вложение не создает член класса, а определяет тип, который известен 
лишь локально в объемлющем классе. Обычно вложенные классы создаются как 
вспомогательные при реализации другого класса, чтобы избежать конфликта имен: */
class Queue
{
private:
// Определения области действия класса
// Node — это вложенное определение структуры, локальное для данного класса
	struct Node { Item item; struct Node *next; };
	...
};
/* Поскольку структура — это класс, члены которого по умолчанию являются 
общедоступными, Node действительно представляет собой вложенный класс. Однако это
определение не использует возможности вложенных классов. В частности, у него нет
явного конструктора. Давайте восполним этот недостаток. Сначала нужно найти, где 
в примере Queue создается объект Node. Просмотрев объявление класса и определения 
методов, можно увидеть, что единственное место, где создаются объекты Node —
это метод enqueue(): */
bool Queue: :enqueue (const Item & item)
{
	if (isfull())
		return false;
	Node * add = new Node;	// создание узла
// В случае сбоя операция new генерирует исключение std::bad_alloc
	add->item = item;		// установка указателей на узлы
	add->next = NULL;
}
/* В этом коде после создания объекта Node его членам явно присваиваются 
значения. Такие действия уместнее выполнять в конструкторе. Зная, где и как 
понадобится конструктор, можно написать соответствующее определение: */
class Queue
{ // Объявления с областью видимости класса
// Node — вложенный класс, локальный по отношению к данному
	class Node
	{
	public:
		Item item;
		Node * next;
		Node (const Item & i) : item(i), next(0) {}
	};
	...
}; // Теперь перепишем метод enqueue() с применением конструктора:
bool Queue::enqueue (const Item & item)
{
	if (isfull())
	return false;
	Node * add = new Node(item); // создание и инициализация узла
// В случае сбоя операция new генерирует исключение std::bad_alloc
}
/* Это сделает код enqueue() немного короче и надежнее, поскольку инициализация
проводится автоматически, и программисту не нужно запоминать все необходимые
действия. В данном примере конструктор определен в объявлении класса. Если потребуется
определить его в файле методов, то тогда определение должно учитывать, что класс
Node определен внутри класса Queue. Это делается с помощью двух операций 
разрешения контекста: */
Queue::Node::Node(const Item & i) : item(i), next(0) {}
/*  Вложенные классы и доступ.
 С вложенными классами связаны два вида доступа. Во-первых, место объявления
вложенного класса определяет его область видимости — т.е. указывает, какие части
программы могут создавать объекты этого класса. Во-вторых, как и для любого другого
класса, доступ к членам класса определяют открытый, закрытый и защищенный 
разделы класса. Место и способ использования вложенного класса зависят как от области
видимости класса, так и от управления доступом.
  Область видимости.
 Если вложенный класс определен в закрытом разделе другого класса, он известен
только объемлющему классу. В последнем примере это относится к классу Node, 
вложенному в объявление класса Queue. Члены класса Queue могут использовать объекты
Node и указатели на объекты Node, а другие части программы даже не подозревают о
существовании класса Node. Если от Queue будет порожден другой класс, то Node для
этого класса будет также невидим, поскольку производный класс не имеет прямого
доступа к закрытой части базового класса.
 Если вложенный класс объявлен в защищенном разделе другого класса, он будет видимым 
для этого класса, но не видимым извне. Поскольку вложенный класс известен во всем 
базовом классе, вовне его нужно использовать с квалификатором класса. */
class Team					// Команда
{
public:
	class Coach { ... };		// Тренер
...
}
// Для создания объекта Coach вне класса Team можно поступить следующим образом:
Team::Coach forhire;			// создание объекта Coach за пределами класса Team
/* Подобные рассуждения об области видимости применимы и к вложенным 
структурам и перечислимым типам. Многие программисты используют открытые 
перечислимые типы для задания констант класса, которые могут применяться в клиентских
классах. Например, как уже было показано, многие реализации классов, созданные
для поддержки средства iostream, используют эту технику для создания различных
вариантов форматирования.
 Свойства области видимости для вложенных классов, структур и перечислений: */
----------------------------------------------------------------------------------------------------
					|Доступен для		|Доступен для класса,	|							|
Где определен:		|вложенного класса:	|порожденного от		|Доступен извне:			|
____________________|___________________|вложенного класса:		|___________________________|
Закрытый раздел		|		Да			|		Нет				|	Нет						|
Защищенный раздел	|		Да			|		Да				|	Нет						|
Открытый раздел		|		Да 			|		Да				|Да,с квалификатором класса	|
----------------------------------------------------------------------------------------------------
/* Управление доступом.
 Если класс оказывается в области видимости, вступают в действие правила 
управления доступом. Для вложенных классов действуют те же правила доступа, что и
для обычных классов. Объявление класса Node внутри объявления класса Queue не
дает классу Queue привилегированный доступ к Node, как и классу Node при доступе
к Queue. To есть объект класса Queue может обращаться только к открытым членам
объекта Node. По этой причине в примере с Queue все члены класса Node сделаны
открытыми. Это идет вразрез с обычной практикой, когда члены данных создаются
закрытыми, но класс Node не виден за пределами класса Queue, поскольку объявлен в
его закрытой части. Значит, методы Queue могут непосредственно обращаться к 
членам Node, а клиенты, использующие класс Queue, не могут. Место объявления 
класса определяет область видимости этого класса. Если какой-то класс находится 
в области видимости, доступ программы к членам вложенного класса определяется 
обычными правилами доступа — открытый, закрытый, защищенный, дружественный.
  Вложение в шаблонах. */
// queuetp.h — шаблон очереди с вложенным классом
#ifndef QUEUETP_H_
#define QUEUETP_H_
template <class Item>
class QueueTP
{
private:
    enum {Q_SIZE = 10};
    class Node                              // Node - определение вложенного класса:
    {
    public:
        Item item;
        Node * next;
// занесение значения в часть данных узла; занесение в указатель на следующий узел NULL или nullptr:
        Node(const Item & i) : item(i), next(0) {}
    };
// Закрытые члены класса
    Node * front;                           // указатель на начало QueueTp
    Node * rear;                            // указатель на конец  QueueTp
    int items;                              // текущее количество элементов в QueueTp
    const int qsize;                        // максимальное количество элементов в QueueTp
/* Упреждающие объявления для предотвращения открытого копирования. Этот код переопределяет 
стандартные определения методов, которые в противном случае генерируются автоматически. 
Поскольку это закрытые методы, они не могут вызываться внешним кодом: */
    QueueTP(const QueueTP & q)  : qsize(0)  {}
    QueueTP & operator=(const QueueTP & q)  { return *this; }
public:
    QueueTP(int qs = Q_SIZE);               // создание очереди с предельным размером qs
    ~QueueTP();
    bool isempty() const                    { return items == 0;     } // проверка на пустоту
    bool isfull() const                     { return items == qsize; } // проверка на заполнение
    int queuecount() const                  { return items;          } // определения количества элементов
    bool enqueue(const Item &item);         // добавление item в конец
    bool dequeue(Item &item);               // удаление item из начала
};
// Методы QueueTP:
template <class Item>
QueueTP<Item>::QueueTP(int qs) : qsize(qs)
{
    front = rear = 0;                       // or nullptr
    items = 0;
}
template <class Item>
QueueTP<Item>::~QueueTP()                   // явный деструктор поочередно удаляет все узлы, начиная с начала списка
{
    Node * temp;
    while (front != 0)                      // пока очередь не пуста
    {
        temp = front;                       // сохранение адреса первого элемента
        front = front->next;                // сдвиг указателя на следующий элемент
        delete temp;                        // удаление предыдущего первого
    }
}
// Добавление элемента в очередь
template <class Item>
bool QueueTP<Item>::enqueue(const Item & item)
{
	if (isfull())			                // если очередь уже полна
		return false;                       // завершить программу
	Node * add = new Node(item);	        	// создание узла; при неудачном выполнении операция new
                                            // генерирует исключение std::bad_alloc.
	items++;					            	// увеличить счетчик элементов (items) на единицу
	if (front == NULL)		                // если очередь пуста,
		front = add;		                // элемент помещается в начало
	else						            // иначе он помещается в конец 
		rear->next = add; /* Присоединить узел в конец очереди; этот процесс состоит из двух частей:
1. Созданный узел привязывается к другим узлам в списке. Для этого в указатель next предыдущего 
   конечного узла заносится ссылка на новый конечный узел.
2. В указатель-член rear объекта QueueTp заносится ссылка на новый узел, чтобы иметь доступ 
   непосредственно к последнему узлу. Если очередь пуста, то ссылку на новый узел необходимо 
   поместить и в указатель front. (Если в очереди всего один узел, то он является и начальным, и конечным.) */			
	rear = add;				                // указатель конца указывает на новый узел
    return true;
}
// Помещение первого элемента в переменную item и удаление его из очереди
template <class Item>
bool QueueTP<Item>::dequeue(Item & item)
{
	if (front == NULL)		// если очередь уже пуста, завершить программу
		return false;
	item = front->item;		/* часть данных узла front(первый элемент из очереди) заносится в item —
ссылочную переменную, переданную в метод. */
	items--;					// уменьшить счетчик элементов (items) на единицу
	Node * temp = front;		// сохранение местоположения первого элемента (адреса front) для последующего удаления
	front = front->next;		/* Удалить узел из очереди: сдвиг указателя начала на следующий элемент. В 
указатель-член front объекта QueueTp заносится указатель на следующий узел, адрес которого находится в front->next. */
	delete temp;			// удаление предыдущего первого элемента
	if (items == 0)			// если список теперь пуст, то занести в rear значение NULL. (Начальный 
		rear = NULL;		// указатель уже равен NULL после установки front->next).
    return true; 
}
#endif
// Класс Node определен через общий тип Item. Поэтому при наличии объявления:
QueueTp<double> dq;
// Node будет содержать значения типа double, а объявление:
QueueTp<char> cq;
/* приведет к тому, что Node будет хранить значения типа char. Эти два класса
Node определены в двух раздельных классах QueueTP, поэтому конфликт имен
не возникает, и один узел имеет тип QueueTP<double>::Node, а другой —
тип QueueTP<char>::Node.
	Исключения.
 При выполнении программ иногда встречаются ситуации, препятствующие их нормальному 
продолжению. Например, программа может попытаться открыть недоступный файл, 
запросить памяти больше, чем доступно в данный момент, или столкнуться со 
значением, которое она не может обработать. Исключения в C++ предлагают мощный и 
гибкий механизм обработки таких ситуаций. 
  ВЫЗОВ abort().
 Вызов функции abort() происходит, если один аргумент равен другому с обратным знаком. 
Прототип функции abort() находится в заголовочном файле cstdlib (или stdlib.h).
В типичной реализации при ее вызове в стандартный поток ошибок (тот же самый, который
используется объектом сегг) отправляется сообщение вроде "abnormal program termination" 
("аварийное завершение программы"), и выполнение программы прекращается. Кроме
того, операционной системе или родительскому процессу возвращается значение, 
зависящее от реализации и означающее аварийное завершение. Выводит ли функция
abort() содержимое файловых буферов (области памяти, используемые для хранения 
данных при операциях с файлами) или нет, также зависит от реализации. Можно
использовать функцию exit(), которая точно выводит содержимое буферов —
правда, без вывода сообщения. */
#include <iostream>					// error1.cpp -- использование функции abort()
#include <cstdlib>
double hmean(double a, double b);
int main()
{
    double x, y, z;

    std::cout << "Enter two numbers: ";                        // запрос на ввод двух чисел
    while (std::cin >> x >> y)
    {
        z = hmean(x,y);                                      // среднее гармоническое двух чисел
        std::cout << "Harmonic mean of " << x << " and " << y
            << " is " << z << std::endl;                      // вывод среднего гармонического
        std::cout << "Enter next set of numbers <q to quit>: "; // запрос следующих двух чисел
    }
    std::cout << "Bye!\n";
    return 0;
}
double hmean(double a, double b)
{
    if (a == -b)                                              // если один аргумент равен другому с обратным знаком
    {
        std::cout << "untenable arguments to hmean()\n";        // неверные аргументы для hmean()
        std::abort();                                        // аварийное завершение программы
    }
    return 2.0 * a * b / (a + b); 
}
/* Если у равно х с обратным знаком, вычисление по формуле приведет к делению на ноль —
совершенно неприемлемая операция. Многие новейшие компиляторы выполняют деление на ноль,
получая в результате специальное значение в формате с плавающей точкой, которое обозначает
бесконечность. В cout это значение отображается как Inf, inf, INF или что-то в этом роде.
Ясно, что лучше создать код, который ведет себя одинаково в любой системе.
  Возврат кода ошибки.
 Для определения возникшей проблемы удобнее не просто прекращение выполнения программы,
а использование значения, возвращаемого функцией. Например, член get(void) класса ostream
обычно возвращает ASCII-код очередного введенного символа, однако в случае достижения 
конца файла он возвращает специальное значение EOF. Для hmean() этот подход не годится:
любое числовое значение является допустимым возвращаемым значением, и не существует 
специального значения для индикации проблемы. В этой ситуации можно в качестве аргумента 
функции применять указатель или ссылку — это позволяет вернуть значение в вызывающую 
программу, и на основе этого значения определить успешность выполнения функции. 
Разновидность такого приема используется в семействе istream перегруженных операций >>.
Информируя вызывающую программу об успехе или неудаче, можно предпринять действия, 
отличные от аварийного завершения программы. */
// error2.cpp -- возврат кода ошибки
#include <iostream>
#include <cfloat>  // (или float.h) для DBL_MAX
bool hmean(double a, double b, double * ans);
int main()
{
    double x, y, z;

    std::cout << "Enter two numbers: ";                             // запрос на ввод двух чисел
    while (std::cin >> x >> y)
    {
        if (hmean(x,y,&z))
            std::cout << "Harmonic mean of " << x << " and " << y   // вывод среднего гармонического
                      << " is " << z << std::endl;
        else
            std::cout << "One value should not be the negative "    // одно значение не может быть равно
                      << "of the other - try again.\n"             // другому с обратным знаком
                      << z << std::endl;
        std::cout << "Enter next set of numbers <q to quit>: ";     // запрос следующих двух чисел
    }
    std::cout << "Bye!\n";
    return 0;
}
bool hmean(double a, double b, double * ans)
{
    if (a == -b)                                        // если один аргумент равен другому с обратным знаком
    {
        *ans = DBL_MAX;
        return false;
    }
    else
    {
        *ans = 2.0 * a * b / (a + b);
        return true;
    }
}
/* Еще один вариант сохранения возвращаемых значений — применение глобальных
переменных. Функция, в которой возможны проблемы, в аварийных ситуациях может
заносить в глобальную переменную определенное значение, а вызывающая программа
может проверить эту переменную.
	Механизм исключений.
В языке C++ исключение — это реакция на нештатную ситуацию, возникшую во
время выполнения программы, например, при делении на ноль. Исключения позволяют 
передать управление из одной части программы в другую. Для управления 
исключениями доступны три компонента:
• генерация исключения;
• перехват исключения обработчиком;
• использование блока try.
 Можно изменить функцию hmean(), чтобы она генерировала исключение вместо вызова 
функции abort(). В сущности, оператор throw является оператором перехода, поскольку 
при этом управление передается операторам в другом месте программы. Ключевое слово 
throw является признаком генерации исключения. После него указывается значение —
например, символьная строка или объект, — обозначающее природу исключения.
Программа перехватывает исключение с помощью обработчика исключений, расположенного
в том месте программы, где исключение необходимо обработать. Ключевое слово catch 
означает перехват исключения. Обработчик исключения начинается с ключевого слова 
catch, за которым следует объявление типа (в круглых скобках), представляющее тип 
исключения, которому оно соответствует. За ними в фигурных скобках располагается 
блок кода, выполняющего необходимые действия. Ключевое слово catch вместе с типом 
исключения играет роль метки, определяющей точку в программе, куда должно быть 
передано управление при возникновении исключения. Обработчик исключения называется 
также блоком catch или блоком перехвата. Блок try представляет собой блок кода, в 
котором активизируются определенные исключения. За ним следуют один или несколько 
блоков catch. Блок try начинается с ключевого слова try, а за ним в фигурных 
скобках находится код, в котором отслеживаются исключения. */
#include <iostream>					// error3.cpp -- using an exception
double hmean(double a, double b);
int main()
{
    double x, y, z;
    std::cout << "Enter two numbers: ";                         // запрос на ввод двух чисел
    while (std::cin >> x >> y)
    { /* Если какой-то оператор в этом блоке приведет к генерации исключения, то обработка исключения 
произойдет в блоках catch, следующих за этим блоком try. Если программа вызовет hmean() где-нибудь вне 
этого (или любого другого) блока try, она не сможет обработать исключение. */
        try
        {                                                     // начало блока try
            z = hmean(x,y);
        }                                                     // конец блока try
        catch (const char * s)                                // начало обработчика исключений
        {
            std::cout << s << std::endl;
            std::cout << "Enter a new pair of numbers: ";       // запрос на ввод новой пары чисел
            continue;
        }                                                    // конец обработчика исключений
        std::cout << "Harmonic mean of " << x << " and " << y  // вывод среднего гармонического
                  << " is " << z << std::endl;
        std::cout << "Enter next set of numbers <q to quit>: "; // запрос следующих двух чисел
    }
    std::cout << "Bye!\n";
    return 0;
}
double hmean(double a, double b)
{
    if (a == -b)
        throw "bad hmean() arguments: a = -b not allowed";      // оператор перехода (генерация исключения)
    return 2.0 * a * b / (a + b); 
}
/* Вместо возврата управления вызывающей программе оператор throw заставляет программу
возвращаться по текущей цепочке вызовов функций до тех пор, пока не будет найден
блок try. В данном случае оператор throw передает управление обратно в main(). Здесь 
программа ищет обработчик исключения (следующий за блоком try), который соответствует 
типу сгенерированного исключения. Блок catch это не функция, а обработчик и выражение 
char * s означает, что обработчик соответствует строковым исключениям. Такое объявление 
s аналогично определению аргумента функции, и если возникшее исключение соответствует этому 
объявлению, оно присваивается s, а затем программа выполняет код внутри фигурных скобок.
Если программа выполнила все операторы внутри блока try без возникновения исключений, 
она пропускает все блоки catch и переходит к выполнению операторов, следующих за 
обработчиками исключений. То, что оператор continue переносит управление в начало цикла, 
говорит о том, что обработчик является частью цикла, и что строка catch ведет себя как 
метка, направляющая поток выполнения программы. Если функция сгенерирует исключение, 
но нет ни одного блока try или соответствующего обработчика, то по умолчанию программа 
вызовет функцию abort(), однако такое поведение можно изменить.
  Использование объектов в качестве исключений.
 Обычно функции, которые генерируют исключения, создают объекты. 
Преимущество такого подхода — возможность применения разных типов исключений для
различения функций и ситуаций, генерирующих исключения. Кроме того, объект 
может содержать произвольную информацию, которая помогает определить причины,
вызвавшие исключение. На основе этой информации блок catch может определить,
какие действия следует предпринять. */
class bad_hmean
{
private:
	double v1;
	double v2;
public:
	bad_hmean(int a = 0, int b = 0) : v1(a), v2(b) {}
	void mesg();
};
inline void bad_hmean::mesg()
{
	std::cout << "hmean(" << v1 << ", " << v2 << "): "
			  << "invalid arguments: a = -b\n"; 		// недопустимые аргументы
}
/* Объект bad_hmean можно инициализировать значениями, переданными в hmean(),
а для сообщения о возникшей проблеме удобен метод mesg(). Здесь вызывается 
конструктор bad_hmean(), который инициализирует объект для
сохранения значений аргументов: */
if (а == -b)
	throw bad_hmean(a, b);
// Если после блока try идут два блока catch подряд:
try { 							// начало блока try
	}							// конец блока try
catch (bad_hmean & bg) {...}		// начало блока catch
catch (bad_gmean & hg) {...}		// конец блока catch
/* Если hmean() сгенерирует исключение bad_hmean, его перехватит первый блок
catch. Если же gmean() сгенерирует исключение bad_gmean, оно пройдет через 
первый блок catch и будет перехвачено вторым. */
#include <iostream>		// exc_mean.h  -- классы исключений для hmean() и gmean()
class bad_hmean	
{
private:
    double v1;
    double v2;
public:					// используются открытые данные и метод:
    bad_hmean(double a = 0, double b = 0) : v1(a), v2(b){}
    void mesg();
};
inline void bad_hmean::mesg()
{   
    std::cout << "hmean(" << v1 << ", " << v2 <<"): "
              << "invalid arguments: a = -b\n";             // неверные аргументы
}
class bad_gmean
{
public:
    double v1;
    double v2;			// возвращает строку в стиле С:
    bad_gmean(double a = 0, double b = 0) : v1(a), v2(b){}  // аргументы gmean() должны быть >= 0
    const char * mesg();
};
inline const char * bad_gmean::mesg()
{  
    return "gmean() arguments should be >= 0\n";
}
// error4.cpp -- использование классов исключений
#include <iostream>
#include <cmath>        // или math.h, пользователям UNIX может потребоваться флаг -lm
#include "exc_mean.h"
// Прототипы функций
double hmean(double a, double b);
double gmean(double a, double b);
int main()
{
    using std::cout;
    using std::cin;
    using std::endl;
    double x, y, z;
    cout << "Enter two numbers: ";                              // запрос на ввод двух чисел
    while (cin >> x >> y)
    {
        try {
            z = hmean(x,y);                                   // начало блока try
            cout << "Harmonic mean of " << x << " and " << y    // вывод среднего гармонического
                << " is " << z << endl;
            cout << "Geometric mean of " << x << " and " << y   // вывод среднего геометрического
                << " is " << gmean(x,y) << endl;
            cout << "Enter next set of numbers <q to quit>: ";  // ввод следующей пары чисел '
        }                                                    // end of try block
        catch (bad_hmean & bg)          // использование объекта bad_hmean // начало блока catch
        {
            bg.mesg();                  // используются открытые данные и метод
            cout << "Try again.\n";                            // необходимо повторить попытку
            continue;                   // пропускает остаток цикла и переходит к его началу
        }
        catch (bad_gmean & hg)          // использование объекта bad_gmean
        {
            cout << hg.mesg();          // возвращает строку в стиле С
            cout << "Values used: " << hg.v1 << ", "            // используемые значения
                 << hg.v2 << endl;
            cout << "Sorry, you don't get to play any more.\n";  // завершение работы
            break;                      // прекращение цикла
        }                                                     // end of catch block
    }
    cout << "Bye!\n";
    return 0;
}
double hmean(double a, double b)
{
    if (a == -b)                    // неверные аргументы
        throw bad_hmean(a,b);       // использование объекта bad_hmean
    return 2.0 * a * b / (a + b);
}
double gmean(double a, double b)
{
    if (a < 0 || b < 0)             // аргументы gmean() должны быть >= 0
        throw bad_gmean(a,b);       // использование объекта bad_gmean
    return std::sqrt(a * b); 
}
/* Обработчик bad_hmean использует оператор continue, a обработчик bad_gmean —
оператор break. Поэтому при обнаружении недопустимых данных в функции hmean() 
программа пропускает остаток цикла и переходит к его началу, а недопустимые 
данные в функции gmean() приводят к прекращению цикла. Подобным образом программа 
определяет, какое исключение возникло (по типу исключения), и выбирает реакцию 
на исключение.
  Спецификации исключений в С++11.
 Спецификациями исключений, которые были добавлены в С++98, но в C++11 объявлены
устаревшими. Это значит, что данное средство включено в стандарт, однако
может быть изъято из него в будущем, поэтому лучше его не использовать. */
double harm(double a) throw(bad_thing);	// может сгенерировать исключение bad_thing
double marm(double)   throw();			// не генерирует исключения
/* Часть throw() — со списком типов или без него — является спецификацией 
исключений, и она должна присутствовать как в прототипе, так и в определении 
функции. Новое ключевое слова noexcept, которое указывает, что функция не 
генерирует исключений: */
double marm() noexcept;	// marm() не генерирует исключений
/* Существует также операция noexcept(), которая сообщает, может ли ее аргумент
генерировать исключения. Она возвращает false, если операнд может сгенерировать 
исключение, и true — в противном случае. Например: */
int hilt(int);
int halt(int) noexcept;
/* Выражение noexcept(hilt) вычисляется как false, поскольку объявление hilt()
не гарантирует, что исключение не будет сгенерировано. Однако noexcept(halt) 
вычисляется как true.
  Раскручивание стека.
 Если блок try не содержит непосредственного вызова функции, генерирующей исключение,
но он вызывает функцию, которая, в свою очередь, обращается к функции, генерирующей 
исключение, то управление передается из функции, в которой возникает исключение, в 
функцию, содержащую блок try и обработчики. Это называется раскручиванием стека.
Обычно при вызове функции информация о ней заносится в стек. В частности, в стеке 
сохраняется адрес инструкции вызывающей функции (адрес возврата). Когда вызываемая 
функция завершает свою работу, программа использует этот адрес для определения точки, 
с которой нужно продолжить выполнение программы. Аргументы функции также сохраняются 
в стеке и трактуются как автоматические переменные. Если вызванная функция создает 
новые автоматические переменные, то они тоже сохраняются в стеке. Если вызванная 
функция вызывает другую функцию, то ее информация также добавляется в стек и т.д. 
Когда выполнение функции завершается, управление передается по адресу, сохраненному 
в момент вызова этой функции, а вершина стека освобождается. То есть обычно функция 
возвращает управление в функцию, которая ее вызвала, при этом каждая функция при 
завершении освобождает свои автоматические переменные. Если автоматической переменной 
является объект класса, то вызывается соответствующий деструктор класса.
 Если функция вместо нормального завершения прерывает свою работу с генерацией 
исключения, при этом программа, как положено, очищает стек, но вместо перехода на 
ближайший адрес возврата в стеке программа продолжает очищать стек, пока не достигнет 
адреса возврата, который находится в блоке try. Затем управление передается в 
обработчики исключений за этим блоком, а не оператору, следующему за вызовом функции.
Это процесс и называется раскручиванием стека. Операция throw, как и при возврате из 
функции, для всех автоматических объектов, которые находятся в стеке, вызываются 
деструкторы. Только при возврате из функции обрабатываются объекты, помещенные в 
стек лишь этой функцией, а оператор throw обрабатывает объекты, помещенные в стек 
целой цепочкой вызовов функций между блоком try и этим throw. Без раскручивания 
стека оператор throw не вызвал бы деструкторы для автоматических объектов, помещенных 
в стек промежуточными вызовами функций. */
#include <iostream>		// error5.cpp -- раскручивание стека
#include <cmath>		// или math.h, пользователям UNIX может потребоваться флаг -lm
#include <string>
#include "exc_mean.h"
class demo
{
private:
    std::string word;
public:
    demo(const std::string & str)
    {
        word = str;
        std::cout << "demo " << word << " created\n";       // строка создана
    }
    ~demo()
    {
        std::cout << "demo " << word << " destroyed\n";     // строка уничтожена
    }
    void show() const
    {
        std::cout << "demo " << word << " lives!\n";        // строка существует
    }
}; 
// Прототипы функций:
double hmean(double a, double b);
double gmean(double a, double b);
double means(double a, double b);
int main()
{
    double x, y, z;
	{
        demo d1("found in block in main()"); /* создаёт объект типа demo ("разговорчивый" класс,
    сообщающий, когда используются его конструктор и деструктор). */
        std::cout << "Enter two numbers: ";
        while (std::cin >> x >> y)								// запрос на ввод двух чисел
        {   // try перехватывает оба исключения bad_hmean и bad_gmean
               try {                                            // начало блока try
                   z = means(x,y);
                   std::cout << "The mean mean of " << x << " and "
                        << y << " is " << z << std::endl;			// вывод среднего из средних
                   std::cout << "Enter next pair: ";				// ввод следующей пары
               }												// конец блока try
               catch (bad_hmean & bg)                           // начало блока catch
               {
                   bg.mesg(); /* Повторно сгенерированное исключение добирается до main(), где захватывается
        и обрабатывается соответствующим блоком catch. */
                   std::cout << "Try again.\n";					// необходимо повторить попытку
                   continue;
               }                  
               catch (bad_gmean & hg)							// перехватывает исключение и завершает цикл
               {
                   std::cout << hg.mesg();
                   std::cout << "Values used: " << hg.v1 << ", " 
                             << hg.v2 << std::endl;
                   std::cout << "Sorry, you don't get to play any more.\n";
                   break;
               }                                                // конец блока catch
        }
        d1.show();
    }
    std::cout << "Bye!\n";
    return 0;
}
double hmean(double a, double b)
{
    if (a == -b)
        throw bad_hmean(a, b);
    return 2.0 * a * b / (a + b);
}
double gmean(double a, double b)
{
    if (a < 0 || b < 0)
        throw bad_gmean(a,b);
    return std::sqrt(a * b); 
}
double means(double a, double b)            // means() в свою очередь, вызывает hmean() и gmean()
{
    double am, hm, gm;
    demo d2("found in means()"); /* создаёт объект типа demo ("разговорчивый" класс, сообщающий, когда
используются его конструктор и деструктор). */
    am = (a + b) / 2.0;                     // среднее арифметическое
    try     // try перехватывает только исключение bad_hmean
    {
        hm = hmean(a, b);                   // вызывает hmean()
        gm = gmean(a, b);                   /* вызывает gmean(). Поскольку means() не перехватывает это
исключение, она передает его дальше в main(), и никакой код из means() больше не выполняется. Но и в 
этом случае при раскручивании стека освобождаются локальные автоматические переменные, в частности,
вызывается деструктор для d2. */
    }
    catch (bad_hmean & bg)                  // начало блока catch
    {
        bg.mesg();
        std::cout << "Caught in means()\n";
        throw;  // завершает выполнение means() и передает исключение в main(). повторная генерация исключения
    }           // вызывается деструктор для d2
    d2.show();
    return (am + hm + gm) / 3.0;
}
/* Если блок catch вызовет, скажем, exit(EXIT_FAILURE), а не break, 
программа завершится немедленно.
  Дополнительные свойства исключений.
 Механизм throw-catch имеет много общего с аргументами и механизмом
возврата функций, но существуют и отличия:
1. Оператор возврата из функции передает управление вызвавшей функции, а 
оператор throw передает управление по цепочке в первую функцию, содержащую
комбинацию try-catch, которая перехватывает данное исключение.
2. Когда компилятор генерирует исключение, он всегда создает временную копию,
даже если спецификатор исключения и блок catch задают ссылку: */
class problem {...};
...
void super() throw (problem)
{
	...
	if (oh_no)
	{
		problem oops;	// создание объекта исключения
		throw oops;		// генерация исключения
		...
	}
...
try
{
	super();
}
catch(problem & p) { /*операторы*/ }
/* Здесь р ссылается на копию oops, а не на сам oops. Это хорошо, потому что
после завершения метода super() исключение oops уже не существует. Удобнее 
объединить создание исключения с оператором throw: */
throw problem();		// создание и генерация стандартного объекта problem
/* Зачем в коде используется ссылка, если throw генерирует копию. Ведь обычно
ссылочные величины возвращаются, чтобы не создавать копию объекта. Однако 
ссылки обладают еще одним важным свойством: ссылка на базовый класс может 
ссылаться на объекты производных классов. Предположим, что существует 
коллекция типов исключений, которые связаны наследованием. В этом случае в
спецификации исключения нужна только ссылка на базовый тип, которая будет 
соответствовать любому исключению, сгенерированному производными объектами.
Если имеется иерархия классов исключений, и разные типы исключений нужно 
обрабатывать по-разному, то ссылка на базовый класс может перехватывать все
объекты семейства, но объект производного класса может перехватить только объект
этого класса и классов, производных от него. Сгенерированный объект будет 
перехвачен первым же соответствующим блоком catch. Значит, блоки catch следует 
располагать в порядке, обратном порождению: */
class bad_1 {...};
class bad_2 : public bad_1 {...};
class bad_3 : public bad_2 {...};
...
void duper() throw(bad_1)
{
	...
	if(oh_no)
		throw bad_1();
	if(rats)
		throw bad_2();
	if(drat)
		throw bad_3();
}
...
try
{
	duper();
}
catch(bad_3 & be) { /*операторы*/ }
catch(bad_2 & be) { /*операторы*/ }
catch(bad_1 & be) { /*операторы*/ }
/* Если обработчик bad_1 & будет первым, он перехватит исключения bad_1, bad_2
и bad_3. При обратном порядке расположения обработчиков исключение bad_3 будет
перехвачено обработчиком bad_3 &. Если имеется иерархия наследования классов 
исключений, необходимо расположить блоки catch в таком порядке, чтобы исключение
самого последнего производного класса перехватывалось первым, а исключение
базового класса — последним.
 Можно перехватить исключение, даже не зная его тип. Хитрость заключается в 
использовании многоточия вместо типа исключения: */
catch(...) { /*операторы*/ }		// перехватывает исключение любого типа
/* Если тип некоторых исключений известен, такую универсальную ловушку можно
расположить в конце блока catch — вроде default в операторе switch: */
try
{
	duper();
}
catch(bad_3 &be)
{ /*операторы*/ }
catch(bad_2 &be)
{ /*операторы*/ }
catch(bad_1 &be)
{ /*операторы*/ }
catch(bad_hmean & h)
{ /*операторы*/ }
catch(...)			// перехват всего, что осталось
{ /*операторы*/ }
/* Вместо ссылок можно перехватывать непосредственно объекты исключений.
Ловушка для базового класса будет перехватывать объекты производного класса, но
свойства, характерные для производного объекта, при этом будут скрыты. Поэтому
будут использоваться виртуальные методы базового класса.
  Класс exception.
 В заголовочном файле exception (ранее exception.h или except.h) определен класс
exception, который служит в C++ базовым классом для других классов исключений.
В коде можно генерировать объект exception или применять класс exception в 
качестве базового класса. Среди виртуальных функций-членов имеется функция what(),
возвращающая строку, природа которой зависит от реализации. Поскольку этот метод
виртуальный, его можно переопределить в производном классе: */
#include <exception>
class bad_hmean : public std::exception
{
public:
	const char * what() { return "bad arguments to hmean()"; }
};
class bad_gmean : public std::exception
{
public:
	const char * what() { return "bad arguments to gmean()"; }
};
/* Если нет необходимости в индивидуальной обработке этих производных 
исключений, их можно перехватить в обработчике базового класса: */
try {...}
catch(std::exception & e)
{
	cout << e.what() << endl;
}
/* Или же можно перехватывать различные типы исключений по отдельности.
В библиотеке C++ определено много типов исключений, основанных на классе
exception.
  Классы исключений stdexcept.
 Классы logic_error и runtime_error, оба общедоступно порожденные от exception: */
class logic_error : public exception
{
public:
	explicit logic_error(const strings what_arg);
	...
};
class domain_error : public logic_error
{
public:
	explicit domain_error(const strings what_arg);
	...
};
/* Конструкторы принимают в качестве аргумента объект string; этот аргумент 
содержит символьные данные в виде строки стиля С, которую возвращает метод what().
Семейство logic_error, описывает типичные логические ошибки. У каждого класса 
имеется конструктор, как у logic_error, который позволяет указать строку, 
возвращаемую методом what():
 -Область определения обратной функции, арксинуса, является отрезком от -1 до +1,
а область возвращаемых значений — от -п до +n. Если написать функцию, которая 
передает аргумент в функцию std::asin(), то эта функция может сгенерировать объект
domain_error, если аргумент окажется вне области определения от -1 до +1.
 -Исключение invalid_argument сообщает, что функции было передано непредвиденное 
значение. Например, если функция ожидает получить строку, состоящую только из 
символов '1' или '0', она может сгенерировать исключение invalid_argument, если 
обнаружит в строке другой символ.
 -Исключение length_error используется, если для какого-то действия недостаточно 
памяти. Например, класс string содержит метод append(), который генерирует
исключение length_error, если результирующая строка получится длиннее максимально
допустимой величины.
 -Исключение out_of_bounds обычно служит для обозначения ошибок индексации.
Например, можно определить класс, подобный массиву, для которого operator()[]
сгенерирует исключение out_of_bounds в том случае, если применяемый индекс 
является недопустимым для этого массива.
  Семейство runtime_error предназначено для ошибок, которые могут возникнуть
во время выполнения программы, но не могут быть предсказаны и выявлены заранее:
 -Ошибка потери значимости (underflow_error) может возникнуть в вычислениях с 
плавающей точкой. Существует наименьшая ненулевая положительная величина,
которая может быть представлена типом с плавающей точкой. Вычисления, при которых 
возникают меньшие значения, приведут к генерации исключения потери значимости.
 -Ошибка переполнения (overflow_error) возникает для целых типов или типов с 
плавающей точкой, если абсолютная величина результата превышает максимально 
возможное значение для этих типов.
-Результат вычисления может лежать вне допустимого диапазона без потери значимости
или переполнения, в этом случае можно использовать исключение range_error.
 Исключение из семейства logic_error отражает проблему, которую предположительно 
можно устранить в коде программы, а исключение из семейства runtime_error — ошибку,
избежать которой нельзя. Отношения наследования позволяют при желании объединить 
эти классы воедино. Например, следующий код перехватывает исключение out_of_bounds
отдельно, обрабатывает остальное семейство исключений logic_error как группу, а 
семейство объектов runtime_error и все оставшиеся объекты, производные от exception, 
обрабатывает коллективно: */
try  {...}
catch(out_of bounds & oe)	// перехват ошибки out_of_bounds отдельно
{...}
catch(logic_error & oe)		// перехват остальных ошибок семейства logic_error
{...}
catch(exception & oe)		// перехват runtime_error и других объектов exception коллективно
{...}
/* Если какой-либо из этих библиотечных классов не соответствует Вашим требованиям,
от logic_error или runtime_error можно породить новый класс исключения, который 
войдет в общую иерархию.
  Исключение bad_alloc и операция new.
 В C++ проблемы, возникающие во время выделения памяти с помощью операции new, 
обрабатываются путем генерации в new исключения bad_alloc. Заголовочный файл new 
включает объявление класса badalloc, открыто унаследованного от класса exception. */
#include <iostream>		// newexcp.cpp — исключение bad_alloc
#include <new>
#include <cstdlib>		// для exit(), EXIT_FAILURE
struct Big
{
    double stuff[20000];
};
int main()
{
    Big * pb;
    try
    {
        std::cout << "Trying to get a big block of memory:\n";	// Попытка выделения крупного блока памяти
        pb = new Big[10000];                               	// 1,600,000,000 bytes
        std::cout << "Got past the new request:\n";           	// вывод результатов запроса new
    }
    catch (std::bad_alloc & ba)                            	// произошло исключение
    {
        std::cout << "Caught the exception!\n";
        std::cout << ba.what() << std::endl;		// метод what() возвращает строку "std::bad_alloc"
        exit(EXIT_FAILURE);
    }
    std::cout << "Memory successfully allocated\n";          	// память успешно выделена
    pb[0].stuff[0] = 4;
    std::cout << pb[0].stuff[0] << std::endl;
    delete [] pb;
    return 0; 
}
/* Если программа выполнилась без ошибок, можно попробовать увеличить объем
запрашиваемой памяти.
  Нулевой указатель и операция new.
 В текущем стандарте языка имеется альтернативный вариант new, который
по-прежнему возвращает нулевой указатель. Он используется примерно так: */
int * pi = new (std::nothrow)  int;
int * pa = new (std::nowthrow) int[500];
// Эта форма позволяет переписать основную часть листинга 15.13 следующим образом:
Big * pb;
pb = new (std::nothrow) Big[10000]; // 1,600,000,000 bytes
if (pb == NULL)
{
	cout << "Could not allocate memory. Bye.\n";
	exit(EXIT_FAILURE);
}
/*  Исключения, классы и наследование.
 Исключения, классы и наследование взаимодействуют несколькими способами.
Во-первых, можно породить один класс исключения от другого класса, как это 
сделано в стандартной библиотеке C++. Во-вторых, можно добавить исключения в классы,
вставив объявление класса исключения в определение класса. В-третьих, такое 
вложенное объявление может быть унаследовано и само служить базовым классом.*/
#ifndef _SALES_H_		// sales.h  -- исключения и наследование
#define _SALES_H_
#include <stdexcept>
#include <string>
class Sales
{
public:
    enum { MONTHS = 12 };                       // может быть статической константой
    class bad_index : public std::logic_error   // может сохранять недопустимые значения индексов и
    {                                           // сообщать о них.
    private:
        int bi;                                 // недопустимое значение индекса
    public:                                     // Ошибка индекса в объекте Sales:
        explicit bad_index(int ix, const std::string & s = "Index error in Sales object\n");
        int bi_val() const { return bi; }
        virtual ~bad_index() throw() {}         // виртуальный деструктор использует спецификацию исключения
    }; // причина в том, что эти классы, в конечном счете, унаследованы от базового класса exception
    explicit Sales(int yy = 0);
    Sales(int yy, const double * gr, int n);
    virtual ~Sales() {}
    int Year() const { return year; }
    virtual double operator[](int i) const;     // для доступа к хранимым в объекте отдельным элементам массива
    virtual double & operator[](int i); // и для генерации исключения, если индекс массива выходит за допустимые пределы
private:
    double gross[MONTHS];
    int year;
};
class LabeledSales : public Sales
{
  public:
    class nbad_index : public Sales::bad_index  // порожден от bad_index и может дополнительно сохранять и выводить 
    {                                           // метки объектов LabeledSales.
    private:
        std::string lbl;
    public:
        nbad_index(const std::string & lb, int ix, const std::string & s = "Index error in LabeledSales object\n");
        const std::string & label_val() const { return lbl; }
        virtual ~nbad_index() throw() {}        // виртуальный деструктор использует спецификацию исключения
     }; // причина в том, что эти классы, в конечном счете, унаследованы от базового класса exception
    explicit LabeledSales(const std::string & lb = "none", int yy = 0);
    LabeledSales(const std::string & lb, int yy, const double * gr, int n);
    virtual ~LabeledSales()  {}
    const std::string & Label() const { return label; }
    virtual double operator[](int i) const;
    virtual double & operator[](int i);
private:
    std::string label;
};
#endif
// sales.cpp -- реализация Sales
#include "sales.h"
using std::string;
Sales::bad_index::bad_index(int ix, const string & s ) : std::logic_error(s), bi(ix) {}
Sales::Sales(int yy)
{
    year = yy;
    for (int i = 0; i < MONTHS; ++i)
        gross[i] = 0;
}
Sales::Sales(int yy, const double * gr, int n)
{
    year = yy;
    int lim = (n < MONTHS)? n : MONTHS;
    int i;
    for (i = 0; i < lim; ++i)
        gross[i] = gr[i];
    // for i > n and i < MONTHS
    for ( ; i < MONTHS; ++i)
        gross[i] = 0;
}
double Sales::operator[](int i) const
{
    if(i < 0 || i >= MONTHS)
        throw bad_index(i);     // генерация исключения, если индекс массива выходит за допустимые пределы
    return gross[i];
}
double & Sales::operator[](int i)
{
    if(i < 0 || i >= MONTHS)
        throw bad_index(i);     // генерация исключения, если индекс массива выходит за допустимые пределы
    return gross[i];
}
LabeledSales::nbad_index::nbad_index(const string & lb, int ix, const string & s ) : Sales::bad_index(ix, s)
{
    lbl = lb;
}
LabeledSales::LabeledSales(const string & lb, int yy)                              : Sales(yy)
{
    label = lb;
}
LabeledSales::LabeledSales(const string & lb, int yy, const double * gr, int n)    : Sales(yy, gr, n)
{
    label = lb;
}
double LabeledSales::operator[](int i) const
{    if(i < 0 || i >= MONTHS)
        throw nbad_index(Label(), i); // генерация исключения, если индекс массива выходит за допустимые пределы
    return Sales::operator[](i);
}
double & LabeledSales::operator[](int i)
{
    if(i < 0 || i >= MONTHS)
        throw nbad_index(Label(), i); // генерация исключения, если индекс массива выходит за допустимые пределы
    return Sales::operator[](i);
}
// use_sales.cpp  -- вложенные исключения
#include <iostream>
#include "sales.h"
int main()
{
    double vals1[12] =
    {
        1220, 1100, 1122, 2212, 1232, 2334,
        2884, 2393, 3302, 2922, 3002, 3544
    };
    double vals2[12] =
    {
        12, 11, 22, 21, 32, 34,
        28, 29, 33, 29, 32, 35
    };
    Sales sales1(2011, vals1, 12);
    LabeledSales sales2("Blogstar", 2012, vals2, 12 );
    std::cout << "First try block:\n";
    try                                                           // первый блок try
    {
        int i;
        std::cout << "Year = "  << sales1.Year()  << std::endl;     // год
        for (i = 0; i < 12; ++i)
        {
            std::cout << sales1[i] << ' ';
            if (i % 6 == 5)
                std::cout << std::endl;
        }
        std::cout << "Year = "  << sales2.Year()  << std::endl;     // год
        std::cout << "Label = " << sales2.Label() << std::endl;     // метка
        for (i = 0; i <= 12; ++i)
        {
            std::cout << sales2[i] << ' ';                         // пытается выйти за пределы массива(<=)
            if (i % 6 == 5)
                std::cout << std::endl;
        }
        std::cout << "End of try block 1.\n";                       // конец первого блока try
    }
    catch(LabeledSales::nbad_index & bad)
    {
        std::cout << bad.what();
        std::cout << "Company: "   << bad.label_val() << std::endl; // компания
        std::cout << "bad index: " << bad.bi_val()    << std::endl; // недопустимый индекс
    }
    catch(Sales::bad_index & bad)
    {
        std::cout << bad.what();
        std::cout << "bad index: " << bad.bi_val()    << std::endl; // недопустимый индекс
    }
    std::cout << "\nNext try block:\n";
    try                                                           // второй блок try
    {
        sales2[2] = 37.5;
        sales1[20] = 23345;                                        // пытается выйти за пределы массива([20])
        std::cout << "End of try block 2.\n";                       // конец второго блока try
    }
    catch(LabeledSales::nbad_index & bad)
    {
        std::cout << bad.what();
        std::cout << "Company: "   << bad.label_val() << std::endl; // компания
        std::cout << "bad index: " << bad.bi_val()    << std::endl; // недопустимый индекс
    }
    catch(Sales::bad_index & bad)
    {
        std::cout << bad.what();
        std::cout << "bad index: " << bad.bi_val()    << std::endl; // недопустимый индекс
    }
    std::cout << "done\n";
    return 0;
}
/*  Потеря исключений.
 Если исключение сгенерировано в функции, имеющей спецификацию исключения, оно 
должно соответствовать одному из типов в списке спецификации. (В иерархии 
наследования тип класса соответствует объектам этого класса и производных от 
него классов.) Если исключение не соответствует  спецификации, оно называется 
непредвиденным исключением и по умолчанию приводит к останову программы. Если
исключение не перехвачено, что может произойти при отсутствии блока try или 
соответствующего блока catch, оно называется неперехваченным исключением. По
умолчанию такое исключение приводит к останову программы. Однако можно 
изменить реакцию программы на непредвиденные и неперехваченные исключения.
 Неперехваченное исключение не приводит к немедленному останову программы.
Вместо этого программа сначала обращается к функции по имени terminate(). По
умолчанию функция terminate() вызывает функцию abort(). Но можно изменить
поведение функции terminate(), зарегистрировав функцию, которую terminate()
будет вызывать вместо abort(). Для этого необходимо вызвать функцию
set_terminate(). Обе функции, terminate() и set_terminate(), объявлены в 
заголовочном файле exception: */
typedef void(*terminate_handler)();
terminate_handler set_terminate(terminate_handler f) throw();	// C++98
terminate_handler set_terminate(terminate_handler f) noexcept;	// C++11
void terminate();												// C++98
void terminate() noexcept;										// C++11
/* Здесь оператор typedef объявляет terminate_handler именем типа указателя
на функцию, которая не принимает аргументы и не возвращает значение. Функция
set_terminate() принимает в качестве аргумента имя функции (т.е. ее адрес) без 
аргументов и возвращает тип void. После вызова set_terminate() возвращает адрес
функции, зарегистрированной перед этим. Если вызвать функцию set_terminate()
более одного раза, terminate() вызовет функцию, зарегистрированную самым 
последним вызовом set_terminate(). Например потребовалось неперехватываемое 
исключение, которое выводит сообщение об этом, затем вызывает функцию exit() с
состоянием завершения в 5. Сначала потребуется включить в проект заголовочный
файл exception. Объявления этого файла можно сделать доступными с помощью 
директивы using, подходящих объявлений using или просто квалификатора std:: */
#include <exception>
using namespace std;
/* После этого нужно создать функцию, которая выполняет два требуемых действия
и имеет подходящий прототип: */
void myQuit()
{
	cout << "Terminating due to uncaught exception\n";
	exit(5);
}
/* И, наконец, в начале программы необходимо указать эту функцию как выбранное
действие завершения программы: */
set_terminate(myQuit);
/* В результате, если исключение будет сгенерировано и не перехвачено, программа
вызовет terminate(), a terminate() вызовет MyQuit().
Теперь рассмотрим непредвиденные исключения. Спецификации исключений в функции
дают возможность пользователям функции узнать, какие исключения перехватывать.*/
double Argh(double, double) throw(out_of_bounds);
// Тогда функцию можно использовать следующим образом:
try
{
	х = Argh(а, b);
}
catch(out_of_bounds & ex) {...}
/* Спецификация исключений должна содержать исключения, генерируемые функциями, 
которые вызываются рассматриваемой функцией. Например, если Argh () вызывает 
функцию Dun(), которая генерирует объект исключения retort, то retort должен 
быть указан в спецификации исключений обеих функций Argh() и Dun(). Если Вы не 
сами (или не тщательно) реализуете все функции, то нет гарантии, что все будет 
работать правильно. Механизм спецификаций исключений в целом может оказаться
весьма громоздким, из-за чего он и не рекомендуется к применению в C++11.
При возникновении непредвиденного исключения программа вызывает функцию 
unexpected(). Эта функция обращается к функции terminate(), которая по умолчанию
вызывает abort(). По аналогии с функцией set_terminate(), изменяющей
поведение terminate(), имеется и функция set_unexpected(), которая модифицирует
поведение unexpected(). Эти функции объявлены в заголовочном файле exception: */
typedef void(*unexpected_handler)();
unexpected_handler set_unexpected(unexpected_handler f) throw();		// C++98
unexpected_handler set_unexpected(unexpected handler f) noexcept;	// C++11
void unexpected();													// C++ 98
void unexpected() noexcept;											// C++11
/* Поведение функции, которая указывается в set_unexpected(), более управляемо.
В частности, функция unexpected_handler может:
• завершить программу, вызвав terminate() (по умолчанию), abort() или exit();
• сгенерировать исключение.
Результат генерации исключения (второй вариант) зависит от исключения, 
сгенерированного функцией замены unexpected_handler, и исходной спецификации 
исключений для функции, которая сгенерировала непредвиденный тип исключения.
• Если вновь сгенерированное исключение соответствует исходной спецификации 
исключений, то программа выполняется нормально — ищет блок catch, который 
соответствует возникшему исключению. По сути, при таком подходе непредвиденный 
тип исключения меняется на ожидаемый тип.
• Если вновь сгенерированное исключение не соответствует исходной спецификации
исключений и если спецификация исключений не содержит тип std::bad_exception,
то программа вызывает terminate(). Тип bad_exception порожден от типа exception,
а его объявление содержится в заголовочном файле exception.
• Если вновь сгенерированное исключение не соответствует исходной спецификации
исключений и если спецификация исключений содержит тип std::bad_exception, то
непредвиденное исключение заменяется исключением типа std::bad_exception.
 Если необходимо перехватывать все исключения — ожидаемые и непредвиденные —
первым делом, нужно сделать доступными объявления заголовочного файла исключений: */
#include <exception>
using namespace std;
/* Затем следует создать функцию замены, которая преобразует непредвиденные 
исключения в тип bad_exception с соответствующим прототипом: */
void myUnexpected()
{
	throw std::bad_exception();		// или просто throw;
}
/* Применение throw без указания исключения приведет к повторной генерации
первоначального исключения. Но если спецификация исключений содержит этот тип, 
исключение будет заменено объектом bad_exception. Далее в начале программы нужно
указать функцию в качестве выбранного действия в ответ на непредвиденное исключение:*/
set_unexpected(myUnexpeced);
/* И, наконец, необходимо включить тип bad_exception в спецификацию 
исключений и цепочку блоков catch: */
double Argh(double, double) throw(out_of_bounds, bad_exception);
...
try
{
	x = Argh(a, b);
}
catch(out_of_bounds & ex) {...}
catch(bad_exception & ex) {...}
/*  Предостережения относительно использования исключений.
 Исключения увеличивают размер программы и снижают скорость ее выполнения.
Спецификации исключений плохо сочетаются с шаблонами, т.к. шаблонные функции
могут генерировать различные виды исключений, в зависимости от конкретной
специализации. Динамическое распределение памяти также не всегда гладко
взаимодействует с исключениями. */
void test1(int n)
{
	string mesg("I'm trapped in an endless loop");
	if(oh_no)
		throw exception();
	return;
}
/* Класс string использует динамическое распределение памяти. Обычно 
деструктор string вызывается, когда функция доходит до оператора return
и завершается. Благодаря раскручиванию стека оператор throw позволяет
вызвать деструктор, хотя он и завершает функцию преждевременно. То есть
в этом случае управление памятью выполняется без проблем. Теперь: */
void test2(int n)
{
	double * ar = new double[n];
	...
	if (oh_no)
		throw exception();
	...
	delete [] ar;
	return;
} /* Здесь присутствует проблема. Раскручивание стека удаляет переменную ar
из стека. Однако из-за преждевременного завершения функции оператор delete[]
в конце тела функции будет пропущен. То есть указатель уничтожен, а память, на 
которую он указывал, остается выделенной, хотя обратиться к ней невозможно.
Т.е. имеется утечка памяти. Такую утечку можно устранить: можно перехватить
исключение в той же функции, которая его сгенерировала, добавить в блок catch
код очистки и сгенерировать исключение заново: */
void test3(int n)
{
	double * ar = new double[n];
	try
	{
		if (oh_no)
			throw exception();
	}
	catch(exception & ex)
	{
		delete [] ar;
		throw;
	}
	...
	delete [] ar;
	return;
} /* Однако такой подход при недостаточной внимательности может породить
новые ошибки. Другой способ основан на использовании шаблонов
интеллектуальных указателей.
	Динамическая идентификация типов (Run Time Type Identification — RTTI).
 Главная цель введения RTTI — предоставить программам стандартный механизм для
определения типа объектов во время выполнения. Может оказаться, что производный
объект имеет собственный, а не унаследованный метод. В этом случае его смогут 
использовать только некоторые объекты. Или для целей отладки может понадобиться
узнать тип сгенерированного объекта. Для этих случаев ответ дает механизм RTTI:
• Операция dynamic_cast, когда это возможно, создает указатель на производный
класс из указателя на базовый класс. В случае невозможности операция возвращает 0,
т.е. нулевой указатель.
• Операция typeid возвращает величину, идентифицирующую точный тип объекта.
• Структура type_info содержит информацию о конкретном типе.
 RTTI можно использовать только с иерархией классов, содержащей виртуальные
функции. Причина в том, что это — единственная иерархия классов, для которой 
бывает нужно присваивать адреса производных объектов указателям базового класса.
  Операция dynamic_cast.
 Дает ответ на вопрос, можно ли безопасно присвоить адрес объекта указателю на 
некоторый тип. */
class Grand { /*содержит виртуальные методы*/ };
class Superb 	  : public Grand  { ... };
class Magnificent : public Superb { ... };
// Далее, пусть имеются перечисленные ниже указатели:
Grand * pg = new Grand;
Grand * ps = new Superb;
Grand * pm = new Magnificent;
// И рассмотрим следующие приведения типов:
Magnificent * p1 = (Magnificent *) pm;	// #1 - безопасно
Magnificent * p2 = (Magnificent *) pg;	// #2 - не безопасно
Superb 		* p3 = (Magnificent *) pm;	// #3 - безопасно
/* #1 Безопасно, потому что оно заносит в указатель типа Magnificent адрес
объекта типа Magnificent. 
 #2 Не безопасно: оно присваивает адрес объекта базового класса (Grand)
указателю на производный класс (Magnificent). После этого программа будет
ожидать, что объект базового класса содержит свойства производного класса,
что в общем случае неверно. К примеру, объект Magnificent может содержать
данные-члены, которых нет в классе Grand.
 #3 Безопасно, т.к. в нем указателю на базовый класс присваивается адрес 
производного объекта. То есть открытое наследование обеспечивает, что объект
Magnificent также является объектом Superb (непосредственный базовый класс) и
объектом Grand (дальний предок). Виртуальные функции гарантируют, что 
использование указателей всех трех типов с адресом Magnificent приведет к 
вызову методов Magnificent. */
Superb * pm = dynamic_cast<Superb *>(pg); /* Здесь спрашивается, можно ли
тип указателя pg безопасно привести (как рассматривалось выше) к типу Superb *.
Если да, операция возвращает адрес объекта. Иначе возвращается 0, т.е. нулевой
указатель. Выражение */
dynamic_cast<Type *>(pt) /* преобразует указатель pt в указатель типа Туре *,
если указываемый объект (*pt) имеет тип Туре либо унаследован непосредственно
или опосредованно от типа Туре. В противном случае это выражение вычисляется
как 0, т.е. нулевой указатель. */
// rtti1.cpp -- использование RTTI-onepaunndynamic_cast
#include <iostream>
#include <cstdlib>
#include <ctime>

using std::cout;

class Grand
{
private:
    int hold;
public:
    Grand(int h = 0) : hold(h)   {}
// виртуальная функция-член Speak(), которую все остальные классы переопределяют:
    virtual void Speak() const   { cout << "I am a grand class!\n"; }
    virtual int  Value() const   { return hold; }
};
class Superb : public Grand
{
public:
    Superb(int h = 0) : Grand(h) {}
    void Speak() const           { cout << "I am a superb class!!\n"; }
// виртуальная функция-член Say(), переопределяемая в классе Magnificent:
    virtual void Say() const     { cout << "I hold the superb value of " << Value() << "!\n"; }
};
class Magnificent : public Superb
{
private:
    char ch;
public:
    Magnificent(int h = 0, char c = 'A') : Superb(h), ch(c) {}
    void Speak() const  { cout << "I am a magnificent class!!!\n";}
    void Say() const    { cout << "I hold the character " << ch << " and the integer "  << Value() << "!\n"; }
};

Grand * GetOne();

int main()
{
    std::srand(std::time(0));
    Grand * pg;
    Superb * ps;
    for (int i = 0; i < 5; i++)
    {
        pg = GetOne();                  // Указатель присваивается переменной pg типа Garnd *,
        pg->Speak();                    // используется для вызова функции Speak().
        if( ps = dynamic_cast<Superb *>(pg) ) // Если приведение типа выполнится успешно (если объект
            ps->Say();		// имеет тип Superb или Magnificent.), ps будет ненулевым, т.е. true. Если 
    }						// приведение типа завершится неудачно (если pg указывает на объект Grand),
    return 0;				// то ps будет равно нулю, или false.
}
// Функция GetOne() имитирует интерактивное принятие решения пользователем: 
Grand * GetOne()				// случайным образом генерирует один из трех типов объектов
{							// и возвращает адрес в виде указателя типа Grand *
    Grand * p;
    switch( std::rand() % 3)
    {
        case 0: p = new Grand(std::rand() % 100);
                    break;
        case 1: p = new Superb(std::rand() % 100);
                    break;
        case 2: p = new Magnificent(std::rand() % 100, 'A' + std::rand() % 26);
                    break;
    }
    return p;
}
/* По возможности следует всегда использовать виртуальные функции, a RTTI —
только когда это необходимо. Операция dynamic_cast применима и к ссылкам,
хотя ее использование при этом слегка отличается. Поскольку не существует
такого значения ссылки, которое соответствует типу нулевого указателя, 
невозможно выбрать специальное значение, которое обозначает неудавшееся 
выполнение. Вместо этого операция dynamic_cast генерирует исключение badcast,
производное от класса exception и определенное в заголовочном файле typeinfо.
Поэтому можно применить следующую операцию (rg — ссылка на объект Grand): */
#include <typeinfo>		// для bad_cast
...
try
{
	Superb & rs = dynamic_cast<Superb &>(rg);
	...
}
catch(bad_cast &) { ... };
/*  Операция typeid и класс type_info.
Операция typeid позволяет выяснить, совпадают ли типы объектов. Похожая на
sizeof, она принимает аргументы двух видов:
• имя класса;
• выражение, которое вычисляется как тип объекта.
Операция typeid возвращает ссылку на объект type_infо, определенный в 
заголовочном файле typeinfо. Класс type_info перегружает операции == и !=,
чтобы их можно было использовать для сравнения типов. Например, следующее
выражение возвращает булевское значение true, если pg указывает на объект
Magnificent, и false — в противном случае: */
typeid(Magnificent) == typeid(*pg)
/* Если pg окажется нулевым указателем, программа сгенерирует исключение
bad_typeid. Этот тип исключения порожден от класса exception и определен в 
заголовочном файле typeinfo. Класс type_info содержит член name(), который
возвращает зависящую от реализации строку, обычно (но не обязательно) 
содержащую имя класса. Например, приведенный ниже оператор отображает строку,
определенную для класса объекта, на который указывает указатель pg: */
cout << "Now processing type " << typeid(*pg).name() << ".\n";
/* Проверка typeid используется для выбора действия, которое даже не является
методом класса, поэтому ее нельзя вызвать с помощью указателя на класс.
  Неправильное использование RTTI.
 Используя typeid и игнорируя dynamic_cast и виртуальные функции, код
rtti1.cpp можно переписать так: */
Grand  * pg;
Superb * ps;
Magnificent * pm;
for(int i = 0; i < 5; i++)
{
	pg = GetOne();
	if(typeid(Magnificent) == typeid(*pg))
	{
		pm = (Magnificent *)pg;
		pm->Speak();
		pm->Say();
	}
	else if(typeid(Superb) == typeid(*pg))
	{
		ps = (Superb *)pg;
		ps->Speak();
		ps->Say();
	}
	else
		pg->Speak();
}
/* Полученный код не только корявей и длиннее исходного, но он еще имеет 
серьезный недостаток — явное именование каждого класса. Если от класса
Magnificent требуется породить класс Insufferable, который переопределит 
методы Speak() и Say(). В версии с использованием typeid для явной проверки 
каждого типа придется добавить в цикл for новый раздел else if. А вот исходная 
версия rtti1.cpp не потребует изменений вообще. Следующий оператор работает 
для всех классов, порожденных от Grand: */
pg->Speak();
// А этот оператор работает для всех классов, порожденных от Superb:
if( ps = dynamic_cast<Superb *>(pg) )
	ps->Say();
/* Если Вы используете операцию typeid в длинной последовательности операторов 
if else, возможно, лучше будет задействовать виртуальные функции и операцию 
dynamic_cast.
  Операции приведения типов. */
struct Data
{
	double data[200];
};
struct Junk
{
	int junk[100];
};
Data d = {2.5еЗЗ, 3.5е-19, 20.2e32};
char * pch = (char *)(&d);	// приведение типа #1 — преобразование в строку
char ch = char(&d);			// приведение типа #2 — преобразование в символ
Junk * pj = (Junk *)(&d);	// приведение типа #3 — преобразование в указатель на Junk
/* Какие из этих трех приведений имеют смысл? Ни одно из них, если находиться
в здравом уме. Какие из этих приведений допустимы? В языке С все они 
являются допустимыми. Бьярне Страуструп, на такую вольность четко
определил то, что является допустимым для общих приведений типов: */
dynamic_cast
const_cast
static_cast
reinterpret_cast
/* Пусть High и Low — два класса, переменная ph имеет тип High *, а pl — тип Low *.
Тогда следующий оператор присваивает указатель Low * переменной pl, только если Low
является доступным для High базовым классом (непосредственным или дальним предком): */
pl = dynamic_cast<Low *> ph;
// В противном случае этот оператор присваивает pl нулевой указатель.
dynamic_cast<имя-типа> (выражение)
/* Назначение этой операции — разрешить восходящие приведения типа внутри 
иерархии классов (такие приведения будут безопасными в силу наличия отношения 
является) и запретить другие приведения.
 Операция const_cast позволяет выполнить приведение типа, только если значение
объявлено как const или volatile. Она имеет такой же синтаксис, как и dynamiс_сast: */
const_cast<имя-типа> (выражение)
/* При несовпадении любых других аспектов типов результатом такого приведения
будет ошибка. То есть имя-типа и выражение должны быть одного типа; они могут
отличаться только наличием или отсутствием квалификаторов const или volatile.
Пусть опять High и Low — два класса: */
High bar;
const High * pbar = &bar;
High * pb = const_cast<High *> (pbar);			// верно
const Low * pl = const_cast<const Low *> (pbar);	// неверно
/* Первое приведение типа делает *pb указателем, который можно использовать для
изменения значения объекта bar; оно удаляет метку const. Второе приведение 
неверно, поскольку оно пытается изменить тип с const High * на const Low *.
Эта операция предназначена на тот случай, когда нужно иметь величину, которая
большую часть времени постоянна, но иногда все же может изменяться. В этом случае
ее можно объявить как const и использовать операцию const_cast, если потребуется
изменить ее значение. Это можно сделать с помощью обычного приведения типа,
но тогда изменится и тип: */
High bar;
const High * pbar = &bar;
High * pb = (High *)(pbar); // верно
Low  * pl = (Low *) (pbar); // тоже верно
/* Поскольку одновременное изменение типа и постоянства значения может 
оказаться непреднамеренной программной ошибкой, безопаснее применять операцию
const_cast.
 const_cast может изменить указатель на величину, но эффект попытки
изменения значения, объявленного с квалификатором const, не определен.*/
#include <iostream>				// constcast.cpp -- using const_cast<>
using std::cout;
using std::endl;
void change(const int * pt, int n);
int main()
{
    int pop1 = 38383;
    const int pop2 = 2000; // const - компилятор может защитить ее от изменений
    cout << "pop1, pop2: " << pop1 << ", " << pop2 << endl;
    change(&pop1, -103);
    change(&pop2, -103);
    cout << "pop1, pop2: " << pop1 << ", " << pop2 << endl;
    return 0;
}
void change(const int * pt, int n)  // Указатель в функции change() объявлен как const int *, поэтому
{                               // его нельзя использовать для изменения целого числа, на которое он указывает.
    int * pc;                   // Указатель рс отбрасывает приведение const, и он позволяет изменить значение,
    pc = const_cast<int *>(pt); // на которое указывает, но только если само значение не объявлено как const.
    *pc += n;                   // Поэтому рс можно использовать для изменения pop1, но не рор2.
}
// Операция static_cast имеет такой же синтаксис, как и другие операции:
static_cast <имя-типа> (выражение)
/* Она допустима только в том случае, если имя-типа может быть неявно преобразовано
в тип, который имеет выражение, или наоборот. В любом другом случае такое приведение
считается ошибочным. Пусть High — базовый класс для Low, a Pond — несвязанный класс.
Тогда приведение High к Low и обратно допустимо, а приведение Low к Pond — нет: */
High bar;
Low blow;
High * pb  = static_cast<High *>(&blow);	// допустимое восходящее приведение
Low  * pl  = static_cast<Low  *>(&bar);	// допустимое нисходящее приведение
Pond * pmr = static_cast<Pond *>(&blow);	// не допускается, Pond не входит в иерархию
/* Первое преобразование является допустимым, поскольку восходящее приведение
может быть выполнено явно. Второе преобразование — из указателя на базовый класс
в указатель на производный класс — не может быть выполнено без явного приведения
типа. Но поскольку обратное преобразование возможно без приведения типа, операцию
static_cast можно использовать для нисходящего преобразования. Аналогично, значение
перечисления может быть преобразовано в целый тип без приведения, - и поэтому 
целочисленный тип можно преобразовать в значение перечисления с помощью операции
static_cast.
 Операция reinterpret_cast предназначена для рискованных приведений типов.
Она не позволит отбросить квалификатор const, но может вызвать другие 
неприятные вещи. */
reinterpret_cast <имя-типа> {выражение)
// Ниже показан пример ее использования:
struct dat { short a; short b; };
long value = 0xA224B118;
dat * pd = reinterpret_cast<dat *>(&value);
cout << hex << pd->a;		// вывод первых двух байтов значения
/* операция reinterpret_cast не позволяет делать вообще все что угодно.
Например, можно привести тип указателя к целочисленному типу, который 
достаточно велик, чтобы хранить указатель, но нельзя привести указатель к меньшему целому
типу или к типу с плавающей точкой. Существует еще одно ограничение: нельзя 
привести указатель на функцию к указателю на данные и наоборот.
 Следующее приведение допустимо в С, но обычно запрещено в C++, потому что в
большинстве реализаций C++ тип char слишком мал, чтобы содержать указатель: */
char ch = char(&d);			// приведение типа #2 — преобразование адреса в символ





















