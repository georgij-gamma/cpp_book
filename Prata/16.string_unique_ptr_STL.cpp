/*	Создание объекта string.
 Представления конструкторов упрощены в том смысле, что они скрывают 
тот факт, что на самом деле string — это typedef для специализации 
шаблона basic_string<char>, и в них опущен необязательный параметр, 
относящийся к управлению памятью. sizetype является внутренним,
зависящим от реализации типом, который определен в заголовочном файле 
string. Класс определяет string::npos в качестве максимально возможной 
длины строки. Как правило, его значение будет равно максимальному значению
типа unsigned int. */
// Конструктор							Описание
string (const char * s)				/* Инициализирует объект string строкой, 
									завершающейся нулевым байтом, которая указана в 's'. */
string (size_type n, char c)			/* Создает объект типа string из n элементов, 
									каждый из которых инициализируется символом 'c'. */
string(const string & str)			/* Инициализирует объект string объектом str типа
									string (конструктор копирования). */
string()							/* Создает объект типа string нулевого размера 
									(конструктор по умолчанию). */
string (const char *s, size_type n)	/* Инициализирует объект типа string строкой, завершающейся
									нулевым байтом, которая указана в 's' и содержит n символов,
									даже если n превышает длину 's'. */
template<class lter>				// Инициализирует объект типа string значениями в
string(Iter begin, Iter end)			/* диапазоне [begin, end), причем begin и end служат указателями 
									начала и конца диапазона. Диапазон начинается с позиции begin 
									включительно и заканчивается позицией end, не включая её.*/
string(const string & str, size_type pos, size_type n = npos) /* Инициализирует объект типа string
									объектом str, начиная с позиции pos и оканчивая концом str
									либо ограничиваясь n символами, в зависимости от того, какое
									условие будет удовлетворено раньше. */
string(string && str) noexcept		/* (C++11). Инициализирует объект string объектом str типа
									string. Объект str может быть изменен (конструктор переноса). */
string(initializer_list<char> il)	/* (C++11). Инициализирует объект типа string символами,
									указанными в списке инициализации il. */
#include <iostream>		// str1.cpp -- введение в класс string
#include <string>
// Использование различных конструкторов класса string
int main()
{
    using namespace std;
    string one("Lottery Winner!");				// ctor #1
/* Инициализация объекта string обычной строкой в стиле С и её вывод на экран с помощью 
перегруженной операции<< */
    cout << "one: " << one << endl;				// overloaded <<
    string two(20, '$');							// ctor #2
// Инициализирует объект two типа string строкой, состоящей из 20 символов $
    cout << "two: " << two << endl;
    string three(one);							// ctor #3
// Конструктор копирования инициализирует объект three типа string объектом one этого же типа
    cout << "three: " << three << endl;
// Перегруженная операция += дописывает строку " Oops!" к строке one:
    one += " Oops!";								// overloaded +=
/* Операция += имеет несколько перегрузок и с ее помощью можно добавлять как 
объекты string, так и отдельные символы. */
    cout << "one: " << one << endl;
/* Операция = тоже является перегружаемой, что позволяет присвоить объекту типа string другой
объект этого же типа, строку в стиле С или простое значение типа char. */
    two = "Sorry! That was ";
/* Перегрузка операции [], позволяет обращаться к отдельным символам объекта типа string,
используя нотацию массива: */
    three[0] = 'P';
// Конструктор по умолчанию создает пустую строку, которой впоследствии может быть присвоено значение:
    string four;								// ctor #4
/* Операция + используется для создания временного объекта string, который затем с помощью
перегруженной операции = присваивается объекту four: */ 
    four = two + three;							// overloaded +, =
/* Операция + объединяет два операнда в один объект типа string. Эта операция имеет несколько
перегрузок, поэтому второй операнд может быть объектом типа string, строкой в стиле С или
значением типа char. */
    cout << "four: " << four << endl;
    char alls[] = "All's well that ends well";
/* Конструктор принимает в качестве аргументов строку в стиле С и 
целочисленное значение, которое указывает количество копируемых символов: */
    string five(alls,20);						// ctor #5
/* Если количество символов превышает длину строки в стиле С, запрошенное количество символов
все равно копируется. Поэтому замена значения 20 значением 40 в приведенном примере привела бы
к копированию в конец строки five пятнадцати бессмысленных символов. */
    cout << "five: " << five << "!\n";
// Использует шаблон template<class Iter> string(Iter begin, Iter end); в качестве аргумента:
    string six(alls+6, alls + 10);				// ctor #6
/* begin и end выступают в роли указателей на начало и конец диапазона памяти. Конструктор применяет
значения элементов памяти, хранящиеся между позициями, указанными аргументами begin и end, для 
инициализации создаваемого им объекта типа string. Запись [begin, end), заимствованная из математики,
означает, что диапазон включает в себя begin, но не включает end. end указывает на позицию, следующую
за последним значением, которое должно быть использовано. Поскольку имя массива является указателем,
значения alls + 6 и alls + 10 будут иметь тип char *, и поэтому в шаблоне тип Iter заменяется типом char* .*/
    cout << "six: " << six  << ", ";
/* Следующий код работать не будет: string seven(five + 6, five + 10);
Причина в том, что имя объекта, в отличие от имени массива, не является адресом объекта. Следовательно,
five — не указатель, и выражение fіѵе + б не имеет смысла. Однако five[6] является значением типа char,
поэтому выражение &five [6] — это адрес, который может использоваться в качестве аргумента конструктора: */
    string seven(&five[6], &five[10]);			// ctor #6 again
    cout << "seven: " << seven << "...\n";
/* Копирует 16 символов из объекта four в объект eight, начиная с
седьмой позиции (восьмого символа) объекта four: */
    string eight(four, 7, 16);					// ctor #7
    cout << "eight: " << eight << " in motion!" << endl;
    return 0; 
}
/* ctor — стандартная аббревиатура конструктора в C++).
  Конструкторы C++11.
 








































