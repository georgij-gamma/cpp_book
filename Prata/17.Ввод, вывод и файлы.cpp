/*	Обзор ввода и вывода в C++.
 Ни С, ни C++ не имеют операций ввода и вывода, встроенных в сам язык.
Для организации ввода-вывода C++ полагается на решения C++, которое 
представляет собой набор классов, определенных в заголовочных файлах 
iostream (бывший iostream.h) и fstream (бывший fstream.h). Эта иблиотека 
классов не является частью формального определения языка (сіп и istream —
это не ключевые слова). Язык программирования определяет правила 
выполнения таких задач, как создание классов, но не определяет, что 
именно нужно создавать, следуя этим правилам. Реализации ввода-вывода C++
поставляется со стандартными библиотеками классов.
  Потоки и буферы.
 Программа на C++ воспринимает ввод и вывод как потоки байтов. При вводе 
программа извлекает байты из входного потока, а при выводе помещает байты в 
выходной поток. Для текстовых программ каждый байт может представлять символ. В 
общем случае байты могут образовывать двоичное представление символов и числовых
данных. Байты входного потока могут поступать с клавиатуры, но также из устройств
хранения, вроде жесткого диска, либо из другой программы. Аналогично, байты 
выходного потока могут передаваться на дисплей, на принтер, на устройство хранения
или же отправляться другой программе. Потоки служат посредниками между 
программой и источником или местом назначения потока. Такой подход позволяет 
программам на C++ трактовать ввод с клавиатуры так же, как и ввод из файла; программа
на C++ просто просматривает поток байтов, не нуждаясь в информации о том, откуда
эти байты поступают. Точно так же, используя потоки, программа на C++ может 
обрабатывать вывод независимо от того, куда, собственно, направляются байты. Таким
образом, управление вводом включает две стадии:
• ассоциирование потока с вводом программы;
• подключение потока к файлу.
Входной поток нуждается в двух подключениях — по одному на каждой стороне. 
Подключение со стороны файла представляет собой источник данных для потока, а 
подключение со стороны программы загружает выходные данные потока в программу.
Подключение со стороны файла может быть файлом, но так же оно может быть 
устройством, таким как клавиатура. Аналогично, управление выводом предусматривает
подключение выходного потока к программе и ассоциирование некоторого выходного 
места назначения с этим потоком. Этот процесс можно сравнить с трубопроводом, 
по которому вместо воды передаются байты. Ввод и вывод может более эффективно 
обрабатываться посредством буфера. Буфер — это блок памяти, используемый в 
качестве промежуточного временного хранилища при передаче информации от 
устройства в программу или из программы устройству. Обычно такие устройства, как 
приводы дисков, передают информацию блоками размером по 512 байт или более, в то 
время как программы часто обрабатывают данные по одному байту за раз. Буфер 
облегчает согласование этих двух различных скоростей передачи информации.
Например, предположим, что программа должна подсчитать количество символов
доллара в файле на жестком диске. Программа может прочитать один символ из 
файла, обработать его, прочитать следующий символ из файла и т.д. Чтение из
дискового файла по одному символа требует множество операций обращения к 
оборудованию и выполняется медленно. Буферизованный подход заключается в чтении
большой порции данных с диска, сохранении этой порции в буфере и последующем 
считывании из буфера по одному символу. Конечно, после того, как программа 
достигает конца буфера, ей приходится затем считывать следующую порцию данных 
с диска. Аналогично, при выводе программа может сначала наполнять буфер, а затем
передавать блок данных целиком на жесткий диск, очищая буфер для следующего 
пакета выходных данных. Этот процесс называют очисткой буфера.
 Клавиатурный ввод поставляет символы по одному, поэтому в его случае программа
не нуждается в буфере для согласования разных скоростей передачи данных. Однако
буферизованный клавиатурный ввод обеспечивает пользователю возможность вернуться 
назад и исправить ввод до того, как он будет передан в программу. Обычно программа 
C++ очищает буфер ввода при нажатии клавиши <Enter>. Для вывода на дисплей программа
C++ обычно очищает выходной буфер при передаче символа новой строки. В зависимости 
от реализации, программа может очищать ввод и в других случаях — например, при 
предстоящем вводе. То есть, когда программа достигает оператора ввода, она очищает 
любой вывод, находящийся в выходном буфере. Реализации C++, которые совместимы с 
ANSI С, должны вести себя таким же образом.
  Потоки, буферы и файл iostream.
• Класс streambuf предоставляет память для буфера, а также и методы для его
заполнения, доступа к содержимому, очистки буфера и управления памятью буфера.
• Класс ios_base представляет общие свойства потока, такие как признак того,
открыт ли поток для чтения, и является он бинарным или текстовым.
• Класс ios базируется на iosbase и включает член-указатель на объект класса
streambuf.
• Класс ostream является производным от ios и предоставляет методы вывода.
• Класс istream является производным от ios и предоставляет методы ввода.
• Класс iostream базируется на классах istream и ostream и потому наследует
как методы ввода, так и методы вывода (множественное наследование). 
 Традиционный 8-битный ("узкий") тип char был дополнен символьным типом wchar_t (или
"широким"). Версия С++11 добавляет типы char16_t и char32_t. Каждому типу требуются
собственные средства ввода-вывода. Вместо того чтобы разрабатывать два (а теперь 
четыре) отдельных набора классов, комитет по стандартизации создал набор шаблонов 
классов ввода-вывода, включая basic_istream< charT, traits<charT> > и 
basic_ostream<charT, traits<charT> >. Шаблон traits<charT>, в свою очередь, 
представляет собой шаблонный класс, который определяет конкретные характеристики 
символьного типа, такие как способы сравнения на эквивалентность и значение EOF 
(end of file — конец файла). Стандарт С++11 предоставляет специализации char и 
wchar_t классов ввода-вывода. Например, istream и ostream — это определения 
typedef для специализаций char. Аналогично, wistream и wostream — специализации 
wchar_t. Так, например, существует объект wcout для потокового вывода "широких" 
символов. Заголовочный файл ostream содержит эти определения. Константа ios::fixed 
теперь превратилась в ios_base::fixed.
 Включение в программу файла <iostream> автоматически создает восемь потоковых 
объектов (четыре для потоков "узких" символов и четыре — для "широких").
• Объект сіп соответствует стандартному потоку ввода. По умолчанию этот 
поток ассоциируется со стандартным устройством ввода — обычно клавиатурой.
Объект wcin аналогичен ему, но работает с типом wchar_t.
• Объект cout соответствует стандартному потоку вывода. По умолчанию этот 
поток ассоциируется со стандартным устройством вывода — обычно монитором.
Объект wcout аналогичен ему, но работает с символами типа wchar_t.
• Объект сегг соответствует стандартному потоку ошибок, который можно 
использовать для отображения сообщений об ошибках. По умолчанию этот поток
ассоциируется со стандартным устройством вывода — обычно монитором — и данный 
поток не буферизуется. Это означает, что информация отправляется непосредственно 
на экран без ожидания заполнения буфера или передачи символа перевода строки. 
Объект wcerr аналогичен, но работает с типом wchar_t.
• Объект clog также соответствует стандартному потоку ошибок. По умолчанию этот 
поток ассоциируется со стандартным устройством вывода — обычно монитором — и не 
буферизуется. Объект wclog аналогичен, но работает с символами типа wchar_t.
 Когда в файле iostream объявляется объект cout для программы, этот объект получает 
члены данных, содержащие информацию относительно вывода, такую как ширина поля для 
отображения данных, количество знаков после десятичной точки, основание системы 
счисления для отображения целочисленных данных и адрес объекта streambuf, описывающего 
буфер, который используется выходным потоком. Оператор, подобный показанному ниже, 
помещает символы из строки "Bjarne free" в управляемый объектом cout буфер посредством 
указанного объекта streambuf: */
cout << "Bjarne free";
/* Класс ostream определяет функцию operator<<(), используемую в этом операторе, а 
также поддерживает данные-члены cout с множеством других методов класса. C++ учитывает,
что вывод из буфера направляется в стандартный вывод — обычно монитор — предоставленный 
операционной системой и объект 'cout' с помощью объекта типа 'streambuf' управляет 
движением байтов в потоке. 
  Перенаправление.
 Перенаправление — функциональную возможность, которая позволяет заменять ассоциации 
стандартного ввода и стандартного вывода. 





























