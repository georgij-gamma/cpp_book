/*	Обзор ввода и вывода в C++.
 Ни С, ни C++ не имеют операций ввода и вывода, встроенных в сам язык.
Для организации ввода-вывода C++ полагается на решения C++, которое 
представляет собой набор классов, определенных в заголовочных файлах 
iostream (бывший iostream.h) и fstream (бывший fstream.h). Эта иблиотека 
классов не является частью формального определения языка (сіп и istream —
это не ключевые слова). Язык программирования определяет правила 
выполнения таких задач, как создание классов, но не определяет, что 
именно нужно создавать, следуя этим правилам. Реализации ввода-вывода C++
поставляется со стандартными библиотеками классов.
  Потоки и буферы.
 Программа на C++ воспринимает ввод и вывод как потоки байтов. При вводе 
программа извлекает байты из входного потока, а при выводе помещает байты в 
выходной поток. Для текстовых программ каждый байт может представлять символ. В 
общем случае байты могут образовывать двоичное представление символов и числовых
данных. Байты входного потока могут поступать с клавиатуры, но также из устройств
хранения, вроде жесткого диска, либо из другой программы. Аналогично, байты 
выходного потока могут передаваться на дисплей, на принтер, на устройство хранения
или же отправляться другой программе. Потоки служат посредниками между 
программой и источником или местом назначения потока. Такой подход позволяет 
программам на C++ трактовать ввод с клавиатуры так же, как и ввод из файла; программа
на C++ просто просматривает поток байтов, не нуждаясь в информации о том, откуда
эти байты поступают. Точно так же, используя потоки, программа на C++ может 
обрабатывать вывод независимо от того, куда, собственно, направляются байты. Таким
образом, управление вводом включает две стадии:
• ассоциирование потока с вводом программы;
• подключение потока к файлу.
Входной поток нуждается в двух подключениях — по одному на каждой стороне. 
Подключение со стороны файла представляет собой источник данных для потока, а 
подключение со стороны программы загружает выходные данные потока в программу.
Подключение со стороны файла может быть файлом, но так же оно может быть 
устройством, таким как клавиатура. Аналогично, управление выводом предусматривает
подключение выходного потока к программе и ассоциирование некоторого выходного 
места назначения с этим потоком. Этот процесс можно сравнить с трубопроводом, 
по которому вместо воды передаются байты. Ввод и вывод может более эффективно 
обрабатываться посредством буфера. Буфер — это блок памяти, используемый в 
качестве промежуточного временного хранилища при передаче информации от 
устройства в программу или из программы устройству. Обычно такие устройства, как 
приводы дисков, передают информацию блоками размером по 512 байт или более, в то 
время, как программы часто обрабатывают данные по одному байту за раз. Буфер 
облегчает согласование этих двух различных скоростей передачи информации.
Например, предположим, что программа должна подсчитать количество символов
доллара в файле на жестком диске. Программа может прочитать один символ из 
файла, обработать его, прочитать следующий символ из файла и т.д. Чтение из
дискового файла по одному символу требует множество операций обращения к 
оборудованию и выполняется медленно. Буферизованный подход заключается в чтении
большой порции данных с диска, сохранении этой порции в буфере и последующем 
считывании из буфера по одному символу. Конечно, после того, как программа 
достигает конца буфера, ей приходится затем считывать следующую порцию данных 
с диска. Аналогично, при выводе программа может сначала наполнять буфер, а затем
передавать блок данных целиком на жесткий диск, очищая буфер для следующего 
пакета выходных данных. Этот процесс называют очисткой буфера.
 Клавиатурный ввод поставляет символы по одному, поэтому в его случае программа
не нуждается в буфере для согласования разных скоростей передачи данных. Однако
буферизованный клавиатурный ввод обеспечивает пользователю возможность вернуться 
назад и исправить ввод до того, как он будет передан в программу. Обычно программа 
C++ очищает буфер ввода при нажатии клавиши <Enter>. Для вывода на дисплей программа
C++ обычно очищает выходной буфер при передаче символа новой строки. В зависимости 
от реализации, программа может очищать ввод и в других случаях — например, при 
предстоящем вводе. То есть, когда программа достигает оператора ввода, она очищает 
любой вывод, находящийся в выходном буфере. Реализации C++, которые совместимы с 
ANSI С, должны вести себя таким же образом.
  Потоки, буферы и файл iostream.
• Класс streambuf предоставляет память для буфера, а также и методы для его
заполнения, доступа к содержимому, очистки буфера и управления памятью буфера.
• Класс ios_base представляет общие свойства потока, такие как признак того,
открыт ли поток для чтения, и является он бинарным или текстовым.
• Класс ios базируется на iosbase и включает член-указатель на объект класса
streambuf.
• Класс ostream является производным от ios и предоставляет методы вывода.
• Класс istream является производным от ios и предоставляет методы ввода.
• Класс iostream базируется на классах istream и ostream и потому наследует
как методы ввода, так и методы вывода (множественное наследование). 
 Традиционный 8-битный ("узкий") тип char был дополнен символьным типом wchar_t (или
"широким"). Версия С++11 добавляет типы char16_t и char32_t. Каждому типу требуются
собственные средства ввода-вывода. Вместо того чтобы разрабатывать два (а теперь 
четыре) отдельных набора классов, комитет по стандартизации создал набор шаблонов 
классов ввода-вывода, включая basic_istream< charT, traits<charT> > и 
basic_ostream<charT, traits<charT> >. Шаблон traits<charT>, в свою очередь, 
представляет собой шаблонный класс, который определяет конкретные характеристики 
символьного типа, такие как способы сравнения на эквивалентность и значение EOF 
(end of file — конец файла). Стандарт С++11 предоставляет специализации char и 
wchar_t классов ввода-вывода. Например, istream и ostream — это определения 
typedef для специализаций char. Аналогично, wistream и wostream — специализации 
wchar_t. Так, например, существует объект wcout для потокового вывода "широких" 
символов. Заголовочный файл ostream содержит эти определения. Константа ios::fixed 
теперь превратилась в ios_base::fixed.
 Включение в программу файла <iostream> автоматически создает восемь потоковых 
объектов (четыре для потоков "узких" символов и четыре — для "широких").
• Объект 'сіп' соответствует стандартному потоку ввода. По умолчанию этот 
поток ассоциируется со стандартным устройством ввода — обычно клавиатурой.
Объект 'wcin' аналогичен ему, но работает с типом wchar_t.
• Объект 'cout' соответствует стандартному потоку вывода. По умолчанию этот 
поток ассоциируется со стандартным устройством вывода — обычно монитором.
Объект 'wcout' аналогичен ему, но работает с символами типа wchar_t.
• Объект 'сеrr' соответствует стандартному потоку ошибок, который можно 
использовать для отображения сообщений об ошибках. По умолчанию этот поток
ассоциируется со стандартным устройством вывода — обычно монитором — и данный 
поток не буферизуется. Это означает, что информация отправляется непосредственно 
на экран без ожидания заполнения буфера или передачи символа перевода строки. 
Объект wcerr аналогичен, но работает с типом wchar_t.
• Объект 'clog' также соответствует стандартному потоку ошибок. По умолчанию этот 
поток ассоциируется со стандартным устройством вывода — обычно монитором — и не 
буферизуется. Объект 'wclog' аналогичен, но работает с символами типа wchar_t.
 Когда в файле iostream объявляется объект cout для программы, этот объект получает 
члены данных, содержащие информацию относительно вывода, такую как ширина поля для 
отображения данных, количество знаков после десятичной точки, основание системы 
счисления для отображения целочисленных данных и адрес объекта streambuf, описывающего 
буфер, который используется выходным потоком. Оператор, подобный показанному ниже, 
помещает символы из строки "Bjarne free" в управляемый объектом cout буфер посредством 
указанного объекта streambuf: */
cout << "Bjarne free";
/* Класс ostream определяет функцию operator<<(), используемую в этом операторе, а 
также поддерживает данные-члены 'cout' с множеством других методов класса. C++ учитывает,
что вывод из буфера направляется в стандартный вывод — обычно монитор — предоставленный 
операционной системой и объект 'cout' с помощью объекта типа 'streambuf' управляет 
движением байтов в потоке. 
  Перенаправление.
 Перенаправление — функциональная возможность, которая позволяет заменять ассоциации 
стандартного ввода и стандартного вывода. Например имеется исполняемая программа 
командной строки count.exe, написанная на языке C++, которая подсчитывает количество 
символов ввода и выдает результат. */
.\count.exe file.txt				// введено вручную  в командной строке
Hello
and goodbye!
Control-Z <- 					// эмуляция конца файла
Input contained 19 characters.	// вывод результата в командной строке
/* В данном случае ввод поступает с клавиатуры, а вывод направляется на экран.
Используя перенаправление ввода '<' и перенаправление вывода '>', эту же 
программу можно применить для подсчета количества символов в файле file.txt и 
поместить результат в файл 123.txt: */
.\count.exe <file.txt >123.txt
/* Часть <file.txt командной строки ассоциирует стандартный ввод с файлом
file.txt, что заставляет 'сіп' считывать ввод из этого файла вместо клавиатуры.
Другими словами, операционная система заменяет подключение начальной части
входного потока, в то время как конечная его часть остается подключенной к 
программе. Часть >123.txt командной строки ассоциирует стандартный вывод с 
файлом 123.txt, что заставляет cout направлять свой вывод в этот файл, а не на экран.
То есть операционная система заменяет конечную часть выходного потока, оставляя
его начальную часть подключенной к программе. 
 Стандартный выходной поток, представленный объектом cout —это нормальный
канал вывода программы. Стандартные потоки ошибок (представленные объектами
'сеrr' и 'clog') предназначены для сообщений об ошибках программы. По умолчанию
все эти три объекта отправляют информацию на монитор. Но перенаправление 
стандартного вывода не затрагивает 'сеrr' и 'clog'; таким образом, если один из этих 
объектов используется для печати сообщений об ошибках, программа отобразит их на
экране, даже если обычный вывод cout будет перенаправлен куда-либо в другое место.
Например, рассмотрим следующий фрагмент кода: */
if (success)
	std::cout << "Here come the goodies!\n";
else
{
	std::cerr << "Something horrible has happened.\n";
	exit(1);
}
/* Если перенаправление не используется, все сообщения будут выведены на экран.
Но если вывод программы перенаправлен в файл, то первое сообщение, если оно
будет выбрано, будет направлено в файл, а второе сообщение в случае его выбора 
будет выведено на экран. Некоторые операционные системы допускают также
перенаправление стандартного потока ошибок. Например, в Unix и Linux операция
'2>' перенаправляет стандартный поток ошибок.
	Вывод с помощью cout.
 C++ рассматривает вывод как поток байтов. В зависимости от реализации и платформы 
это могут быть 8-, 16- или 32-битные байты, но все равно они будут байтами. Но многие
виды данных в программе организованы в виде более крупных блоков, нежели отдельный байт. 
Например, тип 'int' может быть представлен 16- или 32-битным двоичным значением, а 
значение типа 'double' — 64-битными двоичными данными. При отправке потока байтов на 
экран желательно, чтобы каждый байт представлял значение символа. То есть для отображения 
на экране числа '2.34' понадобится отправить пять символов: '-', '2', '.', '3' и '4',а не 
внутреннее 64-битное с плавающей точкой представление этого значения. Поэтому одной из
наиболее важных задач, стоящих перед классом о stream, является преобразование числовых 
типов, таких как 'int' или 'float', в поток символов, который представляет значения в 
текстовой форме. ostream транслирует внутреннее представление данных в виде двоичных 
битовых последовательностей в выходной поток символьных байтов. Для выполнения такой 
трансляции в классе ostream предусмотрено несколько методов.
  Перегруженная операция <<.
Чаще всего мы используем 'cout' с операцией '<<', которая также называется операцией вставки: */
int clients = 22;
cout << clients;
/* В языке C++, как и в С, по умолчанию операция '<<' используется в качестве битовой
операции сдвига. Выражение наподобие 'x << 3' означает: загрузить двоичное представление 'x' и 
сдвинуть все его биты на три позиции влево. Очевидно, что это не слишком тесно связано с выводом.
Но класс ostream переопределяет операцию '<<' для вывода. (Операция сдвига влево обретает эту 
новую роль посредством своего визуального аспекта, который предполагает смещение информации 
влево.) Операция вставки перегружена для применения со всеми базовыми типами C++: */
• unsigned char
• signed char
• char
• short
• unsigned short
• int
• unsigned int
• long
• unsigned long
• long long (C++11)
• unsigned long long (C++11)
• float
• double
• long double
/* Класс ostream предоставляет определение функции operator<<() для каждого из 
этих типов данных. Если применять оператор показанной ниже формы, и если значение 
относится к одному из перечисленных ранее типов, программа на языке C++ может 
сопоставить его с функцией операции с соответствующей сигнатурой: */
cout << значение;
// Например, выражение cout << 88 соответствует следующему прототипу метода:
ostream & operator<<(int);
/* Такой прототип указывает, что функция operator<<() принимает один аргумент 
типа 'int'. Это соответствует параметру '88' в предыдущем операторе. Прототип 
указывает также, что функция возвращает ссылку на объект ostream. Это свойство
позволяет группировать вывод, как показано в следующем примере: */
cout << "I'm feeling sedimental over " << boundary << "\n";
/*  Вывод и указатели.
Класс ostream определяет функции операции вставки для следующих типов указателей: */
• const signed char *
• const unsigned char *
• const char *
• void *
/* C++ представляет строку, используя указатель на ее местоположение. Указатель может 
иметь форму имени массива элементов типа 'char', явного указателя на 'char' или же 
строки в кавычках. Таким образом, все следующие операторы с 'cout' отображают строки: */
char name[20] = "Dudly Diddlemore";
char * pn = "Violet D'Amore";
cout << "Hello!";
cout << name;
cout << pn;
/* Для определения окончания последовательности отрбражаемых символов методы используют 
завершающий нулевой символ. C++ интерпретирует указатель любого другого типа как void * 
и выводит числовое представление адреса. Если требуется получить адрес строки, необходимо 
выполнить приведение к другому типу, как показано в следующем фрагменте кода: */
int eggs = 12;
char * amount = "dozen";
cout << &eggs;				// выводит адрес переменной 'eggs'
cout << amount;				// выводит строку 'dozen'
cout << (void *)amount;		// выводит адрес строки 'dozen'
/*  Конкатенация вывода.
 Все воплощения операции вставки определены с типом возвращаемого значения ostream &: */
ostream & operator<<(type);
/* 'type' — это тип отображаемого значения.) Возвращаемый тип 'ostream &' означает, 
что использование этой операции возвращает ссылку на объект 'ostream'.
Но на какой объект? В соответствии с определением функции — это ссылка на тот же 
объект, который использован для вызова операции. Другими словами, функция операции
возвращает тот же объект, который вызвал операцию. Например: */
cout << "potluck" /* возвращает объект 'cout'. Это свойство позволяет выполнять 
конкатенацию вывода, используя вставку. Например, рассмотрим следующий оператор: */
cout << "We have " << count << " unhatched chickens. \n";
/* Выражение ' cout << "We have " ' отображает строку и возвращает объект cout, 
сокращая оператор до следующего вида: */
cout << count << " unhatched chickens.\n";
/* Затем выражение 'cout << count' отображает значение переменной 'count' и возвращает 
объект 'cout', который затем может использоваться для обработки заключительного 
аргумента в операторе.
  Другие методы ostream.
 



























