/*	Создание объекта string.
 Представления конструкторов упрощены в том смысле, что они скрывают 
тот факт, что на самом деле string — это typedef для специализации 
шаблона basic_string<char>, и в них опущен необязательный параметр, 
относящийся к управлению памятью. sizetype является внутренним,
зависящим от реализации типом, который определен в заголовочном файле 
string. Класс определяет string::npos в качестве максимально возможной 
длины строки. Как правило, его значение будет равно максимальному значению
типа unsigned int. */
// Конструктор:						Описание:
string (const char * s)				/* Инициализирует объект string строкой, 
									завершающейся нулевым байтом, которая указана в 's'. */
string (size_type n, char c)			/* Создает объект типа string из n элементов, 
									каждый из которых инициализируется символом 'c'. */
string(const string & str)			/* Инициализирует объект string объектом str типа
									string (конструктор копирования). */
string()							/* Создает объект типа string нулевого размера 
									(конструктор по умолчанию). */
string (const char *s, size_type n)	/* Инициализирует объект типа string строкой, завершающейся
									нулевым байтом, которая указана в 's' и содержит n символов,
									даже если n превышает длину 's'. */
template<class Iter>				// Инициализирует объект типа string значениями в
string(Iter begin, Iter end)			/* диапазоне [begin, end), причем begin и end служат указателями 
									начала и конца диапазона. Диапазон начинается с позиции begin 
									включительно и заканчивается позицией end, не включая её.*/
string(const string & str, size_type pos, size_type n = npos) /* Инициализирует объект типа string
									объектом str, начиная с позиции pos и оканчивая концом str
									либо ограничиваясь n символами, в зависимости от того, какое
									условие будет удовлетворено раньше. */
string(string && str) noexcept		/* (C++11). Инициализирует объект string объектом str типа
									string. Объект str может быть изменен (конструктор переноса). */
string(initializer_list<char> il)	/* (C++11). Инициализирует объект типа string символами,
									указанными в списке инициализации il. */
#include <iostream>		// str1.cpp -- введение в класс string
#include <string>
// Использование различных конструкторов класса string
int main()
{
    using namespace std;
    string one("Lottery Winner!");				// ctor #1
/* Инициализация объекта string обычной строкой в стиле С и её вывод на экран с помощью 
перегруженной операции<< */
    cout << "one: " << one << endl;				// overloaded <<
    string two(20, '$');							// ctor #2
// Инициализирует объект two типа string строкой, состоящей из 20 символов $
    cout << "two: " << two << endl;
    string three(one);							// ctor #3
// Конструктор копирования инициализирует объект three типа string объектом one этого же типа
    cout << "three: " << three << endl;
// Перегруженная операция += дописывает строку " Oops!" к строке one:
    one += " Oops!";								// overloaded +=
/* Операция += имеет несколько перегрузок и с ее помощью можно добавлять как 
объекты string, так и отдельные символы. */
    cout << "one: " << one << endl;
/* Операция = тоже является перегружаемой, что позволяет присвоить объекту типа string другой
объект этого же типа, строку в стиле С или простое значение типа char. */
    two = "Sorry! That was ";
/* Перегрузка операции [], позволяет обращаться к отдельным символам объекта типа string,
используя нотацию массива: */
    three[0] = 'P';
// Конструктор по умолчанию создает пустую строку, которой впоследствии может быть присвоено значение:
    string four;								// ctor #4
/* Операция + используется для создания временного объекта string, который затем с помощью
перегруженной операции = присваивается объекту four: */ 
    four = two + three;							// overloaded +, =
/* Операция + объединяет два операнда в один объект типа string. Эта операция имеет несколько
перегрузок, поэтому второй операнд может быть объектом типа string, строкой в стиле С или
значением типа char. */
    cout << "four: " << four << endl;
    char alls[] = "All's well that ends well";
/* Конструктор принимает в качестве аргументов строку в стиле С и 
целочисленное значение, которое указывает количество копируемых символов: */
    string five(alls, 20);						// ctor #5
/* Если количество символов превышает длину строки в стиле С, запрошенное количество символов
все равно копируется. Поэтому замена значения 20 значением 40 в приведенном примере привела бы
к копированию в конец строки five пятнадцати бессмысленных символов. */
    cout << "five: " << five << "!\n";
// Использует шаблон template<class Iter> string(Iter begin, Iter end); в качестве аргумента:
    string six(alls + 6, alls + 10);				// ctor #6
/* begin и end выступают в роли указателей на начало и конец диапазона памяти. Конструктор применяет
значения элементов памяти, хранящиеся между позициями, указанными аргументами begin и end, для 
инициализации создаваемого им объекта типа string. Запись [begin, end), заимствованная из математики,
означает, что диапазон включает в себя begin, но не включает end. end указывает на позицию, следующую
за последним значением, которое должно быть использовано. Поскольку имя массива является указателем,
значения alls + 6 и alls + 10 будут иметь тип char *, и поэтому в шаблоне тип Iter заменяется типом char* .*/
    cout << "six: " << six  << ", ";
/* Следующий код работать не будет: string seven(five + 6, five + 10);
Причина в том, что имя объекта, в отличие от имени массива, не является адресом объекта. Следовательно,
five — не указатель, и выражение fіѵе + 6 не имеет смысла. Однако five[6] является значением типа char,
поэтому выражение &five[6] — это адрес, который может использоваться в качестве аргумента конструктора: */
    string seven(&five[6], &five[10]);			// ctor #6 again
    cout << "seven: " << seven << "...\n";
/* Копирует 16 символов из объекта four в объект eight, начиная с
седьмой позиции (восьмого символа) объекта four: */
    string eight(four, 7, 16);					// ctor #7
    cout << "eight: " << eight << " in motion!" << endl;
    return 0; 
}
/* ctor — стандартная аббревиатура конструктора в C++).
  Конструкторы C++11.
 Конструктор string (string && str) noexcept подобен конструктору копирования
в том смысле, что новый объект string является копией объекта str. Однако, в 
отличие от конструктора копии, он не гарантирует, что объект str будет 
трактоваться как const. Эту форму конструктора называют конструктором переноса.
В некоторых ситуациях компилятор может использовать его вместо конструктора
копирования для оптимизации производительности.
 Конструктор string (initializer_list<char> il) обеспечивает возможность
списковой инициализации класса string: */
string piano_man = { 'L', 'i', 's', 'z', 't'};
string comp_lang {'L', 'i', 's', 'p'};
/*  Ввод для класса string.
 Для строк в стиле С существуют три варианта ввода данных: */
char info[100];
cin >> info;				// чтение слова
cin.getline(infо, 100);	// чтение строки с отбрасыванием символа \п
cin.get(info, 100);		// чтение строки с сохранением символа \п в очереди
// Для объектов string доступны два варианта:
string stuff;
cin >> stuff;			// чтение слова
getline(cin, stuff);		// чтение строки с отбрасыванием символа \п
/* Обе версии вызова функции getline() допускают использование необязательного
аргумента — символа, завершающего ввод: */
cin.getline(info, 100, ':'); // чтение до символа ':', ':' отбрасывается
getline(stuff, ':');		// чтение до символа ':', ':' отбрасывается
/* Основное различие состоит в том, что версии с использованием string 
автоматически изменяют размер целевого объекта string в соответствии с
количеством вводимых символов: */
char fname[10];
string lname;
cin >> fname;			// возможно возникновение проблем,
						// если вводится больше 9 символов
cin >> lname;			// можно читать очень длинные строки
cin.getline(fname, 10);	// вводимая строка может быть усечена
getline(cin, fname);		// никакого усечения не выполняется
/* Функция автоматического определения размера позволяет версии getline(), 
использующей объект string, отказаться от параметра, который ограничивает 
количество вводимых символов. Конструктивное же различие состоит в том, 
что средствами ввода строк в стиле С являются методы класса istream, а 
средствами версий с объектами string — автономные функции. Именно поэтому 
cin является вызывающим объектом для ввода строки в стиле С и аргументом 
функции для объекта ввода string. Это относится и к форме >>, что явно 
видно при записи кода в виде вызова функций: */
cin.operator>>(fname);	// метод класса ostream
operator>>(cin, lname);	// обычный вызов функции
/* Существует несколько ограничений на длину строки. Первый ограничивающий 
фактор — максимально допустимая длина строки, задаваемая константой string::npos.
Обычно она равна максимальному значению типа unsigned int, и на практике этого
хватает для обычного интерактивного ввода. Однако проблемы могут возникнуть 
при попытке считывания содержимого всего файла в один объект типа string. 
Второй ограничивающий фактор — размер памяти, доступной программе.
 Функция getline(), применяемая к классу string, будет читать данные из 
входного потока и сохранять их в объекте string до тех пор, пока не произойдет
одно из трех событий:
• Будет достигнут конец файла. В этом случае во входном потоке будет установлен
флаг eofbit и обе функции fail() и eof() возвратят значение true.
• Будет достигнут разделительный символ (\п по умолчанию). Этот символ 
удаляется из входного потока, но не сохраняется.
• Будет прочитано максимально возможное количество символов (меньшее из
значений константы string: :npos и доступного количества байтов памяти).
В этом случае во входном потоке будет установлен флаг failbit и функция
fail() возвратит значение true.
  В объекте, обеспечивающем работу с входным потоком, имеется система учета
для отслеживания ошибок при работе с потоком. В этой системе установленный флаг
eofbit означает достижение конца файла, failbit — ошибку при чтении из потока,
badbit — нераспознанный, например аппаратный, сбой и goodbit — нормальную 
работу без ошибок.
 Функция operator>>() для класса string ведет себя аналогичным образом, за
исключением того, что вместо чтения вплоть до разделительного символа и его 
отбрасывания она считывает данные из потока до тех пор, пока не встретится символ
пробела, и оставляет его в очереди ввода. Символом пробела является собственно
пробел, символ новой строки или символ табуляции, либо в более общем случае —
любой символ, для которого функция isspace() возвращает значение true.
Поскольку функции ввода для объектов string работают с потоками и распознают 
конец файла, их можно применять для ввода из файла. */
#include <iostream>			// strfile.cpp -- чтение строк из файла
#include <fstream>
#include <string>
#include <cstdlib>
int main()
{
     using namespace std;
      ifstream fin;
      fin.open("D:\\repos\\visual\\code\\Prata\\16\\string\\tobuy.txt");
      if (fin.is_open() == false)
      {
        cerr << "Can't open file. Bye.\n";		// не удается открыть файл
        exit(EXIT_FAILURE);
      }
      string item;
      int count = 0;
      getline(fin, item, ':');
      while (fin)								// до тех пор, пока нет ошибок ввода
      {
        ++count;
        cout << count << ": " << item << endl;	// нумерует строки и выводит их на экран
        getline(fin, item,':');     
      }
      cout << "Done\n";
      fin.close();
      return 0;
}
/* При использовании символа ':' в качестве разделителя символ перевода строки стал 
просто еще одним обычным символом. Поэтому символ перевода строки в конце первой 
строки файла стал первым символом строки, которая начинается со слов "cottage cheese".
Аналогично символ перевода строки в конце второй строки ввода, если он присутствует, 
становится единственным элементом девятой строки.
  Работа со строками.
 Строки можно сравнивать. Все шесть операций отношения перегружены для объектов 
 string, причем один объект будет считаться меньше другого, если он находится
раньше в машинной последовательности сопоставления. Если в основе последовательности 
сопоставления лежит код ASCII, то цифры будут считаться меньше прописных символов, 
а прописные символы — меньше строчных. Каждая операция отношения имеет три 
перегрузки, так что можно сравнивать объект string с другим объектом string, 
объект string со строкой в стиле С и строку в стиле С с объектом string: */
string snake1("cobra");
string snake2("coral");
char snake3[20] = "anaconda";
if (snake1 < snake 2) // operator<(const string &,  const string &)
if (snake1 == snake3) // operator==(const string &, const char *)
if (snake3 != snake2) // operator!=(const char *,   const string &)
/* Существуют две функции-члена класса string для определения размера строки —
size() и length(), которые возвращают количество символов в строке: */
if (snake1.length() == snake2.size())
	cout << "Both strings have the same length.\n"; // Строки имеют одинаковую длину
/* Функция length() пришла из ранних версий класса string, a size() добавлена для 
совместимости с STL.
 Поиск подстроки или символа в строке можно провести несколькими 
способами: */
// Прототип метода:						Описание:
size_type find(const string & str,		// Ищет в вызывающей строке первое вхождение
		size_type pos = 0) const			/* подстроки str, начиная с позиции pos. Возвращает
										индекс первого символа найденной подстроки или
										string::npos, если подстрока не найдена. */
size_type find(const char * s,			// Ищет в вызывающей строке первое вхождения
		size_type pos = 0) const			/* подстроки 's', начиная с позиции pos. Возвращает
										индекс первого символа найденной подстроки или
										string::npos, если подстрока не найдена. */
size_type find(const char * s,			// Ищет в вызывающей строке первое вхождение 
		size_type pos = 0, size_type n)	/* подстроки, состоящей из первых 'n' символов строки
										's', начиная с позиции pos. Возвращает индекс первого
										символа найденной подстроки или string::npos,
										если подстрока не найдена. */
size_type find(char ch,					// Ищет в исходной строке первое вхождение 
		size_type pos = 0) const			/* символа 'ch', начиная с позиции pos. Возвращает 
										индекс первого символа найденной подстроки или
										string::npos, если подстрока не найдена. */
/* Библиотека string также предоставляет связанные методы rfind (), find_first_of(),
find_last_of(), find_first_not_of() и find_last_not_of(), каждый из которых имеет 
тот же набор сигнатур перегруженных функций, что и метод find().
Метод rfind() находит последнее вхождение подстроки или символа.
Метод find_first_of() отыскивает первое вхождение в строке любого из 
символов, переданных в аргументах метода. Например, следующий оператор вернет 
позицию символа 'r' в строке "cobra" (3), поскольку это первое вхождение любого из
символов строки "hark" в строке "cobra": */
int where = snake1.find_first_of("hark");
/* Метод find_last_of() работает аналогично, только находит последнее вхождение.
Поэтому следующий оператор вернет позицию символа 'а' в строке "cobra": */
int where = snake1.last_first_of("hark");
/* Метод find_first_not_of() находит первый символ в вызывающей строке, 
который отличается от символа, переданного в аргументе. Таким образом, приведенный ниже
оператор вернет позицию символа 'c' в cobra, поскольку символ 'c' не найден в hark: */
int where = snake1.find_first_not_of("hark");
// hangman.cpp -- использование некоторых методов работы со строками
#include <iostream>
#include <string>
#include <cstdlib>
#include <ctime>
#include <cctype>
using std::string;
const int NUM = 26;
const string wordlist[NUM] = {"apiary", "beetle", "cereal",
    "danger", "ensign", "florid", "garage", "health", "insult",
    "jackal", "keeper", "loaner", "manage", "nonce", "onset",
    "plaid", "quilt", "remote", "stolid", "train", "useful",
    "valid", "whence", "xenon", "yearn", "zippy"};
int main()
{
    using std::cout;
    using std::cin;
    using std::tolower;
    using std::endl;
    
    std::srand(std::time(0));
    char play;
    cout << "Will you play a word game? <y/n> ";            // запуск игры в слова
    cin >> play;
    play = tolower(play);
    while (play == 'y')
    {
        string target = wordlist[std::rand() % NUM];
        int length = target.length();
        string attempt(length, '-');
        string badchars;
        int guesses = 6;
        cout << "Guess my secret word. It has " << length
            << " letters, and you guess\n"
            << "one letter at a time. You get " << guesses
            << " wrong guesses.\n";
        cout << "Your word: " << attempt << endl;           // вывод слова
    // перегрузка операций отношения позволяет работать со строками так же,
        while (guesses > 0 && attempt != target) // как с числовыми переменными
        {
            char letter;
            cout << "Guess a letter: ";
            cin >> letter;
    /* find() для проверки на повторное использование символа; если символ уже вводился, 
    то он будет присутствовать либо в строке badchars (неудачные попытки), либо в строке 
    attempt (удачные попытки): */
            if (badchars.find(letter) != string::npos
                || attempt.find(letter) != string::npos)
            {
                cout << "You already guessed that. Try again.\n";
                    continue;
            }
            int loc = target.find(letter);  // проверка на наличие введенного символа в загаданном слове
            if (loc == string::npos) // если достиг максимума size_t, значит введенной буквы нет в слове
            {
                cout << "Oh, bad guess!\n";
                --guesses;
                badchars += letter;                         // добавить к строке
            }
            else
            { // Если переменная Іос имеет допустимое значение, буква может быть помещена в
                cout << "Good guess!\n"; // соответствующую позицию строки ответа:
                attempt[loc] = letter;
                // Проверить, не появляется ли буква еще раз
                loc = target.find(letter, loc + 1); // Поскольку буква была найдена в позиции
                while (loc != string::npos)         // loc, следующий поиск должен начаться с позиции loc + 1
                {
                    attempt[loc] = letter;
                    loc = target.find(letter, loc + 1);
                }
           }
            cout << "Your word: " << attempt << endl;
            if (attempt != target)
            {
                if (badchars.length() > 0)
                    cout << "Bad choices: " << badchars << endl;
                cout << guesses << " bad guesses left\n";
            }
        }
        if (guesses > 0)
            cout << "That's right!\n";
        else
            cout << "Sorry, the word is " << target << ".\n";
        cout << "Will you play another? <y/n> ";
        cin  >> play;
        play = tolower(play);
    }
    cout << "Bye\n";
    return 0; 
}
/*  Другие возможности, предлагаемые классом string.
 Что происходит, когда программа дописывает букву в конец строки? Она не может просто
увеличить размер строки, поскольку это может привести к использованию соседних 
областей памяти, которые уже заняты. Поэтому нужно выделить новый блок памяти и 
скопировать туда старое содержимое строки. Частое повторение такой процедуры 
приводило бы к снижению производительности, поэтому большинство реализаций C++ 
выделяют для строки блок памяти больший, чем фактическая строка, обеспечивая 
возможность ее увеличения. Когда со временем размер строки превышает размер 
этого блока, программа выделяет новый блок, вдвое больше текущего, обеспечивая 
дополнительное свободное место без постоянного изменения размера. Метод capacity()
возвращает размер текущего блока, а метод reserve() позволяет запросить минимальный 
размер для блока. */
#include <iostream>		// str2.cpp -- использование методов capacity() и reserve()
#include <string>
int main()
{
    using namespace std;
    string empty;
    string small = "bit";
    string larger = "Elephants are a girl's best friend";
    cout << "Sizes:\n";
    cout << "\tempty: "  << empty.size()      << endl;
    cout << "\tsmall: "  << small.size()      << endl;
    cout << "\tlarger: " << larger.size()     << endl;
    cout << "Capacities:\n";
    cout << "\tempty: "  << empty.capacity()  << endl;
    cout << "\tsmall: "  << small.capacity()  << endl;
    cout << "\tlarger: " << larger.capacity() << endl;
    empty.reserve(50);
    cout << "Capacity after empty.reserve(50): " << empty.capacity() << endl;
    return 0;
}
/* Для строки резервируется минимум 15 символов и стандартный шаг увеличения 
размера на единицу меньше значений, кратных 16.
 Если имеется объект string, а нужна строка в стиле С? Например, может 
требоваться открыть файл, имя которого хранится в объекте string: */
string filename;
cout << "Enter file name: ";
cin >> filename;
ofstream fout;
/* Метод open() требует в качестве аргумента строку в стиле С. Однако существует 
метод c_str(), который возвращает указатель на строку в стиле С с тем же содержимым,
что и у вызывающего объекта string. Поэтому можно использовать следующий оператор: */
fout.open(filename.c_str());
/*  Разновидности строк.
 В действительности, в основе библиотеки string лежит шаблонный класс: */
template<class charT, class traits = char _traits<charT>,
		 class Allocator = allocator<charT> >
basic_string {...};
/* Существуют четыре разновидности шаблона basic_string, каждая из которых
имеет имя typedef: */
typedef basic_string<char>		string;
typedef basic_string<wchar_t>	wstring;
typedef basic_string<charl6_t>	ul6string;	// C++11
typedef basic_string<char32_t>	u32string;	// C++11
/* Это позволяет использовать строки на основе типов wchar_t, char16_t и
char32_t, а также строки на базе char. Более того, можно разработать свой класс
на основе символьных типов и применять шаблон класса basic_string при условии,
что новый класс удовлетворяет определенным требованиям. Класс traits описывает
определенные аспекты выбранного символьного типа, например, способы сравнения
значений. Существуют заранее определенные разновидности шаблона char_traits
для типов char, wchar_t, char16_t и char32_t, и они служат значениями по 
умолчанию для класса traits. Класс Allocator предназначен для управления памятью.
Доступны предварительно определенные разновидности шаблона allocator для 
различных типов символов, которые являются значениями по умолчанию. Они 
используют операции new и delete.
	Классы шаблонов интеллектуальных указателей.
 Интеллектуальный указатель (smart pointer) — это объект класса, который 
действует подобно указателю, но обладает дополнительными возможностями. */
void remodel(std::string & str)
{
	std::string * ps = new std::string(str);
	...
	str = ps;
	return;
}
/* При каждом вызове функции программа выделяет память из кучи, однако никогда 
не освобождает память, что приводит к утечкам памяти. Решение проблемы известно —
нужно лишь не забыть об освобождении памяти, т.е. добавить перед оператором return: */
delete ps;
/* Иногда об этом забывают. Или помнят, но случайно удаляют или комментируют 
эту строку кода. И даже когда об этом помнят, могут возникать проблемы: */
void remodel(std::string & str)
{
	std::string * ps = new std::string(str);
	...
	if (weird_thing())
		throw exception ();
	str = *ps;
	delete ps;
	return;
}
/* При возникновении исключения до операции delete дело не доходит, и это снова
приводит к утечке памяти.
  Использование интеллектуальных указателей.
 auto_ptr, unique_ptr и shared_ptr определяют подобный указателю объект, которому 
присваивается адрес области памяти, полученный (прямо или косвенно) операцией new.
Когда срок существования интеллектуального указателя истекает, его деструктор 
использует операция delete для освобождения памяти. Таким образом, присваивая 
адрес, возвращенный операцией new, одному из этих объектов, не нужно беспокоиться
об освобождении памяти впоследствии; она будет освобождена автоматически при
удалении объекта интеллектуального указателя. Чтобы создать один из этих объектов
интеллектуальных указателей, потребуется включить заголовочный файл memory, 
который содержит определения шаблонов. Затем с помощью обычного синтаксиса шаблона
создается необходимая разновидность указателя. Например, шаблон auto_ptr содержит 
следующий конструктор: */
template<class X> class auto_ptr
{
public:
	explicit auto_ptr(X * p = 0) throw();
	...
};
/* Нотация throw() означает, что конструктор не должен генерировать исключения.
Как и auto_ptr, она считается устаревшей. Таким образом, запрашивая объект
auto_ptr типа X, мы получаем объект auto_ptr, который указывает на значение типа X: */
auto_ptr<double> pd(new double);		// pd — объект auto_ptr, указывающий на значение
									// типа double (используется вместо double * pd)
auto_ptr<string> ps(new string);		// ps — объект auto_ptr, указывающий на значение
									// типа string (используется вместо string * ps)
/* new double — это указатель (возвращенный операцией new) на новый выделенный
участок памяти. Он используется в качестве аргумента при вызове конструктора 
auto_ptr<double>, т.е. является фактическим аргументом, соответствующим 
формальному параметру 'p' в прототипе класса. Аналогично, new string также 
является фактическим аргументом конструктора. Остальные два интеллектуальные 
указатели используют тот же самый синтаксис: */
unique_ptr<double> pdu(new double); // pdu — объект unique_ptr, указывающий на double
shared_ptr<string> pss(new string); // pss — объект shared_ptr, указывающий на string
/* Таким образом, чтобы преобразовать функцию remodel(), понадобится 
выполнить следующие три шага.
1. Включить заголовочный файл memory.
2. Заменить указатель на string объектом интеллектуального указателя, который
указывает на string.
3. Удалить обращение к операции delete. */
#include <memory>
void remodel(std::string & str)
{
	std::auto_ptr<std::string> ps(new std::string(str));
	if (weird_thing())
		throw exception();
	str = * ps;
	// delete ps; ЭТОТ ОПЕРАТОР БОЛЬШЕ НЕ НУЖЕН
	return;
}
// Интеллектуальные указатели принадлежат пространству имен std.
#include <iostream>	// smrtptrs.cpp -- использование трех видов интеллектуальных указателей
#include <string>
#include <memory>
class Report
{
private:
    std::string str;
public:
    Report(const std::string s) : str(s) { std::cout << "Object created!\n"; }
    ~Report() { std::cout << "Object deleted!\n"; }
    void comment() const { std::cout << str << "\n"; }
};
int main()
{
    {
        std::auto_ptr<Report>   ps (new Report("using auto_ptr"));
        ps->comment();   // использование операции -> для вызова функции-члена
    }
    {
        std::shared_ptr<Report> ps (new Report("using shared_ptr"));
        ps->comment();
    }
    {
        std::unique_ptr<Report> ps (new Report("using unique_ptr"));
        ps->comment();
    }
    return 0;
}
/* Каждый из этих классов имеет конструктор explicit, который принимает 
указатель в качестве аргумента. Поэтому автоматическое преобразование типов
из указателя в объект интеллектуального указателя не выполняется: */
shared_ptr<double> pd;
double * p_reg = new double;
pd = p_reg;							// недопустимо (неявное преобразование)
pd = shared_ptr<double>(p_reg);		// допустимо (явное преобразование)
shared_ptr<double> pshared = p_reg;	// недопустимо (неявное преобразование)
shared_ptr<double> pshared(p_reg);	// допустимо (явное преобразование)
/* Объект интеллектуального указателя работает подобно обычному указателю. 
Например, если ps — объект интеллектуального указателя, его можно разыменовывать 
(*ps), использовать для получения доступа к членам структуры (ps->puffIndex)
и присваивать регулярному указателю, который указывает на тот же тип. Один объект
интеллектуального указателя можно также присвоить другому того же типа, но при
этом возникают проблемы. Ситуация, "которой следует избегать при использовании 
всех трех названных интеллектуальных указателей: */
string vacation("I wandered lonely as a cloud.");
shared_ptr<string> pvac(&vacation);	// ТАК ДЕЛАТЬ НЕЛЬЗЯ!
/* При удалении объекта рѵас программа применила бы операцию delete к памяти
не из кучи, что совершенно неприемлемо.
  Соображения по поводу интеллектуальных указателей.
 Почему отказались от указателя auto_ptr? */
auto_ptr<string> ps(new string("I reigned lonely as a cloud."));
auto_ptr<string> vocation;
vocation = ps;
/* Каким должен быть результат этого оператора присваивания? Если бы ps и
vocation были обычными указателями, результатом стали бы два указателя на один
и тот же объект string. В данном случае это недопустимо, поскольку программа вела
бы себя непредсказуемо, пытаясь удалить один объект дважды — при удалении ps и
при удалении vocation. Существуют следующие способы предотвращения этой проблемы:
• Определить операцию присваивания так, чтобы она создавала точную копию
объекта. Тогда два указателя будут указывать на два разных объекта, один из 
которых является копией второго.
• Использовать концепцию владения, когда определенным объектом может владеть
только один интеллектуальный указатель. Деструктор будет удалять объект 
только тогда, когда интеллектуальный указатель владеет объектом. Затем можно 
использовать операцию присваивания, которая будет передавать право владения
объектом. Эта стратегия применяется указателями auto_ptr и unique_ptr, но
unique_ptr накладывает несколько больше ограничений.
• Создать еще более интеллектуальный указатель, который будет отслеживать,
сколько интеллектуальных указателей ссылается на определенный объект. Эта
стратегия называется подсчетом ссылок. Например, присваивание могло бы 
увеличивать значение счетчика на единицу, а удаление указателя — уменьшать его.
Тогда операция delete вызвалась бы только при удалении последнего
указателя. Эта стратегия применяется для указателя shared_ptr.
 Те же самые стратегии применимы и к конструкторам копирования. */
#include <string>		// fowl.cpp  -- неудачный выбор
#include <memory>
#include <iostream>
int main()
{
    using namespace std;
    std::auto_ptr<string> films[5] =
    {
        std::auto_ptr<string> (new string("Fowl Balls")),
        std::auto_ptr<string> (new string("Duck Walks")),
        std::auto_ptr<string> (new string("Chicken Runs")),
        std::auto_ptr<string> (new string("Turkey Errors")),
        std::auto_ptr<string> (new string("Goose Eggs"))
    };
    std::auto_ptr<string> pwin;
    pwin = films[2];			// films[2] утрачивает права владения
    std::cout << "The nominees for best avian baseball film are\n";
    for (int i = 0; i < 5; i++)
        std::cout << *films[i] << std::endl;
    std::cout << "The winner is " << *pwin << "!\n";
    return 0;
}
// Вывод:
The nominees for best avian baseball film are
Fowl Balls
Duck Walks
Segmentation fault(core dumped).
/* Проблема заключается в том, что следующий оператор передает права владения 
от films[2] к pwin: */
pwin = films[2];		// films[2] утрачивает права владения
/* Это ведет к тому, что элемент массива films[2] перестает ссылаться на строку.
После того, как auto_ptr передает права владения объектом, он больше не 
предоставляет доступ к этому объекту. Когда программа приступает к выводу строки, 
указанной элементом films[2], она обнаруживает нулевой указатель, что, несомненно, 
оказывается неприятным сюрпризом. Если вместо auto_ptr использовали shared_ptr,
программа выполнится успешно и даст следующий вывод: */
The nominees, for best avian baseball film are
Fowl Balls
Duck Walks
Chicken Runs
Turkey Errors
Goose Eggs
The winner is Chicken Runs!
// Различие состоит в следующей части программы:
shared_ptr<string> pwin;
pwin = films[2];
/* На этот раз и pwin, и films[2] указывают на один и тот же объект, а значение 
счетчика ссылок увеличивается с 1 до 2. В конце программы объект pwin, который был
объявлен последним, оказывается первым, чей деструктор будет вызван. Деструктор
уменьшает значение счетчика ссылок до 1. Затем элементы массива shared_ptrs 
освобождаются. Деструктор films[2] уменьшает значение счетчика до 0 и освобождает
ранее выделенную память. Это же относится к shared_ptr. Программа из листинга 
выполнится успешно. При использовании auto_ptr происходит ошибка времени выполнения.
 А что происходит в случае применения unique_ptr? Как и auto-ptr, unique_ptr 
использует модель владения. Однако вместо сбоя версия с unique_ptr генерирует ошибку
во время компиляции следующей строки кода: */
pwin = films[2];
//  Почему uniqae_ptr предпочтительней auto_ptr.
auto_ptr<string> p1(new string("auto");	//#1
auto_ptr<string> p2;						//#2
p2 = p1;								//#3
/* Когда в операторе #3 указатель р2 получает права владения объектом string, 
указатель р1 лишается этих прав. Это хорошо, поскольку препятствует попыткам дест-
рукторов обоих объектов р1 и р2 удалить один и тот же объект. Но это же и плохо,
если впоследствии программа пытается использовать р1, т.к. р1 больше не указывает
на соответствующие данные. Теперь рассмотрим эквивалентную программу, в которой
применяется unique_ptr: */
unique_ptr<string> р3(new string("auto");	//#4
unique_ptr<string> p4;						//#5
p4 = p3;									//#6
/* В этом случае компилятор не разрешает выполнение оператора #6, и мы избегаем
проблемы, связанной с тем, что p3 не указывает на соответствующие данные. Таким
образом, unique_ptr безопаснее auto_ptr (поскольку вызывает ошибку времени 
компиляции, а не приводит к сбою программы). В некоторых случаях присваивание 
одного интеллектуального указателя другому не устраняет потенциальные проблемы. */
unique_ptr<string> demo(const char * s)
{
	unique_ptr<string> temp(new string(s));
	return temp;
}
// Также представим, что используется такой код:
unique_ptr<string> ps;
ps = demo("Uniquely special");
/* В этом примере функция demo() возвращает временный объект unique_ptr, а 
затем ps принимает права владения объектом, первоначально принадлежавшего 
возвращенному объекту unique_ptr. После этого возвращенный объект unique_ptr 
уничтожается. Это нормально, поскольку теперь объект ps владеет объектом string.
При этом имеет место еще один положительный нюанс. Поскольку временный объект
unique_ptr, возвращенный функцией demo(), вскоре уничтожается, отсутствует 
какая-либо возможность его неправильного использования для доступа к недопустимым
данным. Вданном случае нет никакой причины запрещать присваивание. И, как не 
удивительно, компилятор его разрешает! Если программа пытается присвоить один 
объект unique_ptr другому, компилятор не препятствует этому, если исходный 
объект является временным значением, и запрещает это, если исходный объект 
существует некоторое время: */
using namespace std;
unique_ptr<string> pu1(new string "Hi ho!");
unique_ptr<string> pu2;
pu2 = pu1;									// #1 не разрешено
unique_ptr<string> pu3;
pu3 = unique_ptr<string>(new string "Yo!");	// #2 разрешено
/* Оператор присваивания #1 оставил бы висячий объект unique_ptr (объект pu1) —
возможный источник ошибки. Оператор присваивания #2 не оставляет за собой 
никакого объекта unique_ptr, поскольку он вызывает конструктор unique_ptr, 
создающий временный объект, уничтожаемый при передаче прав владения объекту риЗ.
Это избирательное поведение — одна из причин того, что шаблон unique_ptr 
предпочтительнее auto_ptr, который допускал бы обе формы присваивания. По этой же 
причине использование объектов auto_ptr в контейнерных объектах запрещается 
(рекомендацией, но не компилятором), в то время как применение объектов unique_ptr
разрешено. Если алгоритм контейнера пытается выполнить с содержимым контейнера 
unique_ptr что-либо аналогичное строкам присваивания #1, это ведет к ошибке
времени компиляции. Если же алгоритм пытается выполнить что-то вроде присваивания
#2, то все проходит нормально, и выполнение программы продолжается. При
использовании объектов auto_ptr действия, подобные присваиванию #1, могли бы
вести к непрогнозируемому поведению и непонятным сбоям программы.
 В определенных ситуациях действительно может требоваться выполнение действий,
подобных присваиванию #1. Присваивание небезопасно только при неинтеллектуальном 
использовании отброшенного интеллектуального указателя, например, при его 
разыменовании. Но указатель можно безопасно использовать, присвоив ему новое 
значение. В C++ имеется стандартная библиотечная функция std::move(), которая 
позволяет присваивать один объект unique_ptr другому. */
std::unique_ptr<std::string> ps1, ps2;
ps1 = demo("Uniquely special");
ps2 = std::move(ps1);	// делает возможным присваивание (перемещающее присваивание &&)
ps1 = demo(" and more");
std::cout << *ps2 << *ps1 << std::endl;
/* Может возникать вопрос, каким образом unique_ptr, в отличие от auto_ptr, 
способен различить безопасное и потенциально опасное использование. Ответ 
заключается в том, что он использует дополнения конструкторов переноса и 
ссылок rvalue из С++11. unique_ptr обладает еще одним преимуществом по сравнению
с auto_ptr. Он имеет вариант, который можно использовать с массивами. Операция 
delete применяется только в паре с new, a delete[] — только в паре с new[].
Шаблон auto_ptr использует операцию delete, а не delete[], поэтому может 
применяться только с new, но не с new[]. Однако unique_ptr имеет версию
для пары new[] и delete[]: */
std::unique_ptr< double[] > pda(new double(5)); // будет использовать delete[]
/* Объект auto_ptr или shared_ptr должен использоваться только для памяти, 
выделенной операцией new. Память, выделенная с помощью new[], не подходит. 
Нельзя применять auto_ptr, shared_ptr или unique_ptr для памяти, выделенной 
посредством операции new либо, в случае unique_ptr, с помощью new или new[].
  Выбор интеллектуального указателя.
 Если в программе требуется более одного указателя на объект, необходимо 
выбрать shared_ptr. Например, может существовать массив указателей, а несколько
вспомогательных указателей применяться для идентификации определенных элементов,
таких как максимальный и минимальный. Или же возможно наличие двух видов объектов,
которые содержат указатели на один и тот же третий объект. Либо можно располагать
контейнером указателей из STL. Многие алгоритмы STL включают в себя операции 
копирования или присваивания, которые будут работать с объектом shared_ptr, но не
с unique_ptr (компилятор будет выводить предупреждение) либо auto_ptr (это будет
приводить к непредсказуемому поведению). Если компилятор не разрешает применять 
shared_ptr, можно получить версию из библиотеки BOOST.
 Если программа не нуждается в нескольких указателях на один и тот же объект,
unique_ptr работает вполне успешно. Это хороший вариант для возвращаемого типа
функции, которая возвращает указатель на память, выделенную операцией new. В 
результате права владения передаются объекту unique_ptr, которому присвоено 
возвращаемое значение, и интеллектуальный указатель принимает на себя ответственность
за вызов операции delete. Объекты unique_ptr можно сохранять в контейнере STL,
если только не требуется вызывать методы или алгоритмы, такие как sort(), которые
копируют или присваивают один объект unique_ptr другому. Например, при условии
наличия соответствующих операторов include и using, в программе можно было бы
использовать фрагменты кода вроде показанных ниже: */
unique_ptr<int> make_int(int n)
{
	return unique_ptr<int>(new int(n));
}
void show(unique_ptr<int> & pi)		// передача по ссылке
{
	cout << *a << ' ';
}
int main ()
{	...
	vector< unique_ptr<int> > vp(size);
	for (int i = 0; i < vp.size(); i++)
		vp[i] = make_int(rand() % 1000);  // копирование временного unique_ptr
	vp.push_back(make_int(rand() % 1000)) // номально, поскольку аргумент является временным
	for_each(vp.begin(), vp.end(), show); // использование for_each()
	...
}
/* Вызов функции push_back() работает, поскольку он передает временный объект
unique_ptr, который должен быть присвоен объекту unique_ptr в 'ѵр'.
Обратите внимание, что оператор for_each() приводил бы к ошибке, если бы функция
show() передавала объект по значению, а не посредством ссылки, поскольку в этом
случае было бы необходимо инициализировать рі значением unique_ptr из 'ѵр', не
являющимся временным, что недопустимо. Как уже упоминалось, компилятор будет
перехватывать попытки неправильного использования объекта unique_ptr.
 Объект unique_ptr можно присваивать объекту shared_ptr при соблюдении тех
же условий, при которых один объект unique_ptr допускается присваивать другому —
источником должно быть rvalue. Как и ранее, в следующем коде make_int() 
представляет собой функцию, возвращаемым типом которой является unique_ptr<int>: */
unique_ptr<int> pup(make_int(rand() % 1000);	// нормально
shared_ptr<int> spp(pup);					// недопустимо, pup — это lvalue
shared_ptr<int> spr(make_int(rand() % 1000);	// нормально
/* Шаблон shared_ptr содержит явный конструктор преобразования rvalue типа
unique_ptr в shared_ptr. При этом shared_ptr принимает права владения объектом,
первоначально принадлежавшего unique_ptr. Объект auto_ptr можно было бы 
использовать в тех же ситуациях, что и unique_ptr, но последний предпочтительнее.
Если компилятор не поддерживает unique_ptr, можно подумать о применении класса
scoped_ptr из библиотеки BOOST, который предлагает аналогичные возможности.
	Стандартная библиотека шаблонов (STL).
 STL не является примером объектно-ориентированного программирования. В ней 
используется другая идеология программирования — обобщенное программирование.
  Класс шаблона vector.
 Вектор — это набор однотипных значений, к которым можно обращаться в произвольном
порядке. То есть, например, с помощью индекса можно получить непосредственный 
доступ к десятому элементу вектора без необходимости считывания девяти предыдущих 
элементов. Это значит, что можно создать объект vector, присвоить один объект 
vector другому и применять операцию [] для доступа к отдельным элементам объекта 
vector. Чтобы сделать этот класс обобщенным, его нужно реализовать в виде класса 
шаблона. Шаблон vector использует динамическое выделение памяти, и для указания 
количества элементов вектора можно применять инициализирующий аргумент: */
#include vector
std::vector<int> ratings(5);		// вектор из 5 значений типа int
int n;
std::cin >> n;
std::vector<double> scores(n);	// вектор из п значений типа double
/* После создания объекта vector перегрузка операции [] позволяет обращаться к
элементам вектора, используя обычную нотацию массивов: */
ratings[0] = 9;
for (int i = 0; i < n; i++)
	cout << scores[i] << endl;
/* Подобно классу string, различные шаблоны контейнеров STL принимают необязательный
аргумент, который указывает, какой объект-распределитель будет использоваться для
управления памятью. Например, шаблон vector начинается с таких строк: */
template < class T, class Allocator = allocator<T> >
class vector {...
/* Если опустить значение этого аргумента, шаблон контейнера по умолчанию будет 
применять класс allocator<T>. Этот класс использует операции new и delete. */
#include <iostream>			// vect1.cpp -- пример работы с шаблоном vector
#include <string>
#include <vector>
const int NUM = 2;
int main()
{
    std::vector<int> ratings(NUM);
    std::vector<std::string> titles(NUM);
    std::cout << "You will do exactly as told. You will enter\n"
              << NUM << " book titles and your ratings (0-10).\n";
    int i;
    for (i = 0; i < NUM; i++)
    {
        std::cout << "Enter title #" << i + 1 << ": ";
        std::getline(std::cin, titles[i]);
        std::cout << "Enter your rating (0-10): ";
        std::cin >> ratings[i];
        std::cin.get();
    }
    std::cout << "Thank you. You entered the following:\n"
              << "Rating\tBook\n";
    for (i = 0; i < NUM; i++)
    {
        std::cout << ratings[i] << "\t"
                  << titles[i] << '\n';
    }
    return 0; 
}
/* Итератор - это обобщение указателя. Он может быть указателем или объектом, для 
которого определены операции над указателями, такие как разыменование (например, 
operator*()) и инкремент (например, operator++()). Обобщение указателей позволяет 
STL предоставлять однотипный интерфейс для множества классов-контейнеров, включая 
те, для которых обычные указатели не работают. В каждом классе-контейнере 
определяется соответствующий итератор. Типом этого итератора будет typedef по 
имени iterator с областью видимости класса. */
vector<double>::iterator pd;		// pd — это итератор
// Предположим, что scores — это объект vector<double>:
vector<double> scores;
// Теперь итератор pd можно применять в коде, как показано ниже:
pd = scores.begin();	// обеспечение того, чтобы pd указывал на первый элемент
*pd = 22.3;			// разыменование pd и присваивание значения первому элементу
++pd;				// обеспечение того, чтобы pd указывал на следующий элемент
/* Итератор ведет себя подобно указателю. Автоматическое выведение типа С++11 
может быть полезно еще в одной ситуации. Вместо оператора: */
vector<double>::iterator pd = scores.begin();
// можно использовать следующий оператор:
auto pd = scores.begin();	// автоматическое выведение типа С++11
/* Функция-член end() определяет позицию, следующую за последним элементом контейнера.
Если установить итератор на первый элемент контейнера и увеличивать его, то, в конце 
концов, будет достигнут элемент, следующий за последним — т.е. все содержимое 
контейнера было пройдено. Таким образом, если scores и pd определены как в предыдущем 
примере, то все содержимое контейнера можно отобразить с помощью следующего кода: */
for (pd = scores.begin(); pd != scores.end(); pd++)
cout << *pd << endl;
/* Метод push_back() — добавляет элемент в конец объекта vector. При выполнении этой
операции осуществляется дополнительное выделение памяти,и размер вектора увеличивается,
чтобы в него поместились добавляемые элементы. */
vector<double> scores;	// создание пустого вектора
double temp;
while (cin >> temp && temp >= 0)
	scores.push_back(temp);
cout << "You entered " << scores.size() << " scores.\n";
/* На каждом проходе цикла в объект scores добавляется один элемент. Во время
создания или запуска программы не нужно заботиться о количестве элементов. До тех
пор, пока у программы есть доступ к необходимому объему памяти, размер scores
будет при необходимости увеличиваться.
 Метод erase() удаляет данный диапазон элементов вектора. В качестве аргументов 
он принимает два итератора, которые определяют границы диапазона удаляемых
элементов. Первый итератор указывает на начало диапазона, второй — на элемент, 
следующий за концом диапазона. Например, следующий код удаляет первый и второй 
элементы — те, на которые ссылаются begin() и begin() + 1: */
scores.erase(scores.begin(), scores.begin() + 2);
/* Поскольку vector предоставляет непосредственный доступ к любому элементу,
такие операции, как begin() +, определены для итераторов класса vector. В 
литературе по STL используется также запись вида [р1, р2), где р1 и р2 —
итераторы), описывающая диапазон, начинающийся с р1 и заканчивающийся, но не 
включающий, р2. Таким образом, диапазон [begin(), end()) охватывает все 
содержимое коллекции. Кроме того, запись [p1, p1) определяет пустой диапазон.
Нотация [) неявляется частью языка C++, поэтому в коде она не используется и
присутствует только в документации.
 Метод insert() дополняет erase(). В качестве аргументов он принимает три
итератора. Первый указывает позицию, после которой будут добавляться новые 
элементы. Второй и третий итераторы описывают добавляемый диапазон. Обычно этот
диапазон является частью другого объекта контейнера. Например, следующий код
вставляет все элементы вектора new_v, за исключением первого, после первого 
элемента вектора old_v: */
vector<int> old_v;
vector<int> new_v;
old_v.insert(old_v.begin(), new_v.begin() + 1, new_v.end());
/* Кстати, здесь может пригодиться метод end(), поскольку он облегчает добавление
элементов в конец вектора. В коде ниже новые данные добавляются после позиции
old.end(), т.е. после последнего элемента вектора: */
old_v.insert(old_v.end(), new_v.begin() + 1, new_v.end());
// vect2.cpp -- методы и итераторы
#include <iostream>
#include <string>
#include <vector>
struct Review
{
    std::string title;
    int rating;
};
bool FillReview(Review & rr);
void ShowReview(const Review & rr);
int main()
{
    using std::cout;
    std::vector<Review> books;
    Review temp;
    while (FillReview(temp))
        books.push_back(temp);
    int num = books.size();
    if (num > 0)
    {
        cout << "Thank you. You entered the following:\n"
             << "Rating\tBook\n";
        for (int i = 0; i < num; i++)
            ShowReview(books[i]);
        cout << "Reprising:\n"
             << "Rating\tBook\n";
        std::vector<Review>::iterator pr;
        for (pr = books.begin(); pr != books.end(); pr++)
            ShowReview(*pr);
        std::vector <Review> oldlist(books);                    // использование конструктора копирования
        if (num > 3)
        {
            books.erase(books.begin() + 1, books.begin() + 3);  // Удаление двух элементов
            cout << "After erasure:\n";
            for (pr = books.begin(); pr != books.end(); pr++)
                ShowReview(*pr);
            books.insert(books.begin(), oldlist.begin() + 1, oldlist.begin() + 2); // Вставка одного элемента
            cout << "After insertion:\n";
            for (pr = books.begin(); pr != books.end(); pr++)
                ShowReview(*pr);
        }
        books.swap(oldlist);
        cout << "Swapping oldlist with books:\n";
        for (pr = books.begin(); pr != books.end(); pr++)
            ShowReview(*pr);
    }
    else
        cout << "Nothing entered, nothing gained.\n";
	return 0;
}
bool FillReview(Review & rr)
{
    std::cout << "Enter book title (quit to quit): ";
    std::getline(std::cin,rr.title);
    if (rr.title == "quit")
        return false;
    std::cout << "Enter book rating: ";
    std::cin >> rr.rating;
    if (!std::cin)
        return false;
    while (std::cin.get() != '\n')      // Избавиться от остальной части строки ввода
        continue;
    return true;
}
void ShowReview(const Review & rr)
{
    std::cout << rr.rating << "\t" << rr.title << std::endl; 
}
/*  Дополнительные возможности векторов.
 Автономные, не являющиеся членами класса функции, определены для выполнения 
операций, такие как поиск, сортировка, тасование и т.д. Таким образом, вместо 
того чтобы определять отдельную функцию-член find() для каждого класса контейнера,
в библиотеке определяется одна автономная функция find(), которая может 
использоваться для всех классов контейнеров. В ряде случаев STL определяет 
функцию-член даже при наличии автономной функции для решения той же самой задачи.
Причина в том, что специфичные для класса алгоритмы выполнения некоторых действий 
эффективнее более общих алгоритмов. Поэтому функция swap() класса vector будет 
эффективнее автономной функции swap(). С другой стороны, автономная версия позволит 
обменивать содержимое двух контейнеров различного типа.
 Функция for_each() работает с любым классом-контейнером. Она принимает три аргумента.
Первые два аргумента — это итераторы, определяющие диапазон, а третий аргумент —
указатель на функцию, представляющий собой объект функции (функтор). Затем функция 
for_each() применяет указанную в аргументе функцию ко всем элементам контейнера в 
указанном диапазоне. Функция, указанная в аргументе, не должна изменять значение 
элементов контейнера. Функцию for_each() можно использовать вместо цикла for. Например, 
код: */
vector<Review>::iterator pr;
for (pr = books.begin(); pr != books.end(); pr++)
	ShowReview(*pr);
// можно заменить следующим кодом:
for_each(books.begin(), books.end(), ShowReview);
/* Это позволяет избежать явного использования переменных итераторов.
 Функция random_shuffle() принимает в качестве аргументов два итератора, которые
указывают границы диапазона, и тасует элементы в этом диапазоне случайным образом.
Например, следующий оператор изменяет случайным образом порядок следования всех 
элементов вектора books: */
random_shuffle(books.begin(), books.end());
/* В отличие от функции for_each(), которая работает с любым классом-контейнером,
random_shuffle() требует, чтобы класс контейнера разрешал доступ к своим
элементам в произвольном порядке. Класс vector удовлетворяет этому требованию.
 Функция sort() также требует, чтобы контейнер поддерживал произвольный 
доступ. Существуют две версии этой функции. Первая использует два итератора, 
определяющих границы диапазона, и сортирует элементы этого диапазона с помощью 
операции <, определенной для типа элемента, который хранится в контейнере. Например,
следующий код сортирует содержимое coolstuff по возрастанию с применением
встроенной операции < для сравнения значений: */
vector<int> coolstuff;
sort(coolstuff.begin(), coolstuff.end());
/* Если элементами контейнера являются объекты, типы которых определены 
пользователем, то для этого типа объектов должна быть определена функция operator<(),
в противном случае функция sort() работать не будет. Например, вектор, содержащий
объекты Review, можно было бы сортировать либо с помощью функции-члена класса
Review, либо с помощью автономной функции operator<(). Поскольку Review — это 
структура, ее члены открыты, и в этом случае можно применять автономную функцию: */
bool operator<(const Review & r1, const Review & r2)
{
	if (r1.title < r2.title)
		return true;
	else if (r1.title == r2.title && r1.rating < r2.rating)
		return true;
	else
		return false;
}
/* Используя подобную функцию, можно отсортировать вектор объектов Review: */
sort(books.begin(), books.end());
/* Эта версия функции operator<() сортирует члены title в лексикографическом
порядке. Если у двух объектов поля title совпадают, объекты сортируются по полю
rating. Но предположим, что требуется выполнить сортировку в убывающем порядке
или по рейтингам rating, а не по заглавиям title. В этом случае можно 
использовать вторую форму функции sort(). Она принимает три аргумента. Первые два,
как и в предыдущем случае, являются итераторами, определяющими диапазон. Третий 
аргумент — указатель на функцию (точнее — функтор), которая будет использоваться 
вместо operator<() для выполнения сравнения. Функция должна возвращать значение,
которое можно преобразовать в тип bool, причем значение false означает, что 
аргументы функции расположены в неправильном порядке. Вот пример такой функции: */
bool WorseThan(const Review & r1, const Review & r2)
{
	if (r1.rating < r2.rating)
		return true;
	else
		return false;
}
/* Располагая этой функцией, можно написать следующий оператор для сортировки
вектора books, состоящего из объектов Review, по возрастанию рейтинга: */
sort(books.begin(), books.end(), WorseThan);
/* Функция WorseThan(). сортирует объекты Review менее точно, чем operator<(). 
Если член title объектов совпадает, функция operator<() осуществляет сортировку по 
полю rating. Но если и эти два поля объектов совпадают, функция WorseThan() считает
их эквивалентными. Первый вид упорядочения называется полным упорядочением, а 
второй — строгим квазиупорядочением. При полном упорядочении, если оба выражения 
а < b и b < а ложны, то 'а' должно быть идентично 'b'. При строгом квазиупорядочении
это не так. Объекты могут быть полностью идентичными, а могут совпадать только по 
одному критерию, такому, как поле rating в примере с функцией WorseThan(). Поэтому 
при строгом квазиупорядочении лучше говорить, что объекты эквивалентны, а не идентичны.*/















