/*	Создание объекта string.
 Представления конструкторов упрощены в том смысле, что они скрывают 
тот факт, что на самом деле string — это typedef для специализации 
шаблона basic_string<char>, и в них опущен необязательный параметр, 
относящийся к управлению памятью. size_type является внутренним,
зависящим от реализации типом, который определен в заголовочном файле 
string. Класс определяет string::npos в качестве максимально возможной 
длины строки. Как правило, его значение будет равно максимальному значению
типа unsigned int. */
//	Конструктор:							Описание:
string (const char * s)				/* Инициализирует объект string строкой, 
									завершающейся нулевым байтом, которая указана в 's'. */
string (size_type n, char c)			/* Создает объект типа string из 'n' элементов, 
									каждый из которых инициализируется символом 'c'. */
string(const string & str)			/* Инициализирует объект string объектом str типа
									string (конструктор копирования). */
string()							/* Создает объект типа string нулевого размера 
									(конструктор по умолчанию). */
string (const char *s, size_type n)	/* Инициализирует объект типа string строкой, завершающейся
									нулевым байтом, которая указана в 's' и содержит 'n' символов,
									даже если 'n' превышает длину 's'. */
template<class Iter>				// Инициализирует объект типа string значениями в
string(Iter begin, Iter end)			/* диапазоне [begin, end), причем begin и end служат указателями 
									начала и конца диапазона. Диапазон начинается с позиции begin 
									включительно и заканчивается позицией end, не включая её.*/
string(const string & str, size_type pos, size_type n = npos) /* Инициализирует объект типа string
									объектом str, начиная с позиции pos и оканчивая концом str
									либо ограничиваясь 'n' символами, в зависимости от того, какое
									условие будет удовлетворено раньше. */
string(string && str) noexcept		/* (C++11). Инициализирует объект string объектом str типа
									string. Объект str может быть изменен (конструктор переноса). */
string(initializer_list<char> il)	/* (C++11). Инициализирует объект типа string символами,
									указанными в списке инициализации il. */
#include <iostream>		// str1.cpp -- введение в класс string
#include <string>
// Использование различных конструкторов класса string
int main()
{
    using namespace std;
    string one("Lottery Winner!");				// ctor #1
/* Инициализация объекта string обычной строкой в стиле 'С' и её вывод на экран с помощью 
перегруженной операции<< */
    cout << "one: " << one << endl;				// overloaded '<<'
    string two(20, '$');							// ctor #2
// Инициализирует объект two типа string строкой, состоящей из 20 символов '$'
    cout << "two: " << two << endl;
    string three(one);							// ctor #3
// Конструктор копирования инициализирует объект three типа string объектом one этого же типа
    cout << "three: " << three << endl;
// Перегруженная операция '+=' дописывает строку " Oops!" к строке one:
    one += " Oops!";								// overloaded '+='
/* Операция '+=' имеет несколько перегрузок и с ее помощью можно добавлять как 
объекты string, так и отдельные символы. */
    cout << "one: " << one << endl;
/* Операция '=' тоже является перегружаемой, что позволяет присвоить объекту типа string другой
объект этого же типа, строку в стиле 'C' или простое значение типа char. */
    two = "Sorry! That was ";
/* Перегрузка операции [], позволяет обращаться к отдельным символам объекта типа string,
используя нотацию массива: */
    three[0] = 'P';
// Конструктор по умолчанию создает пустую строку, которой в последствии может быть присвоено значение:
    string four;								// ctor #4
/* Операция '+' используется для создания временного объекта string, который затем с помощью
перегруженной операции '=' присваивается объекту four: */ 
    four = two + three;							// overloaded '+', '='
/* Операция '+' объединяет два операнда в один объект типа string. Эта операция имеет несколько
перегрузок, поэтому второй операнд может быть объектом типа string, строкой в стиле 'C' или
значением типа char. */
    cout << "four: " << four << endl;
    char alls[] = "All's well that ends well";
/* Конструктор принимает в качестве аргументов строку в стиле 'C' и 
целочисленное значение, которое указывает количество копируемых символов: */
    string five(alls, 20);						// ctor #5
/* Если количество символов превышает длину строки в стиле 'C', запрошенное количество символов
все равно копируется. Поэтому замена значения 20 значением 40 в приведенном примере привела бы
к копированию в конец строки five пятнадцати бессмысленных символов. */
    cout << "five: " << five << "!\n";
// Использует шаблон template<class Iter> string(Iter begin, Iter end); в качестве аргумента:
    string six(alls + 6, alls + 10);				// ctor #6
/* begin и end выступают в роли указателей на начало и конец диапазона памяти. Конструктор применяет
значения элементов памяти, хранящиеся между позициями, указанными аргументами begin и end, для 
инициализации создаваемого им объекта типа string. Запись [begin, end), заимствованная из математики,
означает, что диапазон включает в себя begin, но не включает end. end указывает на позицию, следующую
за последним значением, которое должно быть использовано. Поскольку имя массива является указателем,
значения alls + 6 и alls + 10 будут иметь тип char *, и поэтому в шаблоне тип Iter заменяется типом char* .*/
    cout << "six: " << six  << ", ";
/* Следующий код работать не будет: string seven(five + 6, five + 10);
Причина в том, что имя объекта, в отличие от имени массива, не является адресом объекта. Следовательно,
five — не указатель, и выражение fіѵе + 6 не имеет смысла. Однако five[6] является значением типа char,
поэтому выражение &five[6] — это адрес, который может использоваться в качестве аргумента конструктора: */
    string seven(&five[6], &five[10]);			// ctor #6 again
    cout << "seven: " << seven << "...\n";
/* Копирует 16 символов из объекта four в объект eight, начиная с
седьмой позиции (восьмого символа) объекта four: */
    string eight(four, 7, 16);					// ctor #7
    cout << "eight: " << eight << " in motion!" << endl;
    return 0; 
}
/* ctor — стандартная аббревиатура конструктора в C++).
  Конструкторы C++11. */
string(string && str) noexcept /* подобен конструктору копирования
в том смысле, что новый объект string является копией объекта str. Однако, в 
отличие от конструктора копии, он не гарантирует, что объект str будет 
трактоваться как const. Эту форму конструктора называют конструктором переноса.
В некоторых ситуациях компилятор может использовать его вместо конструктора
копирования для оптимизации производительности.
 Конструктор string (initializer_list<char> il) обеспечивает возможность
списковой инициализации класса string: */
string piano_man = { 'L', 'i', 's', 'z', 't'};
string comp_lang {'L', 'i', 's', 'p'};
/*  Ввод для класса string.
 Для строк в стиле 'C' существуют три варианта ввода данных: */
char info[100];
cin >> info;				// чтение слова
cin.getline(infо, 100);	// чтение строки с отбрасыванием символа '\n'
cin.get(info, 100);		// чтение строки с сохранением символа '\n' в очереди
// Для объектов string доступны два варианта:
string stuff;
cin >> stuff;			// чтение слова
getline(cin, stuff);		// чтение строки с отбрасыванием символа '\n'
/* Обе версии вызова функции getline() допускают использование необязательного
аргумента — символа, завершающего ввод: */
cin.getline(info, 100, ':'); // чтение до символа ':', ':' отбрасывается
getline(stuff, ':');			// чтение до символа ':', ':' отбрасывается
/* Основное различие состоит в том, что версии с использованием string 
автоматически изменяют размер целевого объекта string в соответствии с
количеством вводимых символов: */
char fname[10];
string lname;
cin >> fname;			// возможно возникновение проблем,
						// если вводится больше 9-ти символов
cin >> lname;			// можно читать очень длинные строки
cin.getline(fname, 10);	// вводимая строка может быть усечена
getline(cin, fname);		// никакого усечения не выполняется
/* Функция автоматического определения размера позволяет версии getline(), 
использующей объект string, отказаться от параметра, который ограничивает 
количество вводимых символов. Конструктивное различие состоит в том, 
что средствами ввода строк в стиле 'C' являются методы класса istream, а 
средствами версий с объектами string — автономные функции. Именно поэтому 
cin является вызывающим объектом для ввода строки в стиле 'C' и аргументом 
функции для объекта ввода string. Это относится и к форме '>>', что явно 
видно при записи кода в виде вызова функций: */
cin.operator>>(fname);	// метод класса ostream
operator>>(cin, lname);	// обычный вызов функции
/* Существует несколько ограничений на длину строки. Первый ограничивающий 
фактор — максимально допустимая длина строки, задаваемая константой string::npos.
Обычно она равна максимальному значению типа unsigned int, и на практике этого
хватает для обычного интерактивного ввода. Однако проблемы могут возникнуть 
при попытке считывания содержимого всего файла в один объект типа string. 
Второй ограничивающий фактор — размер памяти, доступной программе.
 Функция getline(), применяемая к классу string, будет читать данные из 
входного потока и сохранять их в объекте string до тех пор, пока не произойдет
одно из трех событий:
• Будет достигнут конец файла. В этом случае во входном потоке будет установлен
флаг 'eofbit' и обе функции fail() и eof() возвратят значение true.
• Будет достигнут разделительный символ ('\n' по умолчанию). Этот символ 
удаляется из входного потока, но не сохраняется.
• Будет прочитано максимально возможное количество символов (меньшее из
значений константы string::npos и доступного количества байтов памяти).
В этом случае во входном потоке будет установлен флаг failbit и функция
fail() возвратит значение true.
  В объекте, обеспечивающем работу с входным потоком, имеется система учета
для отслеживания ошибок при работе с потоком. В этой системе установленный флаг
eofbit означает достижение конца файла, failbit — ошибку при чтении из потока,
badbit — нераспознанный, например аппаратный, сбой и goodbit — нормальную 
работу без ошибок.
 Функция operator>>() для класса string ведет себя аналогичным образом, за
исключением того, что вместо чтения вплоть до разделительного символа и его 
отбрасывания она считывает данные из потока до тех пор, пока не встретится символ
пробела, и оставляет его в очереди ввода. Символом пробела является собственно
пробел, символ новой строки или символ табуляции, либо в более общем случае —
любой символ, для которого функция isspace() возвращает значение true.
Поскольку функции ввода для объектов string работают с потоками и распознают 
конец файла, их можно применять для ввода из файла. */
#include <iostream>			// strfile.cpp -- чтение строк из файла
#include <fstream>
#include <string>
#include <cstdlib>
int main()
{
     using namespace std;
      ifstream fin;
      fin.open("D:\\repos\\visual\\code\\Prata\\16\\string\\tobuy.txt");
      if (fin.is_open() == false)
      {
        cerr << "Can't open file. Bye.\n";		// не удается открыть файл
        exit(EXIT_FAILURE);
      }
      string item;
      int count = 0;
      getline(fin, item, ':');
      while(fin)								// до тех пор, пока нет ошибок ввода
      {
        ++count;
        cout << count << ": " << item << endl;	// нумерует строки и выводит их на экран
        getline(fin, item, ':');     
      }
      cout << "Done\n";
      fin.close();
      return 0;
}
/* При использовании символа ':' в качестве разделителя символ перевода строки стал 
просто еще одним обычным символом. Поэтому символ перевода строки в конце первой 
строки файла стал первым символом строки, которая начинается со слов "cottage cheese".
Аналогично символ перевода строки в конце второй строки ввода, если он присутствует, 
становится единственным элементом девятой строки.
  Работа со строками.
 Строки можно сравнивать. Все шесть операций отношения перегружены для объектов 
string, причем один объект будет считаться меньше другого, если он находится
раньше в машинной последовательности сопоставления. Если в основе последовательности 
сопоставления лежит код ASCII, то цифры будут считаться меньше прописных символов, 
а прописные символы — меньше строчных. Каждая операция отношения имеет три 
перегрузки, так что можно сравнивать объект string с другим объектом string, 
объект string со строкой в стиле 'C' и строку в стиле 'C' с объектом string: */
string snake1("cobra");
string snake2("coral");
char snake3[20] = "anaconda";
if (snake1 < snake 2) // operator<(const string &,  const string &)
if (snake1 == snake3) // operator==(const string &, const char *)
if (snake3 != snake2) // operator!=(const char *,   const string &)
/* Существуют две функции-члена класса string для определения размера строки —
size() и length(), которые возвращают количество символов в строке: */
if (snake1.length() == snake2.size())
	cout << "Both strings have the same length.\n"; // Строки имеют одинаковую длину
/* Функция length() пришла из ранних версий класса string, a size() добавлена для 
совместимости с STL.
 Поиск подстроки или символа в строке можно провести несколькими способами: */
// Прототип метода:						Описание:
size_type find(const string & str,		// Ищет в вызывающей строке первое вхождение
		size_type pos = 0) const			/* подстроки str, начиная с позиции pos. Возвращает
										индекс первого символа найденной подстроки или
										string::npos, если подстрока не найдена. */
size_type find(const char * s,			// Ищет в вызывающей строке первое вхождения
		size_type pos = 0) const			/* подстроки 's', начиная с позиции pos. Возвращает
										индекс первого символа найденной подстроки или
										string::npos, если подстрока не найдена. */
size_type find(const char * s,			// Ищет в вызывающей строке первое вхождение 
		size_type pos = 0, size_type n)	/* подстроки, состоящей из первых 'n' символов строки
										's', начиная с позиции pos. Возвращает индекс первого
										символа найденной подстроки или string::npos,
										если подстрока не найдена. */
size_type find(char ch,					// Ищет в исходной строке первое вхождение 
		size_type pos = 0) const			/* символа 'ch', начиная с позиции pos. Возвращает 
										индекс первого символа найденной подстроки или
										string::npos, если подстрока не найдена. */
/* Библиотека string также предоставляет связанные методы rfind(), find_first_of(),
find_last_of(), find_first_not_of() и find_last_not_of(), каждый из которых имеет 
тот же набор сигнатур перегруженных функций, что и метод find().
Метод rfind() находит последнее вхождение подстроки или символа.
Метод find_first_of() отыскивает первое вхождение в строке любого из 
символов, переданных в аргументах метода. Например, следующий оператор вернет 
позицию символа 'r' в строке "cobra" (3), поскольку это первое вхождение любого из
символов строки "hark" в строке "cobra": */
int where = snake1.find_first_of("hark");
/* Метод find_last_of() работает аналогично, только находит последнее вхождение.
Поэтому следующий оператор вернет позицию символа 'а' в строке "cobra": */
int where = snake1.last_first_of("hark");
/* Метод find_first_not_of() находит первый символ в вызывающей строке, 
который отличается от символа, переданного в аргументе. Таким образом, приведенный ниже
оператор вернет позицию символа 'c' в cobra, поскольку символ 'c' не найден в hark: */
int where = snake1.find_first_not_of("hark");
// hangman.cpp -- использование некоторых методов работы со строками
#include <iostream>
#include <string>
#include <cstdlib>
#include <ctime>
#include <cctype>
using std::string;
const int NUM = 26;
const string wordlist[NUM] = {"apiary", "beetle", "cereal",
    "danger", "ensign", "florid", "garage", "health", "insult",
    "jackal", "keeper", "loaner", "manage", "nonce", "onset",
    "plaid", "quilt", "remote", "stolid", "train", "useful",
    "valid", "whence", "xenon", "yearn", "zippy"};
int main()
{
    using std::cout;
    using std::cin;
    using std::tolower;
    using std::endl;
    
    std::srand(std::time(0));
    char play;
    cout << "Will you play a word game? <y/n> ";            // запуск игры в слова
    cin >> play;
    play = tolower(play);
    while (play == 'y')
    {
        string target = wordlist[std::rand() % NUM];
        int length = target.length();
        string attempt(length, '-');
        string badchars;
        int guesses = 6;
        cout << "Guess my secret word. It has "  << length
             << " letters, and you guess\n"
             << "one letter at a time. You get " << guesses
             << " wrong guesses.\n";
        cout << "Your word: " << attempt << endl;           // вывод слова
    // перегрузка операций отношения позволяет работать со строками так же,
        while (guesses > 0 && attempt != target) // как с числовыми переменными
        {
            char letter;
            cout << "Guess a letter: ";
            cin >> letter;
    /* find() для проверки на повторное использование символа; если символ уже вводился, 
    то он будет присутствовать либо в строке badchars (неудачные попытки), либо в строке 
    attempt (удачные попытки): */
            if (badchars.find(letter) != string::npos
                || attempt.find(letter) != string::npos)
            {
                cout << "You already guessed that. Try again.\n";
                continue;
            }
            int loc = target.find(letter);  // проверка на наличие введенного символа в загаданном слове
            if (loc == string::npos) // если достиг максимума size_t, значит введенной буквы нет в слове
            {
                cout << "Oh, bad guess!\n";
                --guesses;
                badchars += letter;                         // добавить к строке
            }
            else
            { // Если переменная loc имеет допустимое значение, буква может быть помещена в
                cout << "Good guess!\n";		// соответствующую позицию строки ответа:
                attempt[loc] = letter;
                // Проверить, не появляется ли буква еще раз
                loc = target.find(letter, loc + 1); // Поскольку буква была найдена в позиции
                while (loc != string::npos)   // loc, следующий поиск должен начаться с позиции loc + 1
                {
                    attempt[loc] = letter;
                    loc = target.find(letter, loc + 1);
                }
           }
            cout << "Your word: " << attempt << endl;
            if (attempt != target)
            {
                if (badchars.length() > 0)
                    cout << "Bad choices: " << badchars << endl;
                cout << guesses << " bad guesses left\n";
            }
        }
        if (guesses > 0)
            cout << "That's right!\n";
        else
            cout << "Sorry, the word is " << target << ".\n";
        cout << "Will you play another? <y/n> ";
        cin  >> play;
        play = tolower(play);
    }
    cout << "Bye\n";
    return 0; 
}
/*  Другие возможности, предлагаемые классом string.
 Что происходит, когда программа дописывает букву в конец строки? Она не может просто
увеличить размер строки, поскольку это может привести к использованию соседних 
областей памяти, которые уже заняты. Поэтому нужно выделить новый блок памяти и 
скопировать туда старое содержимое строки. Частое повторение такой процедуры 
приводило бы к снижению производительности, поэтому большинство реализаций C++ 
выделяют для строки блок памяти больший, чем фактическая строка, обеспечивая 
возможность ее увеличения. Когда со временем размер строки превышает размер 
этого блока, программа выделяет новый блок, вдвое больше текущего, обеспечивая 
дополнительное свободное место без постоянного изменения размера. Метод capacity()
возвращает размер текущего блока, а метод reserve() позволяет запросить минимальный 
размер для блока. */
#include <iostream>		// str2.cpp -- использование методов capacity() и reserve()
#include <string>
int main()
{
    using namespace std;
    string empty;
    string small = "bit";
    string larger = "Elephants are a girl's best friend";
    cout << "Sizes:\n";
    cout << "\tempty: "  << empty.size()      << endl;
    cout << "\tsmall: "  << small.size()      << endl;
    cout << "\tlarger: " << larger.size()     << endl;
    cout << "Capacities:\n";
    cout << "\tempty: "  << empty.capacity()  << endl;
    cout << "\tsmall: "  << small.capacity()  << endl;
    cout << "\tlarger: " << larger.capacity() << endl;
    empty.reserve(50);
    cout << "Capacity after empty.reserve(50): " << empty.capacity() << endl;
    return 0;
}
/* Для строки резервируется минимум 15 символов и стандартный шаг увеличения 
размера на единицу меньше значений, кратных 16.
 Если имеется объект string, а нужна строка в стиле 'C'? Например, может 
требоваться открыть файл, имя которого хранится в объекте string: */
string filename;
cout << "Enter file name: ";
cin >> filename;
ofstream fout;
/* Метод open() требует в качестве аргумента строку в стиле 'C'. Однако существует 
метод c_str(), который возвращает указатель на строку в стиле 'C' с тем же содержимым,
что и у вызывающего объекта string. Поэтому можно использовать следующий оператор: */
fout.open(filename.c_str());
/*  Разновидности строк.
 В действительности, в основе библиотеки string лежит шаблонный класс: */
template< class charT, class traits = char _traits<charT>, class Allocator = allocator<charT> >
basic_string {...};
/* Существуют четыре разновидности шаблона basic_string, каждая из которых
имеет имя typedef: */
typedef basic_string<char>		string;
typedef basic_string<wchar_t>	wstring;
typedef basic_string<char16_t>	u16string;	// C++11
typedef basic_string<char32_t>	u32string;	// C++11
/* Это позволяет использовать строки на основе типов wchar_t, char16_t и
char32_t, а также строки на базе char. Более того, можно разработать свой класс
на основе символьных типов и применять шаблон класса basic_string при условии,
что новый класс удовлетворяет определенным требованиям. Класс traits описывает
определенные аспекты выбранного символьного типа, например, способы сравнения
значений. Существуют заранее определенные разновидности шаблона char_traits
для типов char, wchar_t, char16_t и char32_t, и они служат значениями по 
умолчанию для класса traits. Класс Allocator предназначен для управления памятью.
Доступны предварительно определенные разновидности шаблона allocator для 
различных типов символов, которые являются значениями по умолчанию. Они 
используют операции new и delete.
	Классы шаблонов интеллектуальных указателей.
 Интеллектуальный указатель (smart pointer) — это объект класса, который 
действует подобно указателю, но обладает дополнительными возможностями. */
void remodel(std::string & str)
{
	std::string * ps = new std::string(str);
	...
	str = ps;
	return;
}
/* При каждом вызове функции программа выделяет память из кучи, однако никогда 
не освобождает память, что приводит к утечкам памяти. Решение проблемы известно —
нужно лишь не забыть об освобождении памяти, т.е. добавить перед оператором return: */
delete ps;
/* Иногда об этом забывают. Или помнят, но случайно удаляют или комментируют 
эту строку кода. И даже когда об этом помнят, могут возникать проблемы: */
void remodel(std::string & str)
{
	std::string * ps = new std::string(str);
	...
	if (weird_thing())
		throw exception ();
	str = *ps;
	delete ps;
	return;
}
/* При возникновении исключения до операции delete дело не доходит, и это снова
приводит к утечке памяти.
  Использование интеллектуальных указателей.
 auto_ptr, unique_ptr и shared_ptr определяют подобный указателю объект, которому 
присваивается адрес области памяти, полученный (прямо или косвенно) операцией new.
Когда срок существования интеллектуального указателя истекает, его деструктор 
использует операция delete для освобождения памяти. Таким образом, присваивая 
адрес, возвращенный операцией new, одному из этих объектов, не нужно беспокоиться
об освобождении памяти впоследствии; она будет освобождена автоматически при
удалении объекта интеллектуального указателя. Чтобы создать один из объектов
интеллектуальных указателей, потребуется включить заголовочный файл <memory>, 
который содержит определения шаблонов. Затем с помощью обычного синтаксиса шаблона
создается необходимая разновидность указателя. Например, шаблон auto_ptr содержит 
следующий конструктор: */
template<class X> class auto_ptr
{
public:
	explicit auto_ptr(X * p = 0) throw();
	...
};
/* Нотация throw() означает, что конструктор не должен генерировать исключения.
Как и auto_ptr, она считается устаревшей. Таким образом, запрашивая объект
auto_ptr типа 'X', мы получаем объект auto_ptr, который указывает на значение типа 'X': */
auto_ptr<double> pd(new double);		// pd — объект auto_ptr, указывающий на значение
									// типа double (используется вместо double * pd)
auto_ptr<string> ps(new string);		// ps — объект auto_ptr, указывающий на значение
									// типа string (используется вместо string * ps)
/* new double — это указатель (возвращенный операцией new) на новый выделенный
участок памяти. Он используется в качестве аргумента при вызове конструктора 
auto_ptr<double>, т.е. является фактическим аргументом, соответствующим 
формальному параметру 'p' в прототипе класса. Аналогично, new string также 
является фактическим аргументом конструктора. Остальные два интеллектуальных 
указателя используют тот же самый синтаксис: */
unique_ptr<double> pdu(new double);	// pdu — объект unique_ptr, указывающий на double
shared_ptr<string> pss(new string);	// pss — объект shared_ptr, указывающий на string
/* Таким образом, чтобы преобразовать функцию remodel(), понадобится
выполнить следующие три шага.
1. Включить заголовочный файл memory.
2. Заменить указатель на string объектом интеллектуального указателя, который
указывает на string.
3. Удалить обращение к операции delete. */
#include <memory>
void remodel(std::string & str)
{
	std::auto_ptr<std::string> ps(new std::string(str));
	if (weird_thing())
		throw exception();
	str = *ps;
	// delete ps; ЭТОТ ОПЕРАТОР БОЛЬШЕ НЕ НУЖЕН
	return;
}
// Интеллектуальные указатели принадлежат пространству имен std.
#include <iostream>	// smrtptrs.cpp -- использование трех видов интеллектуальных указателей
#include <string>
#include <memory>
class Report
{
private:
    std::string str;
public:
    Report(const std::string s) : str(s) { std::cout << "Object created!\n"; }
    ~Report() { std::cout << "Object deleted!\n"; }
    void comment() const { std::cout << str << "\n"; }
};
int main()
{
    {
        std::auto_ptr<Report>   ps (new Report("using auto_ptr"));
        ps->comment();   // использование операции -> для вызова функции-члена
    }
    {
        std::shared_ptr<Report> ps (new Report("using shared_ptr"));
        ps->comment();
    }
    {
        std::unique_ptr<Report> ps (new Report("using unique_ptr"));
        ps->comment();
    }
    return 0;
}
/* Каждый из этих классов имеет конструктор explicit, который принимает 
указатель в качестве аргумента. Поэтому автоматическое преобразование типов
из указателя в объект интеллектуального указателя не выполняется: */
shared_ptr<double> pd;
double * p_reg = new double;
pd = p_reg;							// недопустимо (неявное преобразование)
pd = shared_ptr<double>(p_reg);		// допустимо (явное преобразование)
shared_ptr<double> pshared = p_reg;	// недопустимо (неявное преобразование)
shared_ptr<double> pshared(p_reg);	// допустимо (явное преобразование)
/* Объект интеллектуального указателя работает подобно обычному указателю. 
Например, если ps — объект интеллектуального указателя, его можно разыменовывать -
*ps и использовать для получения доступа к членам структуры (ps->puffIndex)
и присваивать регулярному указателю, который указывает на тот же тип. Один объект
интеллектуального указателя можно также присвоить другому того же типа, но при
этом возникают проблемы. Ситуация, "которой следует избегать при использовании 
всех трех названных интеллектуальных указателя: */
string vacation("I wandered lonely as a cloud.");
shared_ptr<string> pvac(&vacation);	// ТАК ДЕЛАТЬ НЕЛЬЗЯ!
/* При удалении объекта 'рѵас' программа применила бы операцию delete к памяти
не из кучи, что совершенно неприемлемо.
  Соображения по поводу интеллектуальных указателей.
 Почему отказались от указателя auto_ptr? */
auto_ptr<string> ps(new string("I reigned lonely as a cloud."));
auto_ptr<string> vocation;
vocation = ps;
/* Каким должен быть результат этого оператора присваивания? Если бы 'ps' и
'vocation' были обычными указателями, результатом стали бы два указателя на один
и тот же объект string. В данном случае это недопустимо, поскольку программа вела
бы себя непредсказуемо, пытаясь удалить один объект дважды — при удалении 'ps' и
при удалении 'vocation'. Существуют следующие способы предотвращения этой проблемы:
• Определить операцию присваивания так, чтобы она создавала точную копию
объекта. Тогда два указателя будут указывать на два разных объекта, один из 
которых является копией второго.
• Использовать концепцию владения, когда определенным объектом может владеть
только один интеллектуальный указатель. Деструктор будет удалять объект 
только тогда, когда интеллектуальный указатель владеет объектом. Затем можно 
использовать операцию присваивания, которая будет передавать право владения
объектом. Эта стратегия применяется указателями auto_ptr и unique_ptr, но
unique_ptr накладывает несколько больше ограничений.
• Создать еще более интеллектуальный указатель, который будет отслеживать,
сколько интеллектуальных указателей ссылается на определенный объект. Эта
стратегия называется подсчетом ссылок. Например, присваивание могло бы 
увеличивать значение счетчика на единицу, а удаление указателя — уменьшать его.
Тогда операция delete вызвалась бы только при удалении последнего
указателя. Эта стратегия применяется для указателя shared_ptr.
 Те же самые стратегии применимы и к конструкторам копирования. */
#include <string>		// fowl.cpp  -- неудачный выбор
#include <memory>
#include <iostream>
int main()
{
    using namespace std;
    std::auto_ptr<string> films[5] =
    {
        std::auto_ptr<string> (new string("Fowl Balls")),
        std::auto_ptr<string> (new string("Duck Walks")),
        std::auto_ptr<string> (new string("Chicken Runs")),
        std::auto_ptr<string> (new string("Turkey Errors")),
        std::auto_ptr<string> (new string("Goose Eggs"))
    };
    std::auto_ptr<string> pwin;
    pwin = films[2];							// films[2] утрачивает права владения
    std::cout << "The nominees for best avian baseball film are\n";
    for (int i = 0; i < 5; i++)
        std::cout << *films[i] << std::endl; // цикл доходит до films[2] и программа падает
    std::cout << "The winner is " << *pwin << "!\n";
    return 0;
}
// Вывод:
The nominees for best avian baseball film are
Fowl Balls
Duck Walks
Segmentation fault(core dumped).
/* Проблема заключается в том, что следующий оператор передает права владения 
от films[2] к pwin: */
pwin = films[2];		// films[2] утрачивает права владения
/* Это ведет к тому, что элемент массива films[2] перестает ссылаться на строку.
После того, как auto_ptr передает права владения объектом, он больше не 
предоставляет доступ к этому объекту. Когда программа приступает к выводу строки, 
указанной элементом films[2], она обнаруживает нулевой указатель, что, несомненно, 
оказывается неприятным сюрпризом. Если вместо auto_ptr использовали shared_ptr,
программа выполнится успешно и даст следующий вывод: */
The nominees, for best avian baseball film are
Fowl Balls
Duck Walks
Chicken Runs
Turkey Errors
Goose Eggs
The winner is Chicken Runs!
// Различие состоит в следующей части программы:
shared_ptr<string> pwin;
pwin = films[2];
/* На этот раз и 'pwin', и films[2] указывают на один и тот же объект, а значение 
счетчика ссылок увеличивается с '1' до '2'. В конце программы объект 'pwin', который был
объявлен последним, оказывается первым, чей деструктор будет вызван. Деструктор
уменьшает значение счетчика ссылок до '1'. Затем элементы массива shared_ptrs 
освобождаются. Деструктор films[2] уменьшает значение счетчика до '0' и освобождает
ранее выделенную память. Это же относится к shared_ptr. Программа из листинга 
выполнится успешно. При использовании auto_ptr происходит ошибка времени выполнения.
 А что происходит в случае применения unique_ptr? Как и auto-ptr, unique_ptr 
использует модель владения. Однако вместо сбоя версия с unique_ptr генерирует ошибку
во время компиляции следующей строки кода: */
pwin = films[2];
//  Почему uniqae_ptr предпочтительней auto_ptr.
auto_ptr<string> p1(new string("auto"));	//#1
auto_ptr<string> p2;						//#2
p2 = p1;								//#3
/* Когда в операторе #3 указатель 'p2' получает права владения объектом string, 
указатель 'р1' лишается этих прав. Это хорошо, поскольку препятствует попыткам дест-
рукторов обоих объектов 'p1' и 'p2' удалить один и тот же объект. Но это же и плохо,
если впоследствии программа пытается использовать 'p1', т.к. 'p1' больше не указывает
на соответствующие данные. Теперь рассмотрим эквивалентную программу, в которой
применяется unique_ptr: */
unique_ptr<string> р3(new string("auto"));	//#4
unique_ptr<string> p4;						//#5
p4 = p3;									//#6
/* В этом случае компилятор не разрешает выполнение оператора #6, и мы избегаем
проблемы, связанной с тем, что 'p3' не указывает на соответствующие данные. Таким
образом, unique_ptr безопаснее auto_ptr (поскольку вызывает ошибку времени 
компиляции, а не приводит к сбою программы). В некоторых случаях присваивание 
одного интеллектуального указателя другому не устраняет потенциальные проблемы. */
unique_ptr<string> demo(const char * s)		// принимает строку и возвращает объект unique_ptr
{
	unique_ptr<string> temp(new string(s));	// конструирует временный объект
	return temp;							// возвращает временный объект unique_ptr
}
// Также представим, что используется такой код:
unique_ptr<string> ps;
ps = demo("Uniquely special");
/* В этом примере функция demo() возвращает временный объект unique_ptr, а 
затем 'ps' принимает права владения объектом, первоначально принадлежавшего 
возвращенному объекту unique_ptr. После этого возвращенный объект unique_ptr 
уничтожается. Это нормально, поскольку теперь объект ps владеет объектом string.
При этом имеет место еще один положительный нюанс. Поскольку временный объект
unique_ptr, возвращенный функцией demo(), вскоре уничтожается, отсутствует 
какая-либо возможность его неправильного использования для доступа к недопустимым
данным. В данном случае нет никакой причины запрещать присваивание. И, как не 
удивительно, компилятор его разрешает! Если программа пытается присвоить один 
объект unique_ptr другому, компилятор не препятствует этому, когда исходный 
объект является временным значением, и запрещает это, когда исходный объект 
существует некоторое время: */
using namespace std;
unique_ptr<string> pu1(new string "Hi ho!");
unique_ptr<string> pu2;
pu2 = pu1;									// #1 не разрешено
unique_ptr<string> pu3;
pu3 = unique_ptr<string>(new string "Yo!");	// #2 разрешено
/* Оператор присваивания #1 оставил бы висячий объект unique_ptr (объект 'pu1') —
возможный источник ошибки. Оператор присваивания #2 не оставляет за собой 
никакого объекта unique_ptr, поскольку он вызывает конструктор unique_ptr, 
создающий временный объект, уничтожаемый при передаче прав владения объекту риЗ.
Это избирательное поведение — одна из причин того, что шаблон unique_ptr 
предпочтительнее auto_ptr, который допускал бы обе формы присваивания. По этой же 
причине использование объектов auto_ptr в контейнерных объектах запрещается 
(рекомендацией, но не компилятором), в то время как применение объектов unique_ptr
разрешено. Если алгоритм контейнера пытается выполнить с содержимым контейнера 
unique_ptr что-либо аналогичное строкам присваивания #1, это ведет к ошибке
времени компиляции. Если же алгоритм пытается выполнить что-то вроде присваивания
#2, то все проходит нормально, и выполнение программы продолжается. При
использовании объектов auto_ptr действия, подобные присваиванию #1, могли бы
вести к непрогнозируемому поведению и непонятным сбоям программы.
 В определенных ситуациях действительно может требоваться выполнение действий,
подобных присваиванию #1. Присваивание небезопасно только при неинтеллектуальном 
использовании отброшенного интеллектуального указателя, например, при его 
разыменовании. Но указатель можно безопасно использовать, присвоив ему новое 
значение. В C++ имеется стандартная библиотечная функция std::move(), которая 
позволяет присваивать один объект unique_ptr другому. */
std::unique_ptr<std::string> ps1, ps2;
ps1 = demo("Uniquely special");
ps2 = std::move(ps1);	// делает возможным присваивание (перемещающее присваивание &&)
ps1 = demo(" and more");
std::cout << *ps2 << *ps1 << std::endl;
Вывод: Uniquely special and more
/* Может возникать вопрос, каким образом unique_ptr, в отличие от auto_ptr, 
способен различить безопасное и потенциально опасное использование. Ответ 
заключается в том, что он использует дополнения конструкторов переноса и 
ссылок rvalue из С++11. unique_ptr обладает еще одним преимуществом по сравнению
с auto_ptr. Он имеет вариант, который можно использовать с массивами. Операция 
delete применяется только в паре с new, a delete[] — только в паре с new[].
Шаблон auto_ptr использует операцию delete, а не delete[], поэтому может 
применяться только с new, но не с new[]. Однако unique_ptr имеет версию
для пары new[] и delete[]: */
std::unique_ptr< double[] > pda(new double(5)); // будет использовать delete[]
/* Объект auto_ptr или shared_ptr должен использоваться только для памяти, 
выделенной операцией new. Память, выделенная с помощью new[], не подходит. 
Нельзя применять auto_ptr, shared_ptr или unique_ptr для памяти, выделенной 
посредством операции new либо, в случае unique_ptr, с помощью new или new[].
  Выбор интеллектуального указателя.
 Если в программе требуется более одного указателя на объект, необходимо 
выбрать shared_ptr. Например, может существовать массив указателей, а несколько
вспомогательных указателей применяться для идентификации определенных элементов,
таких как максимальный и минимальный. Или же возможно наличие двух видов объектов,
которые содержат указатели на один и тот же третий объект. Либо можно располагать
контейнером указателей из STL. Многие алгоритмы STL включают в себя операции 
копирования или присваивания, которые будут работать с объектом shared_ptr, но не
с unique_ptr (компилятор будет выводить предупреждение) либо auto_ptr (это будет
приводить к непредсказуемому поведению). Если компилятор не разрешает применять 
shared_ptr, можно получить версию из библиотеки BOOST.
 Если программа не нуждается в нескольких указателях на один и тот же объект,
unique_ptr работает вполне успешно. Это хороший вариант для возвращаемого типа
функции, которая возвращает указатель на память, выделенную операцией new. В 
результате права владения передаются объекту unique_ptr, которому присвоено 
возвращаемое значение, и интеллектуальный указатель принимает на себя ответственность
за вызов операции delete. Объекты unique_ptr можно сохранять в контейнере STL,
если только не требуется вызывать методы или алгоритмы, такие как sort(), которые
копируют или присваивают один объект unique_ptr другому. Например, при условии
наличия соответствующих операторов include и using, в программе можно было бы
использовать фрагменты кода вроде показанных ниже: */
unique_ptr<int> make_int(int n)
{
	return unique_ptr<int>(new int(n));
}
void show (unique_ptr<int> & pi)		// передача по ссылке
{
	cout << *pi << ' ';
}
int main()
{	...
	vector< unique_ptr<int> > vp(size);
	for (int i = 0; i < vp.size(); i++)
		vp[i] =  make_int(rand() % 1000); // копирование временного unique_ptr
	vp.push_back(make_int(rand() % 1000)) // номально, поскольку аргумент является временным
	for_each(vp.begin(), vp.end(), show); // использование for_each()
	...
}
/* Вызов функции push_back() работает, поскольку он передает временный объект
unique_ptr, который должен быть присвоен объекту unique_ptr в 'ѵр'.
Обратите внимание, что оператор for_each() приводил бы к ошибке, если бы функция
show() передавала объект по значению, а не посредством ссылки, поскольку в этом
случае было бы необходимо инициализировать 'рі' значением unique_ptr из 'ѵр', не
являющимся временным, что недопустимо. Как уже упоминалось, компилятор будет
перехватывать попытки неправильного использования объекта unique_ptr.
 Объект unique_ptr можно присваивать объекту shared_ptr при соблюдении тех
же условий, при которых один объект unique_ptr допускается присваивать другому —
источником должно быть rvalue. Как и ранее, в следующем коде make_int() 
представляет собой функцию, возвращаемым типом которой является unique_ptr<int>: */
unique_ptr<int> pup(make_int(rand() % 1000);	// нормально
shared_ptr<int> spp(pup);					// недопустимо, pup — это lvalue
shared_ptr<int> spr(make_int(rand() % 1000);	// нормально
/* Шаблон shared_ptr содержит явный конструктор преобразования rvalue типа
unique_ptr в shared_ptr. При этом shared_ptr принимает права владения объектом,
первоначально принадлежавшего unique_ptr. Объект auto_ptr можно было бы 
использовать в тех же ситуациях, что и unique_ptr, но последний предпочтительнее.
Если компилятор не поддерживает unique_ptr, можно подумать о применении класса
scoped_ptr из библиотеки BOOST, который предлагает аналогичные возможности.
	Стандартная библиотека шаблонов (STL).
 STL не является примером объектно-ориентированного программирования. В ней 
используется другая идеология программирования — обобщенное программирование.
  Класс шаблона vector.
 Вектор — это набор однотипных значений, к которым можно обращаться в произвольном
порядке. То есть, например, с помощью индекса можно получить непосредственный 
доступ к десятому элементу вектора без необходимости считывания девяти предыдущих 
элементов. Это значит, что можно создать объект vector, присвоить один объект 
vector другому и применять операцию [] для доступа к отдельным элементам объекта 
vector. Чтобы сделать этот класс обобщенным, его нужно реализовать в виде класса 
шаблона. Шаблон vector использует динамическое выделение памяти, и для указания 
количества элементов вектора можно применять инициализирующий аргумент: */
#include vector
std::vector<int> ratings(5);		// вектор из 5 значений типа int
int n;
std::cin >> n;
std::vector<double> scores(n);	// вектор из 'п' значений типа double
/* После создания объекта vector перегрузка операции [] позволяет обращаться
к элементам вектора, используя обычную нотацию массивов: */
ratings[0] = 9;
for (int i = 0; i < n; i++)
	cout << scores[i] << endl;
/* Подобно классу string, различные шаблоны контейнеров STL принимают необязательный
аргумент, который указывает, какой объект-распределитель будет использоваться для
управления памятью. Например, шаблон vector начинается с таких строк: */
template < class T, class Allocator = allocator<T> >
class vector {...
/* Если опустить значение этого аргумента, шаблон контейнера по умолчанию будет 
применять класс allocator<T>. Этот класс использует операции new и delete. */
#include <iostream>			// vect1.cpp -- пример работы с шаблоном vector
#include <string>
#include <vector>
const int NUM = 2;
int main()
{
    std::vector<int> ratings(NUM);
    std::vector<std::string> titles(NUM);
    std::cout << "You will do exactly as told. You will enter\n"
              << NUM << " book titles and your ratings (0-10).\n";
    int i;
    for (i = 0; i < NUM; i++)
    {
        std::cout << "Enter title #" << i + 1 << ": ";
        std::getline(std::cin, titles[i]);
        std::cout << "Enter your rating (0-10): ";
        std::cin  >> ratings[i];
        std::cin.get();
    }
    std::cout << "Thank you. You entered the following:\n"
              << "Rating\tBook\n";
    for (i = 0; i < NUM; i++)
    {
        std::cout << ratings[i] << "\t"
                  << titles[i] << '\n';
    }
    return 0; 
}
/* Итератор - это обобщение указателя. Он может быть указателем или объектом, для 
которого определены операции над указателями, такие как разыменование (например, 
operator*()) и инкремент (например, operator++()). Обобщение указателей позволяет 
STL предоставлять однотипный интерфейс для множества классов-контейнеров, включая 
те, для которых обычные указатели не работают. В каждом классе-контейнере 
определяется соответствующий итератор. Типом этого итератора будет typedef по 
имени iterator с областью видимости класса. */
vector<double>::iterator pd;		// pd — это итератор
// Предположим, что scores — это объект vector<double>:
vector<double> scores;
// Теперь итератор 'pd' можно применять в коде, как показано ниже:
pd = scores.begin();		// обеспечение того, чтобы 'pd' указывал на первый элемент
*pd = 22.3;				// разыменование 'pd' и присваивание значения первому элементу
++pd;					// обеспечение того, чтобы pd указывал на следующий элемент
/* Итератор ведет себя подобно указателю. Автоматическое выведение типа С++11
может быть полезно еще в одной ситуации. Вместо оператора: */
vector<double>::iterator pd = scores.begin();
// можно использовать следующий оператор:
auto pd = scores.begin();	// автоматическое выведение типа С++11
/* Функция-член end() определяет позицию, следующую за последним элементом контейнера.
Если установить итератор на первый элемент контейнера и увеличивать его, то, в конце 
концов, будет достигнут элемент, следующий за последним — т.е. все содержимое 
контейнера было пройдено. Таким образом, если scores и 'pd' определены как в предыдущем 
примере, то все содержимое контейнера можно отобразить с помощью следующего кода: */
for (pd = scores.begin(); pd != scores.end(); pd++)
	cout << *pd << endl;
/* Метод push_back() — добавляет элемент в конец объекта vector. При выполнении этой
операции осуществляется дополнительное выделение памяти, и размер вектора увеличивается,
чтобы в него поместились добавляемые элементы. */
vector<double> scores;	// создание пустого вектора
double temp;
while (cin >> temp && temp >= 0)
	scores.push_back(temp);
cout << "You entered " << scores.size() << " scores.\n";
/* На каждом проходе цикла в объект scores добавляется один элемент. Во время
создания или запуска программы не нужно заботиться о количестве элементов. До тех
пор, пока у программы есть доступ к необходимому объему памяти, размер scores
будет при необходимости увеличиваться.
 Метод erase() удаляет заданный диапазон элементов вектора. В качестве аргументов 
он принимает два итератора, которые определяют границы диапазона удаляемых
элементов. Первый итератор указывает на начало диапазона, второй — на элемент, 
следующий за концом диапазона. Например, следующий код удаляет первый и второй 
элементы — те, на которые ссылаются begin() и begin() + 1: */
scores.erase(scores.begin(), scores.begin() + 2);
/* Поскольку vector предоставляет непосредственный доступ к любому элементу,
такие операции, как begin() + 2, определены для итераторов класса vector. В 
литературе по STL используется также запись вида [p1, р2), где 'p1' и 'p2' —
итераторы), описывающая диапазон, начинающийся с 'p1' и заканчивающийся, но не 
включающий, 'p2'. Таким образом, диапазон [begin(), end()) охватывает все 
содержимое коллекции. Кроме того, запись [p1, p1) определяет пустой диапазон.
Нотация [) не является частью языка C++, поэтому в коде она не используется и
присутствует только в документации.
 Метод insert() дополняет erase(). В качестве аргументов он принимает три
итератора. Первый указывает позицию, после которой будут добавляться новые 
элементы. Второй и третий итераторы описывают добавляемый диапазон. Обычно этот
диапазон является частью другого объекта контейнера. Например, следующий код
вставляет все элементы вектора new_v, за исключением первого, после первого 
элемента вектора old_v: */
vector<int> old_v;
vector<int> new_v;
old_v.insert(old_v.begin(), new_v.begin() + 1, new_v.end());
/* Кстати, здесь может пригодиться метод end(), поскольку он облегчает добавление
элементов в конец вектора. В коде ниже новые данные добавляются после позиции
old.end(), т.е. после последнего элемента вектора: */
old_v.insert(old_v.end(), new_v.begin() + 1, new_v.end());
// vect2.cpp -- методы и итераторы
#include <iostream>
#include <string>
#include <vector>
struct Review
{
    std::string title;
    int rating;
};
bool FillReview(Review & rr);
void ShowReview(const Review & rr);
int main()
{
    using std::cout;
    std::vector<Review> books;
    Review temp;
    while (FillReview(temp))
        books.push_back(temp);
    int num = books.size();
    if (num > 0)
    {
        cout << "Thank you. You entered the following:\n"
             << "Rating\tBook\n";
        for (int i = 0; i < num; i++)
            ShowReview(books[i]);
        cout << "Reprising:\n"
             << "Rating\tBook\n";
        std::vector<Review>::iterator pr;
        for (pr = books.begin(); pr != books.end(); pr++)
            ShowReview(*pr);
        std::vector <Review> oldlist(books);						// использование конструктора копирования
        if (num > 3)
        {
            books.erase(books.begin() + 1, books.begin() + 3);	// Удаление двух элементов
            cout << "After erasure:\n";
            for (pr = books.begin(); pr != books.end(); pr++)
                ShowReview(*pr);
            books.insert(books.begin(), oldlist.begin() + 1, oldlist.begin() + 2); // Вставка одного элемента
            cout << "After insertion:\n";
            for (pr = books.begin(); pr != books.end(); pr++)
                ShowReview(*pr);
        }
        books.swap(oldlist);										// смена местави books и oldlist
        cout << "Swapping oldlist with books:\n";
        for (pr = books.begin(); pr != books.end(); pr++)
            ShowReview(*pr);
    }
    else
        cout << "Nothing entered, nothing gained.\n";
	return 0;
}
bool FillReview(Review & rr)
{
    std::cout << "Enter book title (quit to quit): ";
    std::getline(std::cin,rr.title);
    if (rr.title == "quit")
        return false;
    std::cout << "Enter book rating: ";
    std::cin >> rr.rating;
    if (!std::cin)
        return false;
    while (std::cin.get() != '\n')      // Избавиться от остальной части строки ввода
        continue;
    return true;
}
void ShowReview(const Review & rr)
{
    std::cout << rr.rating << "\t" << rr.title << std::endl; 
}
/*  Дополнительные возможности векторов.
 Автономные, не являющиеся членами класса функции, определены для выполнения 
операций, такие как поиск, сортировка, тасование и т.д. Таким образом, вместо 
того чтобы определять отдельную функцию-член find() для каждого класса контейнера,
в библиотеке определяется одна автономная функция find(), которая может 
использоваться для всех классов контейнеров. В ряде случаев STL определяет 
функцию-член даже при наличии автономной функции для решения той же самой задачи.
Причина в том, что специфичные для класса алгоритмы выполнения некоторых действий 
эффективнее более общих алгоритмов. Поэтому функция swap() класса vector будет 
эффективнее автономной функции swap(). С другой стороны, автономная версия позволит 
обменивать содержимое двух контейнеров различного типа.
 Функция for_each() работает с любым классом-контейнером. Она принимает три аргумента.
Первые два аргумента — это итераторы, определяющие диапазон, а третий аргумент —
указатель на функцию, представляющий собой объект функции (функтор). Затем функция 
for_each() применяет указанную в аргументе функцию ко всем элементам контейнера в 
указанном диапазоне. Функция, указанная в аргументе, не должна изменять значение 
элементов контейнера. Функцию for_each() можно использовать вместо цикла for: */
vector<Review>::iterator pr;
for (pr = books.begin(); pr != books.end(); pr++)
	ShowReview(*pr);
// можно заменить следующим кодом:
for_each(books.begin(), books.end(), ShowReview);
/* Это позволяет избежать явного использования переменных итераторов.
 Функция random_shuffle() принимает в качестве аргументов два итератора, которые
указывают границы диапазона, и тасует элементы в этом диапазоне случайным образом.
Например, следующий оператор изменяет случайным образом порядок следования всех 
элементов вектора books: */
random_shuffle(books.begin(), books.end());
/* В отличие от функции for_each(), которая работает с любым классом-контейнером,
random_shuffle() требует, чтобы класс контейнера разрешал доступ к своим
элементам в произвольном порядке. Класс vector удовлетворяет этому требованию.
 Функция sort() также требует, чтобы контейнер поддерживал произвольный 
доступ. Существуют две версии этой функции. Первая использует два итератора, 
определяющих границы диапазона, и сортирует элементы этого диапазона с помощью 
операции '<', определенной для типа элемента, который хранится в контейнере. Например,
следующий код сортирует содержимое coolstuff по возрастанию с применением
встроенной операции '<' для сравнения значений: */
vector<int> coolstuff;
sort(coolstuff.begin(), coolstuff.end());
/* Если элементами контейнера являются объекты, типы которых определены 
пользователем, то для этого типа объектов должна быть определена функция operator<(),
в противном случае функция sort() работать не будет. Например, вектор, содержащий
объекты Review, можно было бы сортировать либо с помощью функции-члена класса
Review, либо с помощью автономной функции operator<(). Поскольку Review — это 
структура, ее члены открыты, и в этом случае можно применять автономную функцию: */
bool operator<(const Review & r1, const Review & r2)
{
	if (r1.title < r2.title)
		return true;
	else if (r1.title == r2.title && r1.rating < r2.rating)
		return true;
	else
		return false;
}
/* Используя подобную функцию, можно отсортировать вектор объектов Review: */
sort(books.begin(), books.end());
/* Эта версия функции operator<() сортирует члены title в лексикографическом
порядке. Если у двух объектов поля title совпадают, объекты сортируются по полю
rating. Но предположим, что требуется выполнить сортировку в убывающем порядке
или по рейтингам rating, а не по заглавиям title. В этом случае можно 
использовать вторую форму функции sort(). Она принимает три аргумента. Первые два,
как и в предыдущем случае, являются итераторами, определяющими диапазон. Третий 
аргумент — указатель на функцию (точнее — функтор), которая будет использоваться 
вместо operator<() для выполнения сравнения. Функция должна возвращать значение,
которое можно преобразовать в тип bool, причем значение false означает, что 
аргументы функции расположены в неправильном порядке. Вот пример такой функции: */
bool WorseThan(const Review & r1, const Review & r2)
{
	if (r1.rating < r2.rating)
		return true;
	else
		return false;
}
/* Располагая этой функцией, можно написать следующий оператор для сортировки
вектора books, состоящего из объектов Review, по возрастанию рейтинга: */
sort(books.begin(), books.end(), WorseThan);
/* Функция WorseThan() сортирует объекты Review менее точно, чем operator<(). 
Если член title объектов совпадает, функция operator<() осуществляет сортировку по 
полю rating. Но если и эти два поля объектов совпадают, функция WorseThan() считает
их эквивалентными. Первый вид упорядочения называется полным упорядочением, а 
второй — строгим квазиупорядочением. При полном упорядочении, если оба выражения 
а < b и b < а ложны, то 'а' должно быть идентично 'b'. При строгом квазиупорядочении
это не так. Объекты могут быть полностью идентичными, а могут совпадать только по 
одному критерию, такому, как поле rating в примере с функцией WorseThan(). Поэтому 
при строгом квазиупорядочении лучше говорить, что объекты эквивалентны, а не идентичны.*/
// vect3.cpp -- использование функций STL
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
struct Review
{
    std::string title;
    int rating;
};
bool operator<(const Review & r1, const Review & r2);
bool worseThan(const Review & r1, const Review & r2);
bool FillReview(Review & rr);
void ShowReview(const Review & rr);
int main()
{
    using namespace std;

    vector<Review> books;
    Review temp;
    while (FillReview(temp))
        books.push_back(temp);
    if (books.size() > 0)
    {
        cout << "Thank you. You entered the following "
             << books.size() << " ratings:\n"
             << "Rating\tBook\n";
        for_each(books.begin(), books.end(), ShowReview);

        sort(books.begin(), books.end());					// использует operator<
        cout << "Sorted by title:\nRating\tBook\n";
        for_each(books.begin(), books.end(), ShowReview);

        sort(books.begin(), books.end(), worseThan);			// использует worseThan()
        cout << "Sorted by rating:\nRating\tBook\n";
        for_each(books.begin(), books.end(), ShowReview);

        random_shuffle(books.begin(), books.end()); // тасует элементы в этом диапазоне случайным образом
        cout << "After shuffling:\nRating\tBook\n";
        for_each(books.begin(), books.end(), ShowReview);
    }
    else
        cout << "No entries. ";
    cout << "Bye.\n";
    return 0;
}

bool operator<(const Review & r1, const Review & r2)    // для sort()
{
    if (r1.title < r2.title)
        return true;
    else if (r1.title == r2.title && r1.rating < r2.rating)
        return true;
    else
        return false;
}
bool worseThan(const Review & r1, const Review & r2)    // для sort()
{
    if (r1.rating < r2.rating)
        return true;
    else
        return false;
}
bool FillReview(Review & rr)
{
    std::cout << "Enter book title (quit to quit): ";
    std::getline(std::cin,rr.title);
    if (rr.title == "quit")
        return false;
    std::cout << "Enter book rating: ";
    std::cin >> rr.rating;
    if (!std::cin)
        return false;
    // get rid of rest of input line
    while (std::cin.get() != '\n')
        continue;
    return true;
}
void ShowReview(const Review & rr)                      // для for_each()
{
    std::cout << rr.rating << "\t" << rr.title << std::endl; 
}
/*  Цикл for, основанный на диапазоне (С++11) предназначен для работы с 
библиотекой STL. */
double prices[5] = {4.99, 10.99, 6.87, 7.99, 8.49};
for (double x : prices)
	cout << x << std::endl;
/* Аргументы, указанные в круглых скобках оператора for, объявляют тип 
переменной, хранящейся в контейнере, и имя этого контейнера. Затем в теле 
цикла именованная переменная используется для поочередного обращения к 
каждому из элементов контейнера. Cледующий оператор: */
for_each(books.begin(), books.end(), ShowReview);
// можно заменить следующим циклом for, основанным на диапазоне:
for (auto x : books) ShowReview(x);
/* Компилятор будет использовать тип объекта books, которым является
vector<Review>, для определения того, что типом объекта 'х' является Review,
и цикл будет по очереди передавать каждый объект Review контейнера books в 
функцию ShowReview(). В отличие от функции for_each(), цикл for, основанный 
на диапазоне, может изменять содержимое контейнера. При этом важно указать 
параметр ссылки. Например: */
void InflateReview(Review & r) { r.rating++; }
// Эту функцию можно применить к каждому элементу в объекте books:
for (auto & х : books) InflateReview(x);
/*	Обобщенное программирование.
 STL — это пример обобщенного программирования. При объектно-ориентированном 
программировании основное внимание уделяется аспекту данных, а при обобщенном —
алгоритмам. Общим аспектом этих двух подходов является абстрагирование и создание 
повторно используемого кода, но положенная в их основу философия довольно отличается.
Цель обобщенного программирования — создание кода, который не зависит от типов данных.
Шаблоны — это средства C++, предназначенные для создания обобщенных программ.
Шаблоны позволяют определять функции или классы в терминах обобщенного типа. Библиотека
STL предоставляет обобщенное представление алгоритмов.
  Предназначение итераторов.
 Понимание работы итераторов — одно из главных условий понимания STL. Итераторы 
обеспечивают независимость от типа используемых контейнеров.
 Рассмотрим функцию, которая осуществляет поиск некоторого значения в обычном массиве 
элементов типа double. */
double * find_ar (double * ar, int n, const double & val)
{
	for (int i = 0; i < n; i++)
		if (ar[i] == val)
			return &ar[i];
	return 0;	// или return nullptr; в С++11
}
/* Если функция находит значение в массиве, она возвращает адрес в массиве, по
которому находится указанное значение, или в противном случае нулевой указатель.
Для перемещения по массиву она использует нотацию индексов. Чтобы обобщить эту
функцию для работы с массивами любого типа, к которым применима операция '==',
можно использовать шаблон. Однако этот алгоритм по-прежнему применим только
для определенной структуры данных — массива.
 Рассмотрим поиск в другой структуре — связном списке: */
struct Node
{
	double item;
	Node * p_next;
};
/* Указатель p_next в каждом узле списка указывает на следующий узел, a p_next 
последнего элемента установлен в '0'. */
Node * find_ll(Node * head, const double & val)
{
	Node * start;
	for (start = head; start!= 0; start = start->p_next)
		if (start->item == val)
			return start;
	return 0;
}
/* С помощью шаблона можно обобщить этот алгоритм для списков данных любого типа,
поддерживающих операцию '=='. Тем не менее, он останется применимым только к одной 
определенной структуре данных — связному списку. Если внимательнее рассмотреть 
подробности реализации, выяснится, что две функции find используют различные алгоритмы:
одна применяет индексацию массива для перемещения по списку элементов, а другая —
сброс значения start в start->p_next. Но в широком смысле оба алгоритма совпадают: 
они последовательно сравнивают искомое значение со значением каждого элемента контейнера
до тех пор, пока не будет найдено совпадение.
 В данном случае целью обобщенного программирования может быть получение единственной 
функции find, которая бы работала с массивами, со связными списками или с любым другим
типом контейнера. То есть функция должна быть независимой не только от типа данных, 
хранящихся в контейнере, но и от структуры данных самого контейнера. Шаблоны обеспечивают
обобщенное представление типа данных, хранимых в контейнере. Что нам необходимо —
так это обобщенное представление процесса перемещения по элементам контейнера. Итератор 
и является таким обобщенным представлением.
 Итератор должен обладать следующими свойствами, чтобы реализовать функцию find:
• Нужно иметь возможность разыменовывания итератора, чтобы получить доступ
к значению, на которое он ссылается. То есть, если 'р' — итератор, то должно
быть определено выражение *р.
• Должна существовать возможность присваивания одного итератора другому. Это значит,
что если 'р' и 'q' — итераторы, то должно быть определено выражение р = q.
• Должна существовать возможность сравнения одного итератора с другим. То есть,
если 'р' и 'q' — итераторы, то должны быть определены выражения р == q и р != q.
• Должна существовать возможность перемещения итератора по элементам контейнера. 
Это условие можно удовлетворить, определяя для итератора 'р' выражения '++р' и 'р++'.
 Обычный указатель соответствует требованиям, предъявляемым к итераторам. Поэтому: */
typedef double * iterator;
iterator find_ar(iterator ar, int n, const double & val)
{
	for (int i = 0; i < n; i++, ar++)
		if (*ar == val)
			return ar;
	return 0;
}
/* Затем список параметров функции можно изменить так, чтобы в качестве аргументов, 
задающих диапазон, она принимала указатель на начало массива и указатель на элемент,
следующий за концом массива. */
typedef double * iterator;
iterator find_ar(iterator begin, iterator end, const double & val)
{
	iterator ar;
	for (ar = begin; ar != end; ar++)
		if (*ar == val)
			return ar;
	return end; // признак того, что значение не найдено
}
/* Для функции find_ll() можно определить класс итератора, в котором определены 
операции '*' и '++': */
struct Node
{
	double item;
	Node * p_next;
};
class iterator
{
	Node * pt;
public:
	iterator() : pt(0) {}
	iterator(Node * pn) : pt(pn) {}
	double operator*() { return pt->item; }
	iterators operator++()	// для ++it
	{
		pt = pt->p_next;
		return *this;
	}
	iterator operator++(int) // для it++
	{
		iterator tmp = *this;
		pt = pt->p_next;
		return tmp;
	}
	// ... operator==(), operator!=() и т.д.
};
/* Для различения префиксной и постфиксной версий операции '++' в C++ принято 
соглашение о том, что operator++() — это префиксная форма, a operator++(int) —
постфиксная; аргумент никогда не используется, поэтому в именовании не нуждается.
В данном случае важно не то, как именно реализован класс iterator, а то, что при
его использовании вторая функция find может быть переписана следующим образом: */
iterator find_ll(iterator head, const double & val)
{
	iterator start;
	for (start = head; start!= 0; ++start)
		if (*start == val)
			return start;
	return 0;
}
/* Эта функция очень похожа на find_ar(). Различие между ними только в том, как
обе функции определяют достижение конца списка значений при поиске. Функция
find_ar() использует итератор, указывающий на позицию, которая расположена за
последним элементом, в то время как find_ll() работает с нулевым значением, 
сохраненным в последнем узле. Если устранить это различие, упомянутые функции 
можно сделать идентичными. Например, можно потребовать, чтобы связный список 
содержал один дополнительный элемент за последним реальным элементом. То есть 
можно обеспечить, чтобы и массив, и связный список содержали элемент, 
расположенный "за последним элементом", и поиск можно было бы завершать по 
достижении итератором этого элемента. Тогда и find_ar(), и find_ll() одинаково 
определяли бы конец данных, и их алгоритмы поиска стали бы идентичными. Требование 
наличия дополнительного элемента, расположенного за последним элементом, вытекает 
из требований к итераторам, которые, в свою очередь, предъявляют требования к 
классу контейнеров. Каждый контейнерный класс имеет маркер элемента, расположенного
за последним, который представляет собой значение, присваиваемое итератору при 
выходе за последнее значение контейнера. Для использования класса контейнера не 
требуется знать ни как реализованы итераторы, ни как реализован элемент, 
расположенный за последним. */
vector<double>::iterator pr;
for (pr = scores.begin(); pr != scores.end(); pr++)
	cout << *pr << endl;
// Вместо vector для хранения счетов можно использовать шаблон класса list<double>:
list<double>::iterator pr;
for (pr = scores.begin(); pr != scores.end(); pr++)
	cout << *pr << endl;
/* То есть, определяя для каждого класса соответствующие итераторы и создавая классы в 
унифицированной манере, STL позволяет писать один и тот же код для контейнеров, которые
имеют совершенно разное внутреннее представление. Автоматическое выведение типа C++11
позволяет еще больше упростить задачу и применять следующий код при работе и с вектором,
и со списком: */
for (auto pr = scores.begin(); pr != scores.end(); pr++)
	cout << *pr << endl;
/* По стилевым соображениям лучше избегать непосредственного применения итераторов;
вместо этого, если возможно, следует использовать функции STL, такие как for_each(),
которые самостоятельно позаботятся о нюансах. Можно также воспользоваться циклом for,
основанным на диапазоне: */
for (auto x : scores) cout << x << endl;
/* Для обеспечения работы обобщенного алгоритма со специфическими случаями определяются
итераторы, соответствующие нуждам алгоритма, и закладываются требования в архитектуру
контейнеров. Это значит, что базовые свойства итераторов и контейнеров вытекают из 
требований, заложенных в алгоритм.
  Виды итераторов.
 Разные алгоритмы предъявляют разные требования к итераторам. Например, алгоритм find 
требует определения операции '++', чтобы итератор мог пошагово проходить весь контейнер.
Ему нужен доступ к данным для чтения, но не для записи. С другой стороны, обычный 
алгоритм сортировки требует произвольного доступа, чтобы иметь возможность обмена 
значениями для двух не соседствующих элементов. Если 'iter' — итератор, произвольный
доступ можно получить, определив операцию '+', чтобы можно было написать  выражение 
вроде iter + 10. Кроме того, алгоритм сортировки должен иметь возможность как читать,
так и записывать данные. В библиотеке STL определены пять видов итераторов и описаны
их алгоритмы в терминах необходимых им разновидностей итераторов. Эти пять видов 
итераторов следующие: входной итератор, выходной итератор, однонаправленный итератор, 
двунаправленный итератор и итератор произвольного доступа. Например, прототип find() 
выглядит так: */
template<class InputIterator, class T>
InputIterator find(InputIterator first, InputIterator last, const T & value);
/* Это говорит о том, что алгоритм требует входного итератора. Аналогичным 
образом следующий прототип указывает, что алгоритм сортировки sort нуждается в 
итераторе произвольного доступа: */
template<class RandomAccessIterator>
void sort(RandomAccessIterator first, RandomAccessIterator last);
/* Все пять видов итераторов можно разыменовывать (т.е. для них определена 
операция '*') и сравнивать на предмет эквивалентности (с помощью операции '==', возможно,
перегруженной) и неэквивалентности (с помощью операции '!=', возможно, перегруженной).
Если два сравниваемых итератора эквивалентны, то разыменование одного должно 
порождать то же значение, что и разыменование другого. То есть, если выражение: */
iter1 == iter2
// истинно, то и следующее выражение также истинно:
*iter1 == *iter2
/* Эти свойства остаются истинными и для встроенных операций и указателей.
  Входные итераторы.
 Термин входной используется с точки зрения программы. То есть информация,
поступающая из контейнера в программу, считается входной, подобно поступающей
в программу с клавиатуры. Таким образом, входной итератор — это тот, который 
программа может применять для считывания значений из контейнера. В частности, 
разыменование входного итератора должно позволить программе прочитать значение из
контейнера, но это не обязательно означает возможность изменения этого значения.
Поэтому алгоритмы, которые требуют входных итераторов — это алгоритмы, которые
не изменяют значения, хранящиеся в контейнере. Входной итератор должен обеспечивать 
доступ ко всем значениям в контейнере. Он решает эту задачу, поддерживая операцию
'++' в префиксной и в постфиксной форме. Нет никакой гарантии, что второй проход по 
элементам контейнера с помощью входного итератора будет выполнен в той же 
последовательности. Также не существует гарантий, что после увеличения значения 
входного итератора на единицу его предыдущее значение останется доступным для 
разыменования. Поэтому любой алгоритм, построенный на основе входного итератора,
должен быть однопроходным и не зависеть от значений итератора из предшествующего 
прохода или предшествующих значений итератора из того же самого прохода. Входной 
итератор является однонаправленным; его можно инкрементировать, но нельзя возвращать
в предшествующие состояния.
  Выходные итераторы.
В контексте STL термин выходной означает, что итератор используется для передачи
информации из программы в контейнер. (Таким образом, вывод программы является
вводом для контейнера.) Выходной итератор аналогичен входному за исключением
того, что его разыменование гарантированно предоставляет программе возможность
изменять значение контейнера, но не читать его. Входной итератор можно применять 
для алгоритмов однократного прохода с доступом только для чтения, а выходной 
итератор — для алгоритмов однократного прохода с доступом только для записи.
  Однонаправленные итераторы.
 Однонаправленный итератор может осуществлять перемещение по контейнеру только 
вперед, поэлементно. Однако, в отличие от входных и выходных итераторов, при 
каждом использовании он обязательно выполняет проход по последовательности 
значений в одном и том же порядке. Кроме того, после инкрементирования 
однонаправленного итератора предыдущее значение по-прежнему можно разыменовать,
если оно было сохранено, и получить при этом то же самое значение. Эти свойства 
позволяют реализовать многопроходные алгоритмы. Однонаправленный итератор может 
позволить как чтение, так и модификацию данных, либо только чтение: */
int * pirw;			// итератор чтения и записи
const int * pir;	// итератор только для чтения
/*  Двунаправленные итераторы.
 Предположим, что имеется алгоритм, которому нужна возможность прохода контейнера 
в обоих направлениях. Например, функция обратного прохода может обменивать значения 
первого и последнего элемента, инкрементировать указатель на первый элемент, 
декрементировать указатель на второй элемент, а затем повторять этот процесс. 
Двунаправленный итератор обладает всеми свойствами однонаправленного итератора и 
добавляет к ним поддержку двух операций декремента (префиксной и постфиксной).
  Итераторы произвольного доступа.
 Некоторые алгоритмы, такие как стандартная сортировка и бинарный поиск, требуют 
возможности перехода непосредственно на произвольный элемент контейнера. Этот 
способ доступа называется произвольным доступом и требует итератора произвольного 
доступа. Итератор такого типа обладает всеми свойствами двунаправленного итератора,
а также операциями (наподобие операции сложения с указателем), которые поддерживают 
произвольный доступ, и операциями отношения для упорядочения элементов.
Выражение	Описание
а + n		Указывает на n-й элемент после того, на который указывает 'a'
n + а 		То же самое, что a + n
а - n 		Указывает на n-й элемент перед тем, на который указывает 'a'
r += n 		Эквивалентно r = r + n
r -= n 		Эквивалентно r = r - n
а[n] 		Эквивалентно *(а + n)
b - а 		Такое значение 'n', при котором b = a + n
а < b 		Истинно, если b - а > 0
а > b 		Истинно, если b < а
а >= b 		Истинно, если !(а < b)
а <= b 		Истинно, если !(а > b)
 В этой таблице 'а' и 'b' — значения итератора, а 'r' — переменная или ссылка итератора 
произвольного доступа. Выражения вроде а + n корректны, только если 'a' и a + n лежат 
в диапазоне контейнера (включая элемент, расположенный за последним).
  Иерархия итераторов.
 Виды итераторов образуют иерархию. Однонаправленный итератор обладает всеми свойствами
входного и выходного итераторов, а также собственными возможностями. Двунаправленный 
итератор имеет все свойства однонаправленного итератора плюс собственные. А итератор 
произвольного доступа имеет все свойства однонаправленного итератора, к которым 
добавлены его собственные возможности.
В таблице 'і' — итератор, a 'n' — целое значение:
Возможность итератора		Входной	Выходной	 Однонаправлен. Двунаправлен. Произвольн.
Разыменующее чтение		Да		Нет			Да				Да			Да
Разыменующая запись		Нет		Да			Да				Да			Да
Фиксированный и 			Нет		Нет			Да				Да			Да
повторяющийся порядок
	++i, i++				Да		Да			Да				Да			Да
	--і, і--				Нет		Нет			Нет				Да			Да
	i[n]					Нет		Нет			Нет				Нет			Да
	i + n				Нет		Нет			Нет				Нет			Да
	i - n				Нет		Нет			Нет				Нет			Да
	i += n				Нет		Нет			Нет				Нет			Да
	i -= n				Нет		Нет			Нет				Нет			Да
 Алгоритмы, написанные в терминах определенного вида итераторов, могут использовать
этот итератор или любой другой, обладающий нужными возможностями. Поэтому, например,
контейнер с итератором произвольного доступа может пользоваться алгоритмом, 
написанным для входного итератора. Идея состоит в том, чтобы написать алгоритм, 
использующий итератор с минимально необходимыми требованиями, что позволит его 
применять с максимальным множеством различных контейнеров. Так, функция find(), 
за счет использования входного итератора начального уровня, может применяться с 
любым контейнером, который содержит читаемые значения. Однако функция sort(), 
которая требует итераторов произвольного доступа, может использоваться только с 
контейнерами, поддерживающими этот вид итераторов. Различные виды итераторов не 
являются определенными типами. Скорее, они представляют собой концептуальные 
характеристики. Каждый класс контейнера определяет typedef с областью видимости 
класса по имени. Поэтому класс vector<int> имеет итератор типа vector<int>::iterator. 
Итераторы вектора — это итераторы произвольного доступа. Данный факт позволяет 
применять алгоритмы, базирующиеся на итераторах любого типа, потому что итератор 
произвольного доступа обладает возможностями всех итераторов. Аналогично класс 
list<int> имеет итераторы типа list<int>::iterator. Библиотека STL реализует 
двунаправленные связные списки, которые используют двунаправленный итератор. 
Поэтому такой список не может применять алгоритмы на основе итераторов произвольного
доступа, но может использовать алгоритмы на базе менее требовательных итераторов.
  Концепции, уточнения и модели.
 Итератор — это набор требований, а не тип. Требования могут быть удовлетворены 
специально спроектированным классом итератора, но они могут также быть удовлетворены
и обычным указателем. Алгоритм STL работает с любой реализацией итератора, которая 
соответствует его требованиям. В литературе по STL для описания набора требований 
применяется слово концепция. Библиотека STL включает шаблоны итераторов всех 
стандартных разновидностей.
 Механизм наследования C++ нельзя применить к итераторам. Например, однонаправленный 
итератор можно реализовать как класс, а двунаправленный — как обычный указатель. 
Таким образом, с точки зрения C++ данный конкретный двунаправленный итератор, будучи 
встроенным типом, не может быть производным от класса. Однако концептуально он его 
наследует. Двунаправленный итератор — это уточнение (refinement) концепции 
однонаправленного итератора.
 Конкретная реализация концепции называется моделью. Так, обычный указатель на
целое — это модель концепции итератора произвольного доступа. Он является также
моделью однонаправленного итератора, поскольку удовлетворяет всем требованиям
этой концепции.
  Указатель как итератор.
 Итераторы — это обобщения указателей, и указатели отвечают всем требованиям,
предъявляемым к итераторам. Итераторы образуют интерфейс для алгоритмов STL, a
указатели являются итераторами, поэтому алгоритмы STL могут использовать указатели
для работы с не относящимися к STL контейнерами, которые построены на основе
указателей. Например, алгоритмы STL можно применять к массивам. */
const int SIZE = 100;
double Receipts[SIZE];
/* &Receipts[0] (или просто Receipts) — это адрес первого элемента, a &Receipts[SIZE]
(или просто Receipts + SIZE) — это адрес элемента, следующего за последним элементом 
массива. Тогда следующий вызов функции выполняет сортировку массива: */
sort(Receipts, Receipts + SIZE);
/* Тот факт, что указатели являются итераторами и алгоритмы построены на основе 
итераторов, делает возможным применение алгоритмов STL к обычным массивам. 
Аналогично, алгоритмы STL можно применять к формам данных собственной разработки 
при условии обеспечения соответствующих итераторов (которые могут быть указателями
или объектами), а также индикаторов элементов, расположенных за последним.
  сору(), ostream_iterator и istream_iterator.
 Существует алгоритм сору(), предназначенный для копирования данных из одного
контейнера в другой. Этот алгоритм выражен в терминах итераторов, поэтому он 
может копировать из одного вида контейнеров в другой, и даже из массива или в него,
поскольку в качестве итераторов можно применять указатели массива. */
int casts[10] = {6, 7, 2, 9, 4, 11, 8, 7, 10, 5};
vector<int> dice[10];
copy(casts, casts + 10, dice.begin());	// копирование массива в вектор
/* Первые два аргумента-итератора функции сору() представляют диапазон, 
который следует скопировать, а последний аргумент-итератор — местоположение,
куда копируется первый элемент. Первые два аргумента должны быть входными 
(или более совершенными) итераторами, а заключительный аргумент — выходным 
(или более совершенными) итератором. Функция сору() переписывает существующие 
данные в контейнере назначения, и этот контейнер должен быть достаточно велик, 
чтобы вместить копируемые элементы. 
 Если требуется копировать информацию на дисплей, шаблон ostream_iterator из STL,
представляющий выходной поток, представляет собой модель концепции выходного 
итератора. Одновременно он является примером адаптера — класса или функции, 
которая преобразует какой-то другой интерфейс в интерфейс, используемый STL. */
#include <iterator>
ostream_iterator<int, char> out_iter(cout, " ");
/* Итератор out_iter становится интерфейсом, который позволяет применять cout 
для отображения. Первый аргумент шаблона (в данном случае int) указывает тип данных,
отправляемых в выходной поток. Второй аргумент шаблона (в этом случае char) задает
символьный тип, используемый выходным потоком (другим допустимым значением могло бы
быть wchar_t). Первый аргумент конструктора (в рассматриваемой ситуации это cout)
идентифицирует используемый выходной поток. Им мог бы быть также поток, используемый
для вывода файла. Последний строковый аргумент — это разделитель, который должен 
отображаться после каждого элемента, отправленного в выходной поток. Итератор можно
было бы применять следующим образом: */
*out_iter++ = 15;	// работает подобно cout << 15 << " ";
/* Для обычного указателя это означало бы присваивание значения '15' переменной,
находящейся по адресу 'out_iter', с последующим инкрементированием этого указателя.
Однако для данного итератора ostream_iterator приведенный оператор означает
отправку значения '15' и строки, состоящей из пробела, в выходной поток, управляемый
cout. После этого выходной поток должен быть готов к следующей операции вывода.
С функцией сору() итератор можно было бы использовать следующим образом: */
copy(dice.begin(), dice.end(), out_iter);	// копирование вектора в выходной поток
/* Это означало бы копирование всего содержимого контейнера 'dice' в выходной 
поток, т.е. отображение содержимого контейнера. Или же можно пропустить создание 
именованного итератора и вместо него сконструировать неименованный итератор: */
copy(dice.begin(), dice.end(), ostream_iterator<int, char>(cout, " "));
/* Аналогично, заголовочный файл <iterator> определяет шаблон istream_iterator
для адаптации ввода istream к интерфейсу входного итератора. Это — модель 
концепции входного итератора. Для определения входного диапазона функции сору()
можно применять два объекта istream_iterator: */
copy(istream_iterator<int, char>(cin), istream_iterator<int, char>(), dice.begin());
/* Первый аргумент указывает тип данных, который будет прочитан, а второй —
символьный тип, используемый входным потоком. Применение аргумента конструктора
сіп означает использование входного потока, управляемого сin. Опускание аргумента
конструктора означает ошибку ввода, поэтому приведенный выше код означает чтение
из входного потока вплоть до возникновения условия конца файла, несоответствия типа
или другой ошибки ввода.
  reverse_iterator, back_insert_iterator, front_insert_iterator и insert_iterator.
 Обратный итератор (reverse_iterator). В сущности, инкрементирование этого итератора 
вызывает его декремент. Предположим, что требуется отобразить содержимое контейнера 
'dice'. Можно воспользоваться сору() и ostream_iterator для копирования содержимого в 
выходной поток: */
ostream_iterator<int, char> out_iter(cout, " ");
copy(dice.begin(), dice.end(), out_iter); // отображение в прямом порядке
/* Теперь предположим, что требуется вывести элементы в обратном порядке. (Возможно,
для проведения ретроспективного исследования.) Класс vector имеет функцию-член rbegin(),
возвращающую обратный итератор, который указывает на элемент, находящийся за последним,
и функцию-член rend(), возвращающую обратный итератор, который указывает на первый 
элемент. Поскольку инкрементирование обратного итератора приводит к его декременту, 
для отображения содержимого в обратном порядке можно применить следующий оператор: */
copy(dice.rbegin(), dice.rend(), out_iter); // отображение в обратном порядке
/* Обратный итератор даже не нужно объявлять. И rbegin(), и end() возвращают одно и 
то же значение (находящееся за последним элементом), но разного типа (reverse_iterator
и iterator, соответственно). Аналогично, rend() и begin() возвращают одно и то же 
значение (итератор, указывающий на первый элемент), но разного типа.
 Обратные указатели должны выполнять специальную компенсацию. Предположим, что 'rp' —
обратный указатель, инициализированный в dice.rbegin(). Каким должно быть значение '*rp'?
Поскольку rbegin() возвращает элемент, находящийся за последним в контейнере, не нужно
пытаться разыменовывать этот адрес. Аналогично, если rend() — действительное 
местоположение первого элемента, сору() останавливается за один элемент до первого 
элемента контейнера, поскольку диапазон не включает в себя последний элемент. Обратные
указатели решают обе проблемы, вначале выполняя декремент, а затем разыменование. 
То есть '*rp' разыменовывает значение итератора, непосредственно предшествующее текущему 
значению '*rp'. Если 'rp' указывает на шестую позицию в контейнере, то '*rp' — значение из 
пятой позиции, и т.д. */
#include <iostream>				// copyit.cpp -- copy() и итераторы
#include <iterator>
#include <vector>
int main()
{
    using std::cout;
    int casts[10] = {6, 7, 2, 9, 4, 11, 8, 7, 10, 5};
    std::vector<int> dice(10);
    std::copy(casts, casts + 10, dice.begin());             // Копирование из массива в вектор
    cout << "Let the dice be cast!\n";
    std::ostream_iterator<int, char> out_iter(cout, " ");   // Создание итератора ostream
    copy(dice.begin(), dice.end(), out_iter);               // Копирование из вектора в выходной поток
    cout << std::endl;
    cout << "Implicit use of reverse iterator.\n";
    copy(dice.rbegin(), dice.rend(), out_iter);             // неявное использование обратного итератора
    cout << std::endl;
    cout << "Explicit use of reverse iterator.\n";
   // vector<int>::reverse_iterator ri;
    for (auto ri = dice.rbegin(); ri != dice.rend(); ++ri)  // явное использование обратного итератора
        cout << *ri << ' ';
    cout << std::endl;
    return 0; 
}
/* Когда есть возможность выбора между явным объявлением итераторов и 
использованием функций STL для выполнения всей работы внутренним образом, 
например, посредством передачи возвращаемого значения rbegin() функции, 
следует отдавать предпочтение второму подходу.
 Предположим, что требуемый размер 'dice' заранее не известен. Или представим,
что требуется добавлять элементы в 'dice', а не замещать существующие.
Эти проблемы решают три итератора вставки, преобразуя процесс копирования
в процесс вставки. Вставка добавляет новые элементы, не перезаписывая 
существующие данные, и при этом использует автоматическое выделение памяти 
для обеспечения того, что новая информация поместится в контейнере.
 Итератор back_insert_iterator вставляет элементы в конец контейнера, а
front_insert_iterator — в его начало. И, наконец, insert_iterator вставляет
элементы перед позицией, указанной в аргументе конструктора insert_iterator.
Все эти три итератора являются моделями концепции выходного контейнера.
Существуют некоторые ограничения. back_insert_iterator может применяться только
с контейнерными типами, которые допускают быструю вставку в конец. (Термин 
быстрая относится к алгоритму с постоянным временем. Класс vector позволяет это
делать. front_insert_iterator может использоваться только с контейнерными типами,
допускающими вставку в начало за постоянное время. Класс vector не позволяет это
делать, а класс queue — позволяет. Итератор insert_iterator не обладает этими 
ограничениями, т.е. его можно применять для вставки данных в начало вектора. 
Однако front_insert_iterator выполняет это быстрее с теми контейнерными типами, 
которые поддерживают его применение. insert_iterator можно использовать для 
преобразования алгоритма, который копирует данные, в алгоритм, вставляющий их.
Эти итераторы принимают тип контейнера в качестве аргумента шаблона и фактический
идентификатор контейнера — как аргумент конструктора. Таким образом, чтобы создать
итератор back_insert_iterator для контейнера vector<int> по имени 'dice', нужно: */
back_insert_iterator< vector<int> > back_iter(dice);
/* Необходимость объявления типа контейнера обусловлена тем, что итератор 
должен применять соответствующий метод контейнера. Код конструктора 
back_insert_iterator будет исходить из предположения о существовании метода 
push_back() для переданного ему типа. Функция сору(), будучи автономной функцией,
не обладает правами доступа для изменения размера контейнера. Но приведенное 
объявление позволяет back_iter пользоваться методом vector<int>::push_back(), 
который обладает нужными правами доступа. Объявление front_insert_iterator имеет 
ту же форму. Объявление insert_iterator содержит дополнительный аргумент 
конструктора для указания позиции вставки: */
insert_iterator< vector<int> > insert_iter(dice, dice.begin());
// inserts.cpp -- copy() и итераторы вставки
#include <iostream>
#include <string>
#include <iterator>
#include <vector>
#include <algorithm>
void output(const std::string & s) { std::cout << s << " "; }
int main()
{
    std::string s1[4] = {"fine", "fish", "fashion", "fate"};
    std::string s2[2] = {"busy", "bats"};
    std::string s3[2] = {"silly", "singers"};
    std::vector<std::string> words(4);
    copy(s1, s1 + 4, words.begin());                // копирует четыре строки из s1 в words.
    for_each(words.begin(), words.end(), output);
    std::cout << std::endl;
// Конструирование анонимного объекта типа back_insert_iterator
    copy(s2, s2 + 2, std::back_insert_iterator< std::vector<std::string> >(words)); /* вставляет
строки из s2 в место, находящееся перед концом массива words, увеличивая размер words до шести элементов.*/
    for_each(words.begin(), words.end(), output);
    std::cout << std::endl;
// Конструирование анонимного объекта типа insert_iterator
    copy(s3, s3 + 2, std::insert_iterator< std::vector<std::string> >(words, words.begin())); /* вставляет 
две строки из s3 перед первым элементом words, увеличивая его размер до восьми элементов. */
    for_each(words.begin(), words.end(), output);
    std::cout << std::endl;
    return 0; 
}
/* сору() позволяет копировать информацию не только из одного контейнера в другой, но
и из контейнера в выходной поток и из входного потока в контейнер, сору() можно применять
также для вставки данных в другой контейнер. 
	Виды контейнеров.
 Концепции контейнеров — это общие категории с названиями, наподобие: контейнер, 
последовательный контейнер и ассоциативный контейнер. Типы контейнеров — это шаблоны,
которые можно применять для создания специфических объектов-контейнеров. 
  Концепции контейнеров.
 Концепция представляет собой разновидность концептуального абстрактного класса —
концептуального потому, что классы контейнеров на самом деле не используют механизм 
наследования. Или, если посмотреть на это иначе, концепция контейнера устанавливает 
набор требований, которым должны удовлетворять все классы контейнеров STL.
 Контейнер — это объект, который хранит в себе другие объекты одного типа. Хранимые 
объекты могут быть объектами в смысле объектно-ориентированного программирования либо
значениями встроенных типов. Данные, сохраненные в контейнере, принадлежат ему. Это 
означает, что когда время существования контейнера истекает, это же происходит с 
сохраненными в нем данными. (Однако если данные являются указателями, истечение срока
существования указываемых ими данных не обязательно.) Тип хранимых объектов должен 
допускать присваивание и конструирование копированием. Базовые типы удовлетворяют 
этим требованиям, как и типы классов — если только определение класса не объявляет 
конструктор копирования и/или операцию присваивания закрытыми или защищенными.
 Базовый контейнер не гарантирует, что его элементы будут сохранены в каком-то
определенном порядке или же, что этот порядок не изменится, но подобные гарантии
могут быть получены за счет уточнений концепции.
  Дополнения С++11 к требованиям, связанным с контейнерами.
 Различие между конструированием с помощью копирования и присваиванием с помощью 
копирования с одной стороны, и конструированием посредством переноса, и
присваиванием посредством переноса с другой состоит в том, что операция копирования
оставляет исходное значение неизменным, а операция переноса может изменять исходное 
значение, возможно, перенося права владения без выполнения какого-либо копирования. 
Когда исходный объект является временным, операции переноса могут предоставить более 
эффективный код, чем обычное копирование.
  Последовательности.
 Базовую концепцию контейнера можно уточнять, добавляя требования. Последовательность —
это важное уточнение, поскольку несколько типов контейнеров STL — deque, forward_list, 
list, queue, priority_queue, stack и vector — являются последовательностями. Очередь 
(queue) позволяет добавлять элементы в конце и удалять в начале. Двусторонняя очередь 
(double-ended queue), представленная контейнером deque, допускает добавление и извлечение
с обеих сторон. Уточнение, заключающееся в том, что итератор должен быть, по меньшей мере,
однонаправленным, гарантирует размещение элементов в определенном порядке, который не 
меняется от одного цикла итераций к другому. Класс array также считается контейнером 
очереди, хотя он удовлетворяет не всем требованиям. Последовательность также требует, 
чтобы элементы были упорядочены в строго линейном порядке. Другими словами, есть первый 
элемент, а также последний элемент, и каждый элемент кроме первого и последнего имеет 
только один элемент непосредственно перед ним и только один — непосредственно за ним.
Массив и связный список являются примерами последовательностей, в то время как структуры 
ветвления (в которых каждый узел указывает на два дочерних) — нет. Поскольку элементы 
в последовательностях размещены в определенном порядке, становятся возможными такие 
операции, как вставка значений в определенную позицию и удаление определенного диапазона
элементов. В таблице применяются обозначения: 't', представляющего значение типа 'Т' — т.е. 
типа значений, хранимых в контейнере, а также 'п' — целого и 'р', 'q', 'і' и 'j', 
представляющих итераторы. Требования к последовательностям:
Выражение:		Возвращаемый тип: 		Описание:
X a(n, t)							Объявляет последовательность 'a' из 'n' копий значения 't'
X(n, t)								Создает анонимную последовательность из 'n' копий значения 't'
X a(i, j)							Объявляет последовательность 'a', инициализированную
									содержимым из диапазона [i, j)
X(i, j)								Создает анонимную последовательность, 
									инициализированную содержимым из диапазона [i, j)
a.insert(p, t)		итератор			Вставляет копию 't' перед 'p'
a.insert(p, n, t)		void				Вставляет 'n' копий 't' перед 'p'
a.insert(p, i, j)		void				Вставляет копии элементов диапазона [i, j) перед 'p'
a.erase(p)			итератор			Удаляет элемент, на который указывает 'p'
a.erase(p, q)		итератор			Удаляет элементы диапазона [р, q)
a.clear()			void				То же самое, что и erase (begin(), end())
 Поскольку классы шаблонов deque, list, priority_queue, stack и vector являются моделями 
концепции последовательности, все они поддерживают операции из этой таблицы. 
 Необязательные требования к последовательностям:
Выражение:		Возвращаемый тип:	 Значение:				Контейнер:
а.front()			T&			*a.begin()				vector, list, deque
a.back()				T&			*--a.end()				vector, list, deque
a.push_front(t)		void			a.insert(a.begin(), t)	list, deque
a.push_back(t)		void			a.insert(a.end(), t)		vector, list, deque
a.pop_front(t)		void			a.erase(a.begin())		list, deque
a.pop_back(t)		void			a.erase(--a.end())		vector, list, deque
a[n]					T&			*(a.begin() + n)			vector, deque
a.at(n) 				T&			*(a.begin() + n)			vector, deque
 И а[n], и a.at(n) возвращают ссылку на n-й элемент (нумерация начинается с '0') в 
контейнере. Различие между ними в том, что a.at(n) выполняет проверку границ и 
генерирует исключение out_of_range, если 'n' находится вне допустимого диапазона 
значений контейнера. Кроме того, метод push_front() определен для list и deque, 
но не для vector. Предположим, что требуется вставить новое значение в начало вектора,
состоящего из 100 элементов. Чтобы освободить место, нужно переместить 99-й элемент 
в позицию 100, затем 98-й элемент — в позицию 99 и т.д. Это операция имеет линейную 
сложность с точки зрения времени выполнения, поскольку перемещение 100 элементов 
займет в 100 раз больше времени, чем перемещение единственного элемента. Но 
предполагается, что операции из последней таблицы реализованы только в том случае, 
если они могут быть выполнены за постоянное время. Проектные решения списков и 
двусторонних очередей, однако, позволяют добавлять элементы в начало без необходимости
перемещения других элементов в новые позиции, поэтому они могут реализовать push_front()
с постоянным временем выполнения.
  vector.
 vector — это представление массива в виде класса. Этот класс поддерживает автоматическое
управление памятью, которое позволяет динамически менять размер объекта vector, увеличивая
и уменьшая его при добавлении или удалении элементов. Он предоставляет произвольный
доступ к элементам. Элементы могут добавляться в конец и удаляться с конца за постоянное 
время, но вставка и удаление в начале и середине — операции с линейным временем выполнения.
vector является последовательностью, данный контейнер также представляет собой модель 
концепции обратимого контейнера. Это добавляет два метода класса: rbegin(), возвращающий 
итератор на первый элемент обратной последовательности, и rend(), возвращающий итератор 
на элемент, который расположен за последним в обратной последовательности. Таким образом, 
если dice — контейнер типа vector<int>, a Show(int) — функция, отображающая целое значение,
то следующий код отображает содержимое dice сначала в прямом, затем в обратном порядке: */
for_each(dice.begin(),  dice.end(),  Show);	// отображение в прямом порядке
cout << endl;
for_each(dice.rbegin(), dice.rend(), Show);	// отображение в обратном порядке
cout << endl;
/* Итератор, возвращаемый этими двумя методами, относится к типу класса reverse_iterator.
Класс шаблона vector — простейший из типов последовательностей и считается типом, который
должен использоваться по умолчанию, если только не выяснится, что какие-то другие типы 
контейнеров больше удовлетворяют требованиям программы.
  deque.
 Очень напоминает контейнер vector, поддерживая произвольный доступ. Основное различие 
между ними состоит в том, что вставка и удаление элементов из начала объекта deque —
операция, выполняемая за постоянное время, в то время как для объекта vector эти операции 
линейны во времени.
  list.
 Класс шаблона list представляет двусвязный список. Каждый его элемент, за исключением 
первого и последнего, связан с предшествующим и последующим элементом, откуда следует, 
что такой список можно проходить в обоих направлениях. Принципиальное различие между 
list и vector заключается в том, что list обеспечивает вставку и удаление за постоянное 
время в любой позиции списка. Подобно vector, класс шаблона list — обратимый контейнер.
В отличие от vector, list не поддерживает форму записи массива и произвольный доступ. В 
отличие от итератора vector, итератор list продолжает указывать на тот же элемент даже 
после вставки или удаления элементов. 
Некоторые функции-члены класса list:
	Функция: 						Описание:
void merge(list<T, Alloc> & x)	Объединяет список 'x' с вызывающим списком. Оба списка
								должны быть отсортированы. Результирующий отсортированный
								список помещается в вызывающий список, а 'x' остается пустым.
								Эта функция обладает линейной сложностью в плане времени выполнения.
void remove(const T & val)		Удаляет все экземпляры 'ѵаl' из списка. Эта функция 
								обладает линейной сложностью в плане времени выполнения.
void sort()						Сортирует список, применяя операцию '<'; время выполнения равно
								N log N для 'N' элементов.
void splice(iterator pos,	list<T, Alloc> x) Вставляет содержимое списка 'x' перед позицией 'pos' и
								оставляет 'x' пустым. Эта функция выполняется за постоянное время.
void unique()					Сворачивает повторяющиеся соседние элементы в один. Эта функция 
								обладает линейной сложностью в плане времени выполнения. */
#include <iostream>		// list.cpp -- использование списка
#include <list>
#include <iterator>
#include <algorithm>
void outint(int n) { std::cout << n << " "; }
int main()
{
    using std::cout;
    using std::endl;
    std::list<int> one(5, 2);						// список int из 5 двоек
    int stuff[5] = {1, 2, 4, 8, 6};
    std::list<int> two;
    two.insert(two.begin(), stuff, stuff + 5);		// вставить массив stuff во второй список 
    int more[6] = {6, 4, 2, 4, 6, 5};
    std::list<int> three(two);
    three.insert(three.end(), more, more + 6);		// вставить массив more в третий список
    cout << "List one: ";							// первый список
    for_each(one.begin(), one.end(), outint);		// outint - функтор для отображения списков вместо
	                                                // for (auto x : three) cout << x << " ";
    cout << endl << "List two: ";						// второй список
    for_each(two.begin(), two.end(), outint);
    cout << endl << "List three: ";					// третий список
    for_each(three.begin(), three.end(), outint);
    three.remove(2);									// удалить все двойки
    cout << endl << "List three minus 2s: ";			// вычитание второго списка из третьего
    for_each(three.begin(), three.end(), outint);
    three.splice(three.begin(), one);				// вставляет содержимое списка 'one' перед позицией 
                                                    // 'pos' и оставляет 'one' пустым.
    cout << endl << "List three after splice: ";		// третий список после splice()
    for_each(three.begin(), three.end(), outint);
    cout << endl << "List one: ";						// первый список после splice()
    for_each(one.begin(), one.end(), outint);
    three.unique();
    cout << endl << "List three after unique: ";		// третий список после unique()
    for_each(three.begin(), three.end(), outint);
    three.sort();									// сортировка третьего списка
    three.unique();									// сворачивает повторяющиеся соседние элементы в один
    cout << endl << "List three after sort & unique: ";
    for_each(three.begin(), three.end(), outint);	// третий список после sort() и unique()
    two.sort();										// сортировка второго списка
    three.merge(two);								// слияние отсортированного второго списка с третьим
    cout << endl << "Sorted two merged into three: ";
    for_each(three.begin(), three.end(), outint);
    cout << endl;
    return 0;
}
/* Основное различие между insert() и splice() состоит в том, что insert()
вставляет копию исходного диапазона в место назначения, в то время как splice()
перемещает исходный диапазон в место назначения. То есть после того, как 
содержимое 'one' сливается с 'three', 'one' остается пустым. Метод splice() оставляет 
итераторы корректными. Таким образом, если определенный итератор установлен для 
указания на элемент из 'one', то он указывает на тот же элемент и после того, как 
splice() переместит его в 'three'. unique() всего лишь удаляет соседние повторяющиеся 
элементы, оставляя по одному экземпляру. После того, как программа выполнит
three.unique(), список 'three' будет по-прежнему содержать две четверки и две 
шестерки, которые не были соседними. Но применение sort(), а затем unique() 
обеспечит уникальность каждого элемента в списке. Существует автономная функция 
sort(), но она требует итераторов произвольного доступа. Поскольку цена быстрой 
вставки — отказ от произвольного доступа, автономную функцию sort() нельзя 
использовать со списками. Поэтому класс включает в себя версию-член, которая 
работает в рамках ограничений, накладываемых классом.
  Набор инструментов класса list.
 Каждый из методов sort(), merge() и unique() также имеет версию, принимающую 
дополнительный аргумент, который указывает альтернативную функцию, предназначенную 
для сравнения элементов. Аналогично, метод remove() имеет версию с дополнительным 
аргументом, который указывает функцию, используемую для определения того, удален 
ли элемент. Эти аргументы являются примерами функций-предикатов.
  forward_list (C++11).
 Класс контейнера forward_list реализует односвязный список. В таком списке каждый 
элемент связан только со следующим элементом, но не с предыдущим. Поэтому такой 
класс требует только однонаправленного, а не двунаправленного итератора. Таким 
образом, в отличие от vector и list, forward_list не является обратимым контейнером. 
По сравнению с list, forward_list проще, компактнее, но предлагает меньше возможностей.
  queue.
 queue представляет собой класс адаптера. Шаблон ostream_iterator — адаптер, который 
позволяет выходному потоку использовать интерфейс итератора. Подобным же образом 
шаблон queue позволяет лежащему в его основе классу (по умолчанию deque) использовать 
типичный интерфейс очереди. queue не только не позволяет произвольный доступ к элементам
очереди, но даже не разрешает выполнять итерацию по ее элементам. Взамен queue 
ограничивается базовыми операциями, определяющими очередь. Можно добавлять элемент в 
конец очереди, удалять элемент из ее начала, просматривать значения первого и последнего
элементов, проверять количество элементов, а также проверять, не пуста ли очередь.
Операции queue:
	Метод: 					Описание:
bool empty() const		Возвращает true, если очередь пуста, в противном случае — false
size_t size() const		Возвращает количество элементов в очереди
T & front()				Возвращает ссылку на элемент, находящийся в начале очереди
T & back()				Возвращает ссылку на элемент, находящийся в конце очереди
void push(const T & x)	Вставляет 'x' в конец очереди
void pop()				Удаляет элемент из начала очереди
 pop() — это метод удаления данных, а не их извлечения. Если требуется использовать 
значение из очереди, сначала нужно вызвать метод front() для извлечения значения, а 
затем pop() — для удаления его из очереди.
  priority_queue.
 priority_queue представляет собой еще один класс адаптера. Он поддерживает те же 
операции, что и queue. Главное отличие между этими двумя классами: в priority_queue 
наибольшее значение перемещается в начало очереди. Внутреннее различие: по умолчанию
классом, лежащим в его основе, является vector. Операцию сравнения, используемую для
определения того, что должно находиться в голове очереди, можно изменить, передавая 
необязательный аргумент конструктору: */
priority_queue<int> pq1;					// версия по умолчанию
priority_queue<int> pq2( greater<int> );	// использование greater<int> для упорядочения
/* Функция greater<>() — предопределенный функциональный объект.
  stack.
 Подобно queue, stack — это класс адаптера. Он предоставляет лежащему в его основе
классу (по умолчанию vector) типичный интерфейс стека. Класс шаблона stack более 
ограничен, чем vector. Он не только не разрешает произвольный доступ к элементам 
стека, но также не позволяет выполнять итерацию по своим элементам. Вместо этого 
stack ограничивается базовыми операциями, определяющими стек. Можно заталкивать 
значение в вершину стека, выталкивать элемент с вершины, просматривать элемент, 
находящийся на вершине, запрашивать количество элементов, а также проверять, не 
пуст ли стек.
Операции класса stack:
	Метод:					Описание:
bool empty() const		Возвращает true, если стек пуст, в противном случае — false
size_t size() const		Возвращает количество элементов в стеке
T & top()				Возвращает ссылку на элемент, находящийся на вершине стека
void push(const T & x)	Вставляет 'х' в вершину стека
void pop()				Удаляет элемент из вершины стека
 Почти так же, как и с queue, если требуется использовать значение из стека, сначала
нужно с помощью top() извлечь значение, а затем посредством pop() удалить его из стека.
  array (C++11).
 array не является контейнером STL, поскольку имеет фиксированный размер.
Поэтому операции, которые должны были бы изменять размер контейнера, такие как
push_back() и insert() , для класса array не определены. Однако определены те
функции-члены, которые имеют для него смысл, например, operator[]() и at().
Кроме того, с объектами массивов можно использовать многие стандартные 
алгоритмы STL, такие как сору() и for_each().
	Ассоциативные контейнеры.
 Ассоциативный контейнер — еще одно уточнение концепции контейнеров. Ассоциативный 
контейнер связывает значение с ключом, который служит для отыскания значения. Например, 
значения могут быть структурами, представляющими информацию о сотрудниках, такую как 
фамилия, адрес, номер офиса, домашний и рабочий телефоны, медицинская карточка и т.д.,
а ключом может быть уникальный табельный номер сотрудника. Чтобы извлечь информацию о 
сотруднике, программа должна использовать ключ для обнаружения структуры, описывающей 
сотрудника. В общем случае для контейнера 'X' выражение X::value_type указывает тип 
значений, хранимых в контейнере. Для ассоциативного контейнера выражение X::key_type 
указывает тип, применяемый для ключей. Ассоциативный контейнер предоставляет быстрый
доступ к своим элементам. Подобно последовательности, ассоциативный контейнер 
позволяет вставлять элементы; однако нельзя указать определенное местоположение для
вставляемых элементов. Это связано с тем, что обычно ассоциативный контейнер 
обладает конкретным алгоритмом для определения места помещения данных, позволяя
быстро извлекать информацию. Ассоциативные контейнеры реализуются с помощью той или 
иной формы дерева. Дерево — это структура данных, в которой корневой узел связан с 
одним или двумя другими узлами, каждый из которых, в свою очередь, связан с одним или
двумя узлами, образуя ветвящуюся структуру. Наличие узлов позволяет сравнительно
просто добавлять или удалять элементы данных, во многом подобно тому, как это имеет 
место в связных списках. Но по сравнению со списком дерево обеспечивает значительно 
более быстрый поиск. Библиотека STL предлагает четыре ассоциативных контейнера:
set, multiset, map и multimap. Простейшим контейнером из четырех является set. 
Тип его значения совпадает с типом ключа, а ключи уникальны — т.е. в наборе хранится
не более одного экземпляра каждого значения ключа. Действительно, для set значение 
элемента является также его ключом. Тип multiset подобен set, за исключением того, 
что он может содержать более одного значения с одним и тем же ключом. Например, 
если типом ключа и значения является int, то объект multiset может содержать значения
1, 2, 2, 2, 3, 5, 7 и 7. В случае тар тип значения отличается от типа ключа, причем 
ключи уникальны и на каждый ключ приходится только одно значение. Тип multimap подобен
тар, за исключением того, что один ключ может быть связан с несколькими значениями.
  set.
 set — это ассоциативный, обратимый и отсортированный набор с уникальными ключами, 
поэтому он не может содержать более одного заданного значения. Подобно vector и list,
set использует параметр шаблона для указания хранимого типа: */
set<string> A;	// набор строковых объектов
/* Необязательный второй аргумент шаблона может служить для указания функции
сравнения или объекта, который должен использоваться для упорядочивания ключей.
По умолчанию применяется шаблон less<>: */
set< string, less<string> > A;
// Рассмотрим следующий код:
const int N = 6;
string s1[N] = { "buffoon", "thinkers", "for", "heavy", "can", "for" };
set<string> A(s1, s1 + N);	// инициализация набора А диапазоном массива
ostream_iterator<string, char> out(cout, " ");
copy(A.begin(), A.end(), out);
/* Как и другие контейнеры, set имеет конструктор, который принимает в качестве 
аргументов диапазон итераторов. Это обеспечивает простой способ инициализации набора 
содержимым массива. Вывод этого фрагмента кода иллюстрирует, что ключи уникальны 
(строка "for" появляется дважды в массиве, но один раз — в наборе), а также то, что 
набор отсортирован: */
#buffoon can for heavy thinkers
/* В математике определены стандартные операции для наборов (множеств). Например, 
объединение двух наборов — это набор, состоящий из содержимого этих двух наборов.
Если определенное значение — общее для двух наборов, то вследствие уникальности 
ключей оно появляется в их объединении только один раз. Пересечение двух наборов —
это набор, состоящий из элементов, общих для обоих этих наборов. Разность двух 
наборов — это первый набор за вычетом элементов, общих для обоих. Библиотека STL 
предоставляет алгоритмы, которые поддерживают эти операции. Они представляют собой
общие функции, а не методы, поэтому не ограничены объектами set. Однако все объекты
set автоматически удовлетворяют обязательному условию применения этих алгоритмов —
контейнер должен быть отсортирован. Функция set_union() принимает пять итераторов в
качестве аргументов. Первые два определяют диапазон одного набора, вторые два —
диапазон второго набора, а последний — это выходной итератор, указывающий 
местоположение, куда следует копировать результирующий набор. Например: */
set_union(A.begin(), A.end(), B.begin(), B.end(), ostream_iterator<string, char> out(cout, " "));
/* Предположим, что результат должен быть помещен в набор 'С', а не отображен на
экране. В этом случае в последнем аргументе понадобится передать итератор, 
указывающий на набор 'С'. Очевидным выбором представляется С.begin(), однако это
не работает по двум причинам: 1. ассоциативные наборы интерпретируют ключи как 
постоянные значения, поэтому итератор, возвращенный С.begin(), будет итератором-
константой, который не может использоваться в качестве выходного итератора. 
2. set_union(), подобно сору(), перезаписывает существующие данные в контейнере и 
требует, чтобы в контейнере было достаточно места для хранения новой информации. 
Набор 'С', будучи пустым, не удовлетворяет этому требованию. Но шаблон 
insert_iterator решает обе проблемы. Он превращает копирование во вставку. Он 
также моделирует концепцию выходного итератора, поэтому его можно использовать 
для выполнения записи в контейнер. Таким образом, можно создать анонимный 
insert_iterator для копирования информации в набор 'С'. Конструктор принимает 
в качестве аргументов имя контейнера и итератор: */
set_union(A.begin(), A.end(), B.begin(), B.end(), insert_iterator< set<string> >(C, C.begin()));
/* Функции set_intersection() и set_difference() находят пересечение и 
разность двух наборов и обладают тем же интерфейсом, что и set_union().
Два удобных метода set — это lower_bound() и upper_bound(). Метод lower_bound() 
принимает значение типа ключа в качестве аргумента и возвращает итератор, 
указывающий на первый член набора, который не меньше ключевого аргумента.
Аналогично, upper_bound() принимает ключ в качестве аргумента и возвращает 
итератор, указывающий на первый член набора, который больше ключевого аргумента.
Например, если имеется набор строк, эти методы можно применять для определения
диапазона, включающего все строки в наборе от 'b' до 'f'. Поскольку сортировка
определяет, куда будут помещаться добавления к набору, класс имеет методы, 
которые лишь указывают добавляемые данные без указания позиции. Например, если
'А' и 'В' — наборы строк, можно использовать следующий код: */
string s("tennis");
A.insert(s);						// вставка значения
В.insert(A.begin(), A.end());	// вставка диапазона значений
// setops.cpp -- некоторые операции с наборами
#include <iostream>
#include <string>
#include <set>
#include <algorithm>
#include <iterator>
int main()
{
    using std::cout;
    using std::endl;
    using std::string;
    const int N = 6;
    string s1[N] = {"buffoon", "thinkers", "for", "heavy", "can", "for"};
    string s2[N] = {"metal", "any", "food", "elegant", "deliver","for"};
    std::set<string> A(s1, s1 + N);
    std::set<string> B(s2, s2 + N);
    std::ostream_iterator<string, char> out(cout, " ");
    cout << "Set A: ";                              // набор А
    copy(A.begin(), A.end(), out);
    cout << endl;
    cout << "Set B: ";                              // набор В
    copy(B.begin(), B.end(), out);
    cout << endl;
    cout << "Union of A and B:\n";                  // объединение А и В
    set_union(A.begin(), A.end(), B.begin(), B.end(), out);
    cout << endl;
    cout << "Intersection of A and B:\n";           // пересечение А и В
    set_intersection(A.begin(), A.end(), B.begin(), B.end(), out);
    cout << endl;
    cout << "Difference of A and B:\n";             // разность А и В
    set_difference(A.begin(), A.end(), B.begin(), B.end(), out);
    cout << endl;
    std::set<string> C;
    cout << "Set C:\n";                             // набор С
    set_union(A.begin(), A.end(), B.begin(), B.end(),
        std::insert_iterator< std::set<string> >(C, C.begin()));
    copy(C.begin(), C.end(), out);
    cout << endl;
    string s3("grungy");
    C.insert(s3);
    cout << "Set C after insertion:\n";             // набор С после вставки
    copy(C.begin(), C.end(),out);
    cout << endl;
    cout << "Showing a range:\n";                   // вывод диапазона
    copy(C.lower_bound("ghost"),C.upper_bound("spook"), out);
    cout << endl;
    return 0;
}
/*  multimap.
 Как и set, multimap — это обратимый, отсортированный ассоциативный контейнер.
При использовании multimap тип ключа отличается от типа значения, а объект 
multimap может содержать более одного значения, связанного с конкретным ключом.
Простейшее объявление multimap задает тип ключа и тип значения, сохраненные в 
виде аргументов шаблона. Например, следующее объявление создает объект multimap,
который использует int как тип ключа и string — в качестве типа сохраненного значения: */
multimap<int, string> codes;
/* Необязательный третий аргумент шаблона может применяться для указания функции 
сравнения или объекта, который будет использоваться для упорядочивания ключа. 
По умолчанию применяется шаблон less<> с типом ключа в качестве параметра. 
Действительный тип значения объединяет тип ключа и тип данных в единую пару. 
Для этого STL использует класс шаблона pair<class T, class U> для хранения двух 
видов значений в одном объекте. Если keytype — тип ключа, а datatype —
тип сохраненных данных, то типом значения будет pair<const keytype, datatype>.
Например, типом значения ранее объявленного объекта codes является: */
pair<const int, string>
/* Предположим, что требуется хранить названия городов с кодом региона в качестве
ключа. Это вполне соответствует объявлению объекта codes, которое использует int
как тип ключа и string — как тип данных. Один из возможных подходов — создание
пары и вставка ее в объект multimap: */
pair<const int, string> item(27, "Komsomolsk-on-Amue");
codes.insert(item);
// Либо можно создать анонимный объект pair и вставить его в единственном операторе:
codes.insert(pair<const int, string> (27, "Komsomolsk-on-Amue"));
/* Поскольку элементы сортируются по ключу, нет необходимости указывать позицию 
вставки. Располагая объектом pair, получать доступ к двум его компонентам можно
с помощью членов first и second: */
pair<const int, string> item(27, "Komsomolsk-on-Amue");
cout << "Region #" << item.first << " City: " << item.second << endl;
/* Функция-член count() принимает в качестве аргумента ключ и возвращает количество
элементов, имеющих такое значение ключа. Функции-члены lower_bound() и upper_bound()
принимают ключ и работают так же, как в классе set. Функция-член equal_range() также 
принимает в качестве аргумента ключ и возвращает итераторы, представляющие диапазон
значений, соответствующих этому ключу. Чтобы вернуть два значения, метод упаковывает
их в один объект pair, на этот раз с обоими аргументами шаблона — итераторами.
Например, следующий код выведет список городов из объекта codes, у которых код 
региона равен 27: */
pair< multimap<KeyType, string>::iterator, multimap<KeyType,
	string>::iterator > range = codes.equal_range(27);
cout << "Cities with area code 27:\n";
std::multimap<KeyType, std::string>::iterator it;
for (it = range, first; it != range.second; ++it)
		cout << (*it).second << endl;
/* Объявления, подобные приведенному выше, способствовали появлению средства
автоматического выведения типа С++11, которое позволяет упростить код: */
auto range = codes.equal_range(27);
cout << "Cities with area code 27:\n";
for (auto it = range, first; it != range.second; ++it)
	cout << (*it).second << endl;
// multmap.cpp -- использование multimap
#include <iostream>
#include <string>
#include <map>
#include <algorithm>
typedef int KeyType;
typedef std::pair<const KeyType, std::string> Pair;
typedef std::multimap<KeyType, std::string> MapCode;
int main()
{
    using std::cout;
    using std::endl;
    MapCode codes;
    codes.insert(Pair(27,  "Komsomolsk-on-Amue"));
    codes.insert(Pair(66,  "Ekaterinburg"));
    codes.insert(Pair(777, "Moskow"));
    codes.insert(Pair(27,  "Amursk"));
    codes.insert(Pair(66,  "Nizhny Tagil"));
    codes.insert(Pair(27,  "Khabarovsk"));
    cout << "Number of cities with area code 27:\t"    // количество городов с кодом региона 27
         << codes.count(27)  << endl;
    cout << "Number of cities with area code 777:\t"   // количество городов с кодом региона 777
         << codes.count(777) << endl;
    cout << "Number of cities with area code 66:\t"    // количество городов с кодом региона 66
         << codes.count(66)  << endl;
    cout << "    Area Code\tCity\n";
    MapCode::iterator it;
    for (it = codes.begin(); it != codes.end(); ++it)
        cout << "\t" << (*it).first << "\t" << (*it).second << endl;
    std::pair<MapCode::iterator, MapCode::iterator> range = codes.equal_range(27);
    cout << "Cities with area code 27:\n";
    for (auto it = range.first; it != range.second; ++it)
        cout << (*it).second  << endl;
    return 0; 
}
/*	Неупорядоченные ассоциативные контейнеры (С++11).
 Подобно ассоциативному контейнеру, неупорядоченный ассоциативный контейнер 
связывает значение с ключом и использует ключ для отыскания значения.
Принципиальное различие между ними в том, что в основе ассоциативных контейнеров
лежат древовидные структуры, тогда как неупорядоченные ассоциативные контейнеры 
построены на основе хеш-таблиц. Цель состоит в получении контейнеров, в которых 
добавление и удаление элементов осуществляется сравнительно быстро и для которых 
существуют эффективные алгоритмы поиска. Доступны четыре типа неупорядоченных 
ассоциативных контейнеров: unordered_set, unordered_multiset, unordered_map и 
unordered_multimap. Хеш-функция преобразует ключ в значение индекса. Например, 
если ключ имеет тип string, хеш-функция могла бы суммировать числовые коды 
символов в string и вычислять эту сумму по модулю '13', давая в результате индексы
в диапазоне '0-12'. Неупорядоченный контейнер будет использовать для хранения 
объектов string '13' областей. Объект string, скажем, с индексом '4', будет помещен
в область '4'. Чтобы найти контейнер для ключа, необходимо применить хеш-функцию 
к ключу и просто искать область с соответствующим индексом. В идеальном случае 
областей должно быть достаточно для того, чтобы каждая из них содержала лишь 
несколько объектов string. Библиотека C++11 предоставляет шаблон hash<Key>, 
который неупорядоченные ассоциативные контейнеры используют по умолчанию. Также 
определены специализации для разнообразных целочисленных типов и типов с 
плавающей точкой, указателей и ряда шаблонных классов, таких как string.
Тот факт, что обычные ассоциативные контейнеры являются упорядоченными, позволяет
им пользоваться предикатом сравнения, который выражает концепцию "меньше чем".
Такое сравнение неприменимо к неупорядоченным ассоциативным контейнерам, поэтому
они вместо него используют предикат сравнения, основанный на концепции "является
эквивалентным".
Типы, определенные для неупорядоченных ассоциативных контейнеров:
	Тип:				Значение:
X:: key_type		Параметр Key, тип ключа.
X:: key_equal	Параметр Pred, представляющий собой бинарный предикат, 
				который проверяет, эквивалентны ли два аргумента типа Key.
X::hasher		Параметр Hash, тип унарного функционального объекта, такой, что если 
				'hf' имеет тип Hash и 'k' имеет тип Key, то hf(k) имеет тип std::size_t
X::local_iterator Итератор того же типа, что и X::iterator, но который может
				использоваться только внутри одиночной области.
X::const_local_iterator Итератор того же типа, что и X::const_iterator, но который
может использоваться только внутри одиночной области
X::mapped_tуре	Т — тип связанных данных (только тар и multітар)

	Функциональные объекты (функторы).
 Функтор — это любой объект, который может использоваться с операцией () в манере, 
подобной функции. Это включает нормальные имена функций, указатели на функции и 
объекты классов, с перегруженной операцией () — т.е. классы, для которых определена
функция operator()(). Например, можно было бы определить такой класс: */
class Linear
{
private:
	double slope;
	double y0;
public:
	Linear (double sl_ = 1, double y_ = 0) : slope(sl_), y0(y_) {}
	double operator()(double x) { return y0 + slope * x; }
};
// Тогда перегруженная операция () позволит использовать объекты Linear подобно функциям:
Linear f1;
Linear f2(2.5, 10.0);
double y1 = f1(12.5);	// правой частью является f1.operator() (12.5)
double y2 = f2(0.4);
/* В этом примере 'y1' вычисляется с помощью выражения 0 + 1 * 12.5, а 'y2' — с 
помощью выражения 10.0 + 2.5 * 0.4. Значения 'y0' и slope в выражении y0 + slope * x
поступают из конструктора объекта, а значение 'x' — из аргумента operator()().
 Функция for_each применяла указанную функцию к каждому члену из заданного диапазона: */
for_each(books.begin(), books.end(), ShowReview);
/* В общем случае третий аргумент может быть функтором, а не обычной функцией.
В действительности возникает вопрос: как объявить третий аргумент? Его нельзя
объявлять как указатель на функцию, поскольку указатель на функцию подразумевает
наличие типов аргументов. Так как контейнер может содержать практически любой
тип, заранее не известно, какой конкретный тип аргумента должен быть использован.
Библиотека STL решает эту проблему, применяя шаблоны. Прототип for_each: */
template<class InputIterator, class Function>
Function for_each(InputIterator first, InputIterator last, Function f);
// Прототип ShowReview():
void ShowReview(const Review &);
/* В результате типом идентификатора ShowReview становится void (*)(const Review &),
поэтому именно данный тип назначается аргументу шаблона Function. При других 
вызовах функций аргумент Function мог бы представлять тип класса с перегруженной
операцией (). В любом случае код for_each() будет содержать выражение, использующее 
конструкцию f(). В примере с ShowReview() идентификатор 'f' — указатель на функцию,
а конструкция f() вызывает функцию. Если последний аргумент функции for_each() —
объект, то f() становится объектом, который вызывает свою перегруженную операцию ().
  Концепции функторов.
• генератор — это функтор, который может быть вызван без аргументов;
• унарная функция — функтор, который может быть вызван с одним аргументом;
• бинарная функция — функтор, который может быть вызван с двумя аргументами.
 Функтор, поддерживающий for_each(), должен быть унарной функцией, поскольку 
он применяется к одному элементу контейнера за раз. Приведенные концепции 
имеют уточнения:
• унарная  функция, которая возвращает булевское значение, представляет собой предикат;
• бинарная функция, которая возвращает булевское значение, представляет собой бинарный
предикат.
 Некоторые функции STL требуют предикатов либо бинарных предикатов в качестве 
аргументов. Например версия sort(), которая в третьем аргументе принимает 
бинарный предикат: */
bool WorseThan(const Review & r1, const Review & r2);
sort(books.begin(), books.end(), WorseThan);
/* Шаблон list имеет функцию-член removeif(), которая принимает предикат в
качестве аргумента. Она применяет предикат к каждому члену указанного диапазона,
удаляя те элементы, для которых предикат возвращает значение true. Например, 
следующий код удалил бы из списка все элементы, которые больше 100: */
bool tooBig(int n) { return n > 100; }
list<int> scores;
scores.remove_if(tooBig);
/* Пример показывает, где могут быть полезны классы функторов. Предположим, что 
из второго списка требуется удалить все значения, которые больше 200. Было бы 
неплохо, если бы функции tooBig() можно было передать граничное значение, чтобы 
использовать ее с различными значениями, но предикат принимает только один аргумент.
Однако если Вы проектируете класс TooBig, то для передачи дополнительной информации
вместо аргументов функции можно применять члены класса: */
template<class T>
class TooBig
{
private:
	Т cutoff;
public:
	TooBig(const T & t) : cutoff(t) {}
	bool operator()(const T & v) { return v > cutoff; }
};
/* Здесь одно значение (v) передается как аргумент функции, а второй аргумент
(cutoff) устанавливается конструктором класса. Располагая таким определением,
можно инициализировать разные объекты TooBig разными граничными значениями
для их использования в вызовах remove_if(). */
#include <iostream>			// functor.cpp -- использование класса functor
#include <list>
#include <iterator>
#include <algorithm>
template<class T>           // класс функтора определяет operator()()
class TooBig
{
private:
    T cutoff;
public:
    TooBig(const T & t) : cutoff(t) {}
    bool operator()(const T & v) { return v > cutoff; }
};
void outint(int n) { std::cout << n << " "; }
int main()
{
    using std::list;
    using std::cout;
    using std::endl;
    TooBig<int> f100(100);					// предельное значение = 100
    int vals[10] = {50, 100, 90, 180, 60, 210, 415, 88, 188, 201};
    list<int> yadayada(vals, vals + 10);		// конструктор диапазона
    list<int> etcetera(vals, vals + 10);
//  Вместо этого в C++11 можно использовать следующий код:
//  list<int> yadayada = {50, 100, 90, 180, 60, 210, 415, 88, 188, 201};
//  list<int> etcetera {50, 100, 90, 180, 60, 210, 415, 88, 188, 201};
    cout << "Original lists:\n";
    for_each(yadayada.begin(), yadayada.end(), outint);
    cout << endl;
    for_each(etcetera.begin(), etcetera.end(), outint);
    cout << endl;
    yadayada.remove_if(f100);				// использование именованного функционального объекта
    etcetera.remove_if(TooBig<int>(200));	// конструирование функционального объекта
    cout << "Trimmed lists:\n";				// усеченные списки
    for_each(yadayada.begin(), yadayada.end(), outint);	// не больше 100
    cout << endl;
    for_each(etcetera.begin(), etcetera.end(), outint);	// не больше 200
    cout << endl;
    return 0;
}
/* Один из функторов (f100) является объявленным объектом, а второй (TooBig<int>(200)) —
анонимным объектом, который создан вызовом конструктора. 
Предположим, что имеется шаблонная функция с двумя аргументами: */
template <class T>
bool tooBig (const T & val, const T & lim) {	 return val > lim; }
// Чтобы преобразовать ее в функциональный объект с одним аргументом, можно использовать класс:
template<class T>
class TooBig2
{
private:
	Т cutoff;
public:
	TooBig2(const T & t) : cutoff(t) {}
	bool operator()(const T & v) { return tooBig<T>(v, cutoff); }
};
// Это значит, что можно написать следующий код:
TooBig2<int> tB100(100);
int x;
cin >> х;
if(tB100(x))		// то же что и if(tooBig(x, 100))
	...
/* Таким образом, вызов tB100(100) эквивалентен tooBig(x, 100), но функция с
двумя аргументами преобразуется в функциональный объект с одним аргументом, а
второй аргумент служит для конструирования функционального объекта. Короче 
говоря, функтор TooBig2 — это адаптер функции, приспосабливающий функцию к 
требованиям другого интерфейса.
  Предопределенные функторы.
 Библиотека STL определяет несколько элементарных функторов. Они выполняют
такие действия, как сложение двух значений и проверка двух значений на предмет
равенства. Функторы предназначены для оказания поддержки тем функциям STL, 
которые принимают функции в качестве аргументов. Для примера рассмотрим функцию
transform(). Она имеет две версии. Первая принимает четыре аргумента. Из них
первые два — итераторы, которые задают диапазон контейнера. Третий аргумент — 
это итератор, указывающий место помещения копии результата. И последний — функтор,
который применяется к каждому элементу диапазона для создания каждого нового 
результирующего элемента.*/
const int LIM = 5;
double arr1[LIM] = {36, 39, 42, 45, 48};
vector<double> gr8(arr1, arr1 + LIM);
ostream_iterator<double, char> out(cout, " ");
transform(gr8.begin(), gr8.end(), out, sqrt); /* вычисляет квадратный корень 
каждого элемента и отправляет результирующее значение в выходной поток.
Итератор места назначения может указывать на исходный диапазон. Например, замена
в этом примере аргумента out аргументом gr8.begin() привела бы к копированию 
новых значений поверх старых. Применяемый функтор должен быть таким, который 
работает с одним аргументом.
 Вторая версия использует функцию, которая принимает два аргумента, применяя
функцию к одному элементу из каждого их двух диапазонов. Она принимает 
дополнительный аргумент, который является третьим по порядку и идентифицирует начало
второго диапазона. Например, если бы 'm8' был вторым объектом vector<double> и
функция mean(double, double) возвращала среднее значение двух значений, то: */
transform(gr8.begin(), gr8.end(), m8.begin(), out, mean); /* выводит среднее значение
												каждой пары значений из 'gr8' и 'm8'.
 Теперь предположим, что требуется сложить два массива. Операцию '+' использовать
в качестве аргумента нельзя, потому что для типа double она является встроенной 
операцией, а не функцией. Можно было бы определить функцию для сложения двух чисел: */
double add (double x, double у) { return x + у; }
transform(gr8.begin(), gr8.end(), m8.begin(), out, add);
/* Но тогда пришлось бы определять отдельную функцию для каждого типа. Лучше
определить шаблон, за исключением тех случаев, когда библиотека STL уже содержит
его. Заголовочный файл <functional> определяет несколько функциональных объектов 
класса шаблона, в том числе plus<>().Применение класса plus<> для простого сложения
возможно, хотя и неудобно: */
#include <functional>
plus<double> add;			// создание объекта plus<double>
double у = add(2.2, 3.4);	// использование plus<double>::operator()()
// Однако проще предоставить функциональный объект в виде аргумента:
transform(gr8.begin(), gr8.end(), m8.begin(), out, plus<double>());
/* Вместо создания именованного объекта с помощью конструктора plus<double> 
создается функтор для выполнения сложения. Круглые скобки указывают вызов 
конструктора по умолчанию, который передает сконструированный функциональный
объект функции transform().
 Библиотека STL предлагает эквивалентные функторы для всех встроенных 
арифметических, реляционных и логических операций. Их можно использовать со 
встроенными типами C++ или любым определенным пользователем типом, который 
перегружает соответствующую операцию. Операции и их адаптируемые эквиваленты-функторы:
Операция			Эквивалент-функтор:
	+				plus
	-				minus
	*				multiplies
	/				divides
	%				modulus
	-				negate
	==				equal_to
	!=				not_equal_to
	>				greater
	<				less
	>=				greater_equal
	<=				less_equal
	&&				logical_and
	||				logical_or
	!				logical not
  Адаптируемые функторы и функциональные адаптеры.
 Фактически библиотека STL использует пять связанных концепций: 
адаптируемые генераторы, адаптируемые унарные функции, адаптируемые бинарные
функции, адаптируемые предикаты и адаптируемые бинарные предикаты.
Адаптируемым функтор делает тот факт, что он использует члены typedef, указывающие
типы их аргументов и тип возвращаемых значений. Эти члены называются result_type 
(тип результата), first_argument_type (тип первого аргумента) и second_argument_type
(тип второго аргумента) и представляют именно то, что подразумевают их имена.
Например, возвращаемый тип объекта plus<int> указан как plus<int>::result_type, 
и он должен служить typedef для int. Важность адаптируемости функтора в том, что 
тогда он может применяться объектами функционального адаптера, который исходит из 
существования этих членов typedef. Например, функция с аргументом, который является
адаптируемым функтором, может использовать член result_type для объявления переменной,
соответствующей возвращаемому типу функции. STL предоставляет классы функциональных
адаптеров, использующих эти средства. Например, предположим, что каждый элемент 
вектора 'gr8' нужно умножить на '2.5'. В этом случае можно применить версию transform()
с аргументом — унарной функцией, которая подобна показанной в примере ранее: */
transform(gr8.begin(), gr8.end(), out, sqrt);
/* Функтор multiplies() может выполнять умножение, но это — бинарная функция.
Поэтому необходим адаптер функции, который преобразует функтор с двумя аргументами 
в функтор с одним аргументом. Приведенный ранее пример с TooBig2 демонстрирует один
способ сделать это, но STL автоматизирует этот процесс с помощью классов binder1st 
и binder2nd, которые преобразуют адаптируемые бинарные функции в адаптируемые 
унарные функции. Предположим, что имеется адаптируемый бинарный функциональный объект 
f2(). Можно создать объект binder1st, который привязывает определенное значение по 
имени 'ѵаl', чтобы оно использовалось в качестве первого аргумента f2(): */
binder1st(f2, val) f1;
/* Тогда вызов f1(x) с его единственным аргументом возвратит то же значение, что и
f2() с 'val' в качестве его первого аргумента и аргументом функции f1() в качестве 
второго аргумента. То есть f1(х) эквивалентна f2(val, x), за исключением того,
что это унарная, а не бинарная функция. Иными словами, функция f2() адаптирована.
Подобное возможно, только если f2() — адаптируемая функция. STL предлагает 
функцию bind1st() для упрощения работы с классом binder1st. Ей передается имя 
функции и значение, используемое для создания объекта binder1st, а она возвращает 
объект этого типа. Например, бинарную функцию multiplies() можно преобразовать в 
унарную, которая умножает свой аргумент на '2.5'. Для этого достаточно написать: */
bind1st(multiplies<double>(), 2.5)
// Решение по умножению каждого элемента gr8 на '2.5' и отображению результатов:
transform(gr8.begin(), gr8.end(), out, bind1st(multiplies<double>(), 2.5));
/* Класс binder2nd аналогичен рассмотренному, за исключением того, что он 
присваивает константу второму аргументу вместо первого. Он имеет вспомогательную
функцию bind2nd, которая работает аналогично bind1st. */
#include <iostream>				// funadap.cpp -- использование адаптеров функций
#include <vector>
#include <iterator>
#include <algorithm>
#include <functional>
void Show(double);
const int LIM = 6;
int main()
{
    using std::cout;
    using std::vector;
    double arr1[LIM] = {28, 29, 30, 35, 38, 59};
    double arr2[LIM] = {63, 65, 69, 75, 80, 99};
    vector<double> gr8(arr1, arr1 + LIM);
    vector<double> m8(arr2, arr2 + LIM);
    cout.setf(std::ios_base::fixed);
    cout.precision(1);
    cout << "gr8:\t";
    for_each(gr8.begin(), gr8.end(), Show);     // отображение gr8
    cout << std::endl;
    cout << "m8: \t";
    for_each(m8.begin(), m8.end(), Show);       // отображение m8
    cout << std::endl;
    vector<double> sum(LIM);
    transform(gr8.begin(), gr8.end(), m8.begin(), sum.begin(), std::plus<double>());	// сложение gr8 + m8
    cout << "sum:\t";
    for_each(sum.begin(), sum.end(), Show);
    cout << std::endl;
    vector<double> prod(LIM);														// умножение gr8 * 2.5
    transform(gr8.begin(), gr8.end(), prod.begin(), std::bind1st(std::multiplies<double>(), 2.5));
    cout << "prod:\t";
    for_each(prod.begin(), prod.end(), Show);
    cout << std::endl;
    return 0; 
}
void Show(double v)
{
    std::cout.width(6);
    std::cout << v << ' '; 
}
/*  Лямбда-функции.
С++11 предоставляет альтернативу функциональным указателям и функторам —
лямбда-выражения. */
[&count](int x) { count += (х % 13 == 0); } // лямбда-функция
/*  Как работают указатели на функции, функторы и лямбда.
 Предположим, что необходимо сгенерировать список случайных целых чисел
и выяснить, сколько из них являются кратными '3', а сколько — кратными '13'.
Генерация списка исключительно прямолинейна. Один из вариантов предполагает 
использование массива vector<int> для хранения чисел и STL-алгоритма generate() —
для заполнения массива случайными числами: */
#include <vector>
#include <algorithm>
#include <cmath>
std::vector<int> numbers(1000);
std::generate(vector.begin(), vector.end(), std::rand);
/* Функция generate() принимает диапазон, указанный первыми двумя аргументами, 
и устанавливает каждый элемент в значение, возвращаемое третьим аргументом,
который представляет собой функциональный объект, не принимающий аргументов. 
В этом случае функциональный объект — это указатель на стандартную функцию rand().
С помощью алгоритма count_if() несложно подсчитать количество элементов, кратных '3'.
В первых двух аргументах должен быть указан диапазон, как это делалось для generate().
Третий аргумент должен быть функциональным объектом, возвращающим true или false. 
Затем функция count_if() подсчитывает все элементы, для которых функциональный объект
возвращает true. Для нахождения элементов, кратных '3', можно использовать следующее 
определение функции: */
bool f3(int x) { return x % 3 == 0; }	// если делится без остатка, то true
// Аналогично, для нахождения элементов, кратных '13':
bool f13(int x) { return x % 13 == 0; }	// если делится без остатка, то true
// Имея эти определения, можно подсчитать элементы:
int count3  = std::count_if(numbers.begin(), numbers.end(), f3);
cout << "Count of numbers divisible by 3: "  << count3  << '\n';	// количество элементов, кратных '3'
int count13 = std::count_if(numbers.begin(), numbers.end(), f13);
cout << "Count of numbers divisible by 13: " << count13 << "\n\n";	// количество элементов, кратных '13'
/* Теперь давайте рассмотрим, как решить ту же задачу с использованием функтора.
Преимущество использования функтора в рассматриваемом примере заключается в том,
что один и тот же функтор подходит для решения обеих задач подсчета. */
class f_mod
{
private:
	int dv;
public:
	f_mod(int d = 1) : dv(d) {}
	bool operator()(int x) { return x % dv == 0; } // если делится без остатка, то true
};
/* С помощью конструктора можно создать объект f_mod, хранящий определенное 
целочисленное значение: */
f_mod obj(3);				// f_mod.dv устанавливается в '3'
// Этот объект может использовать метод operator() для возврата значения bool:
bool is_div_by_3 = obj(7);	// то же, что и obj.operator()(7)
// Сам конструктор может передаваться в качестве аргумента в такие функции, как count_if():
count3 = std::count_if(numbers.begin(), numbers.end(), f_mod(3));
/* Аргумент f_mod(3) создает объект, хранящий значение 3, a count_if() 
применяет этот созданный объект для вызова метода operator()(), устанавливая параметр
'х' равным некоторому элементу из numbers. Для подсчета количества чисел, кратных не
'3', а '13', в качестве третьего аргумента должно указываться f_mod(13).
 И, наконец, проанализируем подход с лямбда. Его название происходит от лямбда-
вычислений — математической системы для определения и применения функций. Эта
система позволяет использовать анонимные функции — т.е. позволяет обойтись без
имен функций. В контексте C++11 определение анонимной функции (лямбда) можно
применять в качестве аргумента для функций, ожидающих указатель на функцию или
функтор. Лямбда-выражение, соответствующее функции f3(), выглядит следующим образом: */
[](int x) { return x % 3 == 0; }			// если делится без остатка, то true
// Оно очень похоже на определение f3():
bool f3(int x) { return x % 3 == 0; }	// если делится без остатка, то true
/* Два отличия заключаются в том, что имя функции заменяется парой квадратных
скобок [], а возвращаемый тип не объявляется. Вместо этого возвращаемый тип будет
выведен decltype из возвращаемого значения, в данном случае им будет bool. Если
лямбда не имеет оператора return, выводимым типом оказывается void. В рассматриваемом
примере лямбда будет использоваться следующим образом: */
count3 = std::count_if(numbers.begin(), numbers.end(), [](int x){ return x % 3 == 0; });
/* Таким образом, полное лямбда-выражение применяется так же, как указатель или
конструктор функтора. Автоматическое выведение типа для лямбда-выражений работает 
только в ситуациях, когда тело содержит одиночный оператор return. В противном 
случае необходимо использовать синтаксис хвостового возвращаемого типа: */
[](double х)->double { int у = х; return х - у; } // возвращаемым типом является double
// lambda0.cpp -- использование лямбда-выражений:
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
#include <ctime>
const long Size1 = 39L;
const long Size2 = 100 * Size1;
const long Size3 = 100 * Size2;
bool f3(int x)  { return x % 3  == 0; }	// если делится без остатка, то true
bool f13(int x) { return x % 13 == 0; }	// если делится без остатка, то true
int main()
{
    using std::cout;
    std::vector<int> numbers(Size1);
    std::srand(std::time(0));
    std::generate(numbers.begin(), numbers.end(), std::rand);
// Использование указателей на функции:
    cout << "Sample size = " << Size1 << '\n';
    int count3 = std::count_if(numbers.begin(), numbers.end(), f3);		// количество чисел, кратных '3'
    cout << "Count of numbers divisible by 3: "  << count3  << '\n';
    int count13 = std::count_if(numbers.begin(), numbers.end(), f13);	// количество чисел, кратных '13'
    cout << "Count of numbers divisible by 13: " << count13 << "\n\n";
    numbers.resize(Size2);												// Увеличение размера numbers
    std::generate(numbers.begin(), numbers.end(), std::rand);
    cout << "Sample size = " << Size2 << '\n';							// размер выборки
// Использование функтора:
    class f_mod
    {
    private:
        int dv;
    public:
        f_mod(int d = 1) : dv(d) {}
        bool operator()(int x) { return x % dv == 0; }				// если делится без остатка, то true
    };
    count3 = std::count_if(numbers.begin(), numbers.end(), f_mod(3));		// количество чисел, кратных '3'
    cout << "Count of numbers divisible by 3: "  << count3  << '\n';
    count13 = std::count_if(numbers.begin(), numbers.end(), f_mod(13));	// количество чисел, кратных '13'
    cout << "Count of numbers divisible by 13: " << count13 << "\n\n";
    numbers.resize(Size3);												// повторное увеличение размера numbers
    std::generate(numbers.begin(), numbers.end(), std::rand);
    cout << "Sample size = " << Size3 << '\n';							// размер выборки
// Использование лямбда:
    count3  = std::count_if(numbers.begin(), numbers.end(), [](int x) { return x % 3  == 0; });
    cout << "Count of numbers divisible by 3: "  << count3  << '\n';		// количество чисел, кратных '3'
    count13 = std::count_if(numbers.begin(), numbers.end(), [](int x) { return x % 13 == 0; });
    cout << "Count of numbers divisible by 13: " << count13 << '\n';		// количество чисел, кратных '13'
    return 0;
}
/*  Характеристики лямбда-функций: близость, краткость, эффективность и 
возможность.
 Близость: Определения располагаются близко к месту, где они используются.
Определение лямбда-функций производится в месте их применения. Обычные функции 
хуже, т.к. функции не могут определяться внутри других функций, поэтому возможно,
что определение будет располагаться далеко от точки использования. Функторы 
достаточно хороши, потому что класс, в том числе и класс функтора, может быть 
определен внутри функции, и это позволяет располагать определение близко к месту
применения.
 Краткость: Код функтора более многословный, чем код эквивалентной функции или 
лямбда. Функции и лямбда примерно одинаково краткие. Одним очевидным исключением 
является ситуация, когда лямбда-функция должна использоваться дважды: */
count1 = std::count_if(n1.begin(), n1.end(), [](int x) { return x % 3 == 0; });
count2 = std::count_if(n2.begin(), n2.end(), [](int x) { return x % 3 == 0; });
/* Но писать код лямбда-функции дважды не понадобится. В сущности можно предусмотреть
имя для анонимной лямбда-функции и затем два раза воспользоваться этим именем: */
auto mod3 = [](int x) { return x % 3 == 0; } // mod3 — это имя для лямбда
count1 = std::count_if(n1.begin(), n1.end(), mod3);
// Эту больше не анонимную лямбда-функцию можно даже применять как обычную функцию:
bool result = mod3(z);	// результат равен true, если z % 3 == 0
/* В отличие от обычной функции, именованная лямбда-функция может быть определена 
внутри функции. Действительным типом 'mod3' будет некоторый зависящий от реализации 
тип, который компилятор применяет для отслеживания лямбда-функций.
 Эффективность: Зависит от того, что именно компилятор выберет для встраивания.
В данном случае эффективности подхода с указателем на функцию препятствует тот факт,
что компиляторы традиционно не встраивают функцию, адрес которой используется, 
поскольку концепция адреса функции означает отсутствие встраивания. Относительно 
функторов и лямбда-функций явное противоречие со встраиванием отсутствует.
 Возможности: Лямбда-функция может обращаться по имени к любой автоматической 
переменной в области видимости. Используемые переменные захватываются путем 
перечисления их имен внутри квадратных скобок. Когда указано только имя, например,
[z], доступ к переменной производится по значению. Если имя предваряется символом '&',
как в [&count], доступ к переменной осуществляется по ссылке. Применение [&] 
предоставляет доступ ко всем автоматическим переменным по ссылке, а [=] — по значению.
Можно также смешивать и сочетать. Например, [ted, &ed] обеспечит доступ к ted по 
значению, а к 'ed' — по ссылке; [&, ted] предоставит доступ к ted по значению, а ко 
всем остальным автоматическим переменным — по ссылке; [=, &ed] обеспечит доступ к 'ed'
по ссылке, а к остальным автоматическим переменным — по значению. Можно заменить код: */
int count13;
count13 = std::count_if(numbers.begin(), numbers.end(), [](int x) { return x % 13 ==0; });
// следующим:
int count13 = 0;
std::for_each(numbers.begin(), numbers.end(), [&count13](int x) { count13 += x % 13 == 0; });
/* Выражение х % 13 == 0 вычисляется как true, если значение 'x' кратно '13', и при
добавлении к 'count13' значение true преобразуется в '1'. Аналогично, значение false
преобразуется в '0'. После того, как for_each() применит лямбда-выражение ко всем 
элементам numbers, в count13 будет храниться количество элементов, кратных '13'.
Этот прием можно использовать для подсчета количества элементов, кратных '3', и
элементов, кратных '13', написав единственное лямбда-выражение: */
int count3  = 0;
int count13 = 0;
std::for_each(numbers.begin(), numbers.end(), [&](int x){count3 += x % 3 == 0; count13 += x % 13 == 0;});
/* На этот раз с помощью [&] все автоматически переменные, включая count3 и count13,
сделаны доступными лямбда-выражению. */ 
#include <iostream>				// lambda1.cpp -- использование захваченных переменных
#include <vector>
#include <algorithm>
#include <cmath>
#include <ctime>
const long Size = 390000L;
int main()
{
    using std::cout;
    std::vector<int> numbers(Size);
    std::srand(std::time(0));
    std::generate(numbers.begin(), numbers.end(), std::rand);
    cout << "Sample size = " << Size << '\n';							// размер выборки
// Использование лямбда-функций:
    int count3 = std::count_if(numbers.begin(), numbers.end(), [](int x) { return x % 3 == 0; });
    cout << "Count of numbers divisible by 3: "  << count3  << '\n';	// количество чисел, кратных '3'
    int count13 = 0;
    std::for_each(numbers.begin(), numbers.end(), [&count13](int x) { count13 += x % 13 == 0; });
    cout << "Count of numbers divisible by 13: " << count13 << '\n';	// количество чисел, кратных '13'
// Использование одиночного лямбда-выражения:
    count3 = count13 = 0;
    std::for_each(numbers.begin(), numbers.end(), [&](int x){count3 += x % 3 == 0; count13 += x % 13 == 0;});
    cout << "Count of numbers divisible by 3: "  << count3  << '\n';	// количество чисел, кратных '3'
    cout << "Count of numbers divisible by 13: " << count13 << '\n';	// количество чисел, кратных '13'
    return 0;
}
/* Оба подхода (две отдельных лямбда-функции и одиночное лямбда-выражение) в этой
программе приводят к одним и тем же результатам. Типичной лямбда-функцией будет 
проверочное или сравнивающее выражение, которое может быть записано как единственный
оператор return. Это сохраняет лямбда-функцию короткой и простой для понимания, а 
также делает возможным автоматическое выведение типа возвращаемого значения. 
	Алгоритмы.
 Существуют два основных общих проектных компонента функций алгоритмов. Во-первых,
они применяют шаблоны для предоставления обобщенных типов. Во-вторых, они используют
итераторы для обеспечения обобщенного представления доступа к данным в контейнере.
Таким образом, функция сору() может работать с контейнером, который содержит значения 
типа double в массиве, с контейнером, содержащим значения string в связном списке, 
либо с контейнером, который хранит определенные пользователем объекты в древовидной 
структуре, как это делает set. Поскольку указатели — это специальный случай итераторов,
функции STL, подобные сору(), могут применяться с обычными массивами. Операцию '=='
можно применять для сравнения разных видов контейнеров — например, deque
и vector. Это возможно потому, что перегруженная операция '==' для контейнеров
применяет итераторы для сравнения содержимого, и в результате объекты deque и
vector считаются эквивалентными, если они имеют одно и то же содержимое в 
одном и том же порядке.
  Группы алгоритмов:
• немодифицирующие последовательные операции;
• модифицирующие последовательные операции;
• сортирующие и связанные с ними операции;
• обобщенные числовые операции.
 Первые три группы описаны в заголовочном файле <algorithm> (бывший algo.h),
а четвертая группа, будучи специально ориентированной на числовые данные, имеет
собственный заголовочный файл <numeric> (раньше они также были в algo.h).
 Немодифицирующие последовательные операции обрабатывают каждый элемент в диапазоне
и оставляют контейнер без изменений. Например: find() и for_each().
 Модифицирующие последовательные операции также обрабатывают каждый элемент в контейнере,
но они могут изменить содержимое контейнера. Изменения могут касаться значений либо 
порядка, в котором они сохранены. Например: transform(), random_shuffle() и copy().
 Сортирующие и связанные с ними операции включают некоторые сортирующие функции 
(в т.ч. sort()), а также ряд других функций, включая операции с наборами (множествами).
 Числовые операции включают функции для суммирования содержимого диапазона, вычисления
внутреннего произведения двух контейнеров, подсчета частичных сумм и вычисления разностей
соседних элементов. Они характерны для массивов, поэтому vector — это контейнер, который
наиболее вероятно будет использован с ними.
  Основные свойства алгоритмов.
 Прототипы функций указывают предположения, сделанные относительно итераторов.
Например, функция сору() имеет следующий прототип: */
template<class InputIterator, class OutputIterator>
OutputIterator copy(InputIterator first, InputIterator last, OutputIterator result);
/* Это объявление указывает, что параметрами диапазона должны быть входные итераторы 
или более мощные итераторы, и что итератором, указывающим место помещения результата,
должен быть выходной или более мощный итератор.
 Один из способов классификации алгоритмов основан на том, куда должен быть помещен 
результат работы алгоритма. Некоторые алгоритмы делают свою работу на месте, другие 
создают копии. Например, по завершении работы функции sort() результат занимает то же
местоположение, которое занимали исходные данные. Поэтому sort() — алгоритм "по месту".
Функция сору() отправляет результат своей работы в другое местоположение, поэтому она 
является копирующим алгоритмом. Функция transform() может делать и то, и другое. 
Подобно сору(), она использует выходной итератор для указания места помещения результата.
Но, в отличие от сору(), transform() позволяет выходному итератору указывать позицию
внутри входного диапазона, поэтому она может копировать трансформированные значения
поверх исходных.
 Некоторые алгоритмы имеют две версии: "по месту" и копирующую. В соответствии
с соглашением STL, к имени копирующей версии добавляется _сору. Последняя версия
принимает дополнительный параметр — выходной итератор для указания места копирования 
результата. Например, существует функция replace() с таким прототипом: */
template<class ForwardIterator, class T>
void replace(ForwardIterator first, ForwardIterator last, const T & old_value, const T & new_value);
/* Она заменяет экземпляр old_value экземпляром new_value. Это происходит на месте.
Поскольку данный алгоритм выполняет и чтение, и запись элементов контейнера, типом 
итератора должен быть ForwardIterator либо более мощный. */
template<class InputIterator, class OutputIterator, class T>
OutputIterator replace_copy(InputIterator first, InputIterator last, OutputIterator result,
							const T & old_value, const T & new_value);
/* На этот раз результирующие данные копируются в новое место, заданное result,
поэтому для указания диапазона вполне достаточно входного итератора, выполняющего 
только чтение. Возвращаемым типом функции replace_copy() является Outputlterator. 
В соответствии с принятым соглашением, копирующие алгоритмы возвращают итератор, 
который указывает на позицию, следующую за последним скопированным значением.
 Еще одна часто используемая разновидность — функции, имеющие версию, которая 
выполняет действие условно, в зависимости от результата применения функции к элементу 
контейнера. Как правило, к именам этих версий добавляется _if. Например, функция 
replace_if() заменяет старое значение новым, если применение функции к старому значению
возвращает true: */
template<class ForwardIterator, class Predicate, class T>
void replace_if(ForwardIterator first, ForwardIterator last, Predicate pred, const T & new_value);
/* Предикат — это унарная функция, возвращающая значение bool.
Существует также версия по имени replace_copy_if(). STL выбирает имя Predicate, чтобы 
напомнить пользователю, что действительный аргумент должен быть моделью концепции 
Predicate.Использование неподходящего вида итератора может привести к длинному списку 
сообщений об ошибках, поскольку компилятор будет пытаться создать экземпляр шаблона.
  Библиотека STL и класс string.
 Перестановка — это изменение порядка следования элементов в контейнере. Алгоритм 
next_permutation() преобразует содержимое диапазона в следующую перестановку; в 
случае строки перестановки выполняются в возрастающем алфавитном порядке. Алгоритм 
возвращает true при успешном продолжении и false — в ситуации, когда порядок 
следования элементов в диапазоне является последним из возможных. Чтобы получить 
все перестановки диапазона, следует начать с элементов, расположенных в самом первом
возможном порядке, и с этой целью в программе используется алгоритм sort() из 
библиотеки STL. */
#include <iostream>				// strgstl.cpp -- применение STL к строке
#include <string>
#include <algorithm>
int main()
{
    using std::cout;
    std::string letters;
    cout << "Enter the letter grouping (quit to quit): ";
    while (std::cin >> letters && letters != "quit")
    {
        cout << "Permutations of " << letters << std::endl;
        std::sort(letters.begin(), letters.end());
        cout << letters << std::endl;
        while (next_permutation(letters.begin(), letters.end()))
            cout << letters << std::endl;
        cout << "Enter next sequence (quit to quit): ";
    }
    cout << "Done.\n";
    return 0;
}
/*  Сравнение функций и методов контейнеров.
 Иногда возникает ситуация, когда требуется произвести выбор между использованием 
метода STL либо функции STL. Обычно лучшим вариантом является метод. Во-первых, 
он должен быть лучше оптимизирован для конкретного контейнера. Во-вторых, будучи 
функцией-членом, он может пользоваться средствами управления памятью класса шаблона
и при необходимости изменять размер контейнера. Предположим, например, что имеется 
список чисел, и нужно удалить из него все экземпляры определенного значения, скажем, 
'4'. Если 'lа' — это объект list<int>, можно применить метод remove() списка: */
la.remove(4);	// удаление всех четверок из списка
/* После вызова этого метода все элементы со значением '4' удаляются из списка и
размер списка автоматически изменяется. В STL существует также алгоритм remove(). 
Вместо того чтобы вызываться объектом, он принимает аргументы, задающие диапазон.
Поэтому, если lb — это объект list<int>, то: */
remove (lb.begin(), lb.end(), 4);
/* Поскольку функция remove() не является членом класса, она не может изменить 
размер списка. Вместо этого она удостоверяется, что все не удаленные элементы 
располагаются в начале списка, и возвращает итератор, указывающий на новое значение
за концом списка. Затем этот итератор можно применять для корректировки размеров 
списка. Например, метод erase() списка можно использовать для удаления диапазона, 
который описывает более не нужную часть списка. */
#include <iostream>				// listrmv.cpp -- применение STL к строке
#include <list>
#include <algorithm>
void Show(int);
const int LIM = 10;
int main()
{
    using namespace std;
    int ar[LIM] = {4, 5, 4, 2, 2, 3, 4, 8, 1, 4};
    list<int> la(ar, ar + LIM);
    list<int> lb(la);
    cout << "Original list contents:\n\t";              // вывод содержимого исходного списка
    for_each(la.begin(), la.end(), Show);
    cout << endl;
    la.remove(4);   // метод remove() уменьшает размер списка 'la' с 10 до 6 элементов.
    cout << "After using the remove() method:\n";       // список после использования метода remove()
    cout << "la:\t";
    for_each(la.begin(), la.end(), Show);
    cout << endl;
    list<int>::iterator last;
    last = remove(lb.begin(), lb.end(), 4);	// после вызова функции remove() список 'lb' по-прежнему 
                                            // содержит 10 элементов.
    cout << "After using the remove() function:\n";     // список после использования функции remove()
    cout << "lb:\t";
    for_each(lb.begin(), lb.end(), Show);
    cout << endl;
    lb.erase(last, lb.end());
    cout << "After using the erase() method:\n";        // список после использования метода erase()
    cout << "lb:\t";
    for_each(lb.begin(), lb.end(), Show);
    cout << endl;
    return 0;
}
void Show(int v) { std::cout << v << ' '; }
/* Хотя обычно методы подходят лучше, обычные функции более универсальны. Их можно 
использовать с массивами и объектами string, равно как и с контейнерами STL. И их 
можно применять с контейнерами смешанных типов, например, для сохранения данных 
контейнера vector в списке или наборе.
  Использование STL.
 Предположим, требуется написать программу, которая дает возможность пользователю 
вводить слова. В конце работы программы записать эти слова, как они были введены, 
получить список использованных слов алфавитном порядке (без учета регистра букв) 
и вывести количество случаев ввода каждого слова. Можно создать объект vector<string>
и применить push_back() для добавления введенных слов в вектор: */
vector<string> words;
string input;
while (cin >> input && input != "quit")
	words.push_back(input);
/* Затем воспользоваться sort() для получения алфавитного списка слов и unique(),
но такой подход ведет к перезаписи исходных данных, поскольку sort() — алгоритм, 
работающий "по месту". Существует более простой способ, можно создать объект set<string>
и скопировать (используя итератор вставки) слова из вектора в набор. Набор автоматически
сортирует свое содержимое, что исключает необходимость вызова sort(). Кроме того, набор 
хранит только по одной копии каждого ключа, поэтому не придется вызывать и unique(). 
Но спецификация требует игнорировать регистр! Один из способов обеспечения этого —
использование transform() вместо сору() для копирования данных из вектора в набор. В 
качестве функции трансформации можно применить такую, которая преобразует строки в 
нижний регистр: */
set<string> wordset;
transform(words.begin(), words.end(), insert_iterator< set<string> >(wordset, wordset.begin()), ToLower);
/* Написание функции ToLower() не представляет сложности. Нужно с помощью transform()
применить функцию tolower() к каждому элементу строки, указывая строку и в качестве 
источника, и в качестве места назначения. Объекты string также могут использовать 
функции STL. */
string & ToLower(string & st)
{
	transfarm(st.begin(), st.end(), st.begin(), tolower);
	return st;
}
/* Одна из потенциальных проблем состоит в том, что функция tolower() определяется 
как int tolower(int), а некоторые компиляторы требуют, чтобы функция соответствовала
типу элемента, которым является char. Одно из возможных решений — замена tolower на
toLower и предоставление следующего определения: */
char toLower(char ch) { return tolower(ch); }
/* Для получения количества появлений каждого слова в строке ввода можно применить 
функцию count(). Она принимает в качестве аргументов диапазон и значение, а возвращает
количество появлений этого значения в диапазоне. Можно воспользоваться объектом vector,
чтобы задать диапазон, и объектом set, чтобы передать список слов для подсчета. То 
есть для каждого слова в наборе можно подсчитать количество его появлений в векторе. 
Чтобы результаты подсчета оставались связанными с соответствующим словом, слово и 
количество можно сохранить в виде объекта pair<const string, int> внутри объекта map. 
Слово будет ключом (только одной копией), а количество — значением. Это можно сделать 
в единственном цикле: */
map<string, int> wordmap;
set<string>::iterator si;
for (si = wordset.begin(); si != wordset.end(); si++)
	wordmap.insert(pair<string, int>(*si, count(words.begin(), words.end(), *si)));
/* Поскольку контейнер wordset содержит все ключи, используемые wordmap, следующий
код может выступать альтернативным способом для сохранения результатов: */
for (si = wordset.begin(); si != wordset.end(); si++)
	wordmap[*si] = count(words.begin(), words.end(), *si);
/* Так как 'si' указывает на строку в контейнере wordset, '*si' — это строка, которая
может служить ключом для wordmap. Этот код помещает ключи и значения в карту wordmap.
Аналогично, нотацию массивов можно применить для выдачи результатов: */
for (si = wordset.begin(); si != wordset.end(); si++)
	cout << *si << ": " << wordmap[*si] << endl;
// Если ключ является недопустимым, то соответствующее ему значение будет равно 0.
#include <iostream>			// usealgo.cpp -- использование нескольких элементов STL
#include <string>
#include <vector>
#include <set>
#include <map>
#include <iterator>
#include <algorithm>
#include <cctype>
using namespace std;
char toLower(char ch) { return tolower(ch); }
string & ToLower(string & st);
void display(const string & s);
int main()
{
    vector<string> words;
    cout << "Enter words (enter quit to quit):\n";		// запрос на ввод слов
    string input;
    while (cin >> input && input != "quit")
        words.push_back(input);
    cout << "You entered the following words:\n";		// отображение введенных слов
    for_each(words.begin(), words.end(), display);
    cout << endl;
    set<string> wordset;								// Помещение слов в набор с преобр. букв в строчные
    transform(words.begin(), words.end(), insert_iterator<set<string> > (wordset, wordset.begin()), ToLower);
    cout << "\nAlphabetic list of words:\n";			// список слов в алфавитном порядке
    for_each(wordset.begin(), wordset.end(), display);
    cout << endl;
    map<string, int> wordmap;						// Помещение и частоты его помещения в карту
    set<string>::iterator si;
    for (si = wordset.begin(); si != wordset.end(); si++)
        wordmap[*si] = count(words.begin(), words.end(), *si);
    cout << "\nWord frequency:\n";					// частота появления слов
    for (si = wordset.begin(); si != wordset.end(); si++)
        cout << *si << ": " << wordmap[*si] << endl;	// Отображение содержимого карты
    return 0;
}
string & ToLower(string & st)
{
    transform(st.begin(), st.end(), st.begin(), toLower);
    return st;
}
void display(const string & s) { cout << s << " "; }
/*  Другие библиотеки.
  Заголовочный файл <complex> предоставляет шаблонный класс complex для комплексных
чисел, имеющий отдельные варианты для типов float, long и long double.
  vector, valarray и array.
 Класс vector поддерживает контейнерно-ориентированные действия вроде сортировки, 
вставки, переупорядочивания, поиска и передачи данных в другие контейнеры и другие 
манипуляции с данными. Класс шаблона valarray ориентирован на вычислительные операции,
и не является частью STL. Например, он не имеет методов push_back() и insert(), но 
предоставляет простой интуитивно понятный интерфейс для многих математических операций.
Класс array разработан в качестве замены встроенного типа массива, сочетая в себе 
компактность и эффективность типа с более удобным и безопасным интерфейсом. Имея 
фиксированный размер, array не поддерживает push_back() и insert(), но предоставляет 
ряд других методов STL. В их число входят begin(), end(), rbegin() и rend(), что 
упрощает применение алгоритмов STL к объектам array. Например: */
vector  <double>     ved1(10), ved2(10),	ved3(10);
array   <double, 10>	 vod1,     vod2,	vod3;
valarray<double>     vad1(10), vad2(10),	vad3(10);
/* Предположим, что ved1, ved2, vod1, vod2, vad1 и vad2 получили соответствующие значения.
Требуется присвоить сумму первых элементов двух массивов первому элементу третьего массива,
и т.д. Используя класс vector, необходимо было бы выполнить следующее: */
transform(ved1.begin(), ved1.end(), ved2.begin(), ved3.begin(), plus<double>());
// Это же можно сделать с классом array:
transform(vod1.begin(), vod1.end(), vod2.begin(), vod3.begin(), plus<double>());
/* Однако класс valarray перегружает все арифметические операции для работы с объектами 
valarray, поэтому нужно было использовать следующий оператор: */
vad3 = vad1 + vad2;	// операция '+' перегружена
/* Аналогично, следующий оператор приводит к тому, что каждый элемент vad3 
является произведением соответствующих элементов из vad1 и vad2: */
vad3 = vad1 * vad2;	// операция '*' перегружена
/* Допустим, что требуется заменить каждое значение массива им же, но умноженным 
на 2.5. В STL применяется следующий подход: */
transform(ved3.begin(), ved3.end(), ved3.begin(), bind1st(multiplies<double>(), 2.5));
/* Класс valarray перегружает операцию умножения объекта valarray на одиночное значение,
а также различные операции присваивания с вычислением, поэтому можно было бы воспользоваться
любым из приведенных ниже операторов: */
vad3 = 2.5 * vad3;	// операция '*' перегружена
vad3 *= 2.5;			// операция '*=' перегружена
/* Предположим, что требуется вычислить натуральный логарифм каждого элемента в массиве и
сохранить результат в соответствующем элементе второго массива. В STL применяется следующий подход: */
transform (ved1.begin(), ved1.end(), ved3.begin(), log);
/* Класс valarray перегружает обычные математически функции для принятия объекта valarray 
в качестве аргумента и возврата объекта valarray, поэтому можно использовать оператор: */
vad3 = log(vad1);	// операция log() перегружена
// Или же можно воспользоваться методом apply(), который работает для неперегруженных функций:
vad3 = vad1.apply(log);
/* Метод apply() не изменяет вызывающий объект; вместо этого он возвращает новый объект,
содержащий результирующие значения. Простота интерфейса valarray становится еще более 
очевидной при выполнении многошаговых вычислений: */
vad3 = 10.0 * ((vad1 + vad2) / 2.0 + vad1 * cos(vad2));
/* Класс valarray также предлагает метод sum(), который суммирует содержимое объекта valarray,
метод size(), подсчитывающий количество элементов, метод max(), который возвращает наибольшее
значение объекта, и метод min(), возвращающий наименьшее значение. valarray обладает явным 
преимуществом перед vector с точки зрения нотации, если речь идет о математических операциях,
однако он менее универсален. Класс valarray имеет метод resize(), но не осуществляет 
автоматического изменения размера, подобного тому, которое обеспечивает метод pushback() класса
vector. He существует никаких методов для вставки значений, выполнения поиска, сортировки и 
тому подобных действий. Т.е., класс valarray более ограничен, чем класс vector, но его более 
узкое назначение позволяет иметь намного более простой интерфейс.
Можно ли применять STL для работы с объектами valarray? Предположим, что имеется объект 
valarray<double>, содержащий 10 элементов: */
valarray<double> vad(10);
/* После того как массив заполнен числовыми значениями, можно ли применить к
нему функцию сортировки STL? Класс valarray не имеет методов begin() и end(),
так что их нельзя использовать в качестве аргументов, задающих диапазон: */
sort(vad.begin(), vad.end());	// НЕЛЬЗЯ, нет ни begin(), ни end()
/* Кроме того, vad — это объект, а не указатель, поэтому нельзя имитировать 
использование обычного массива и применять vad и vad + 10: */
sort(vad, vad + 10);				// НЕТ, vad — это объект, а не адрес
// Можно использовать операцию получения адреса:
sort(&vad[0], &vad[10]);			// может быть?
/* Но поведение операции обращения к индексу, значение которого на единицу превышает 
значение последнего индекса массива, для valarray не определено. Если от вашего кода 
зависит дорогостоящий проект, то не стоит рисковать получением подобного сбоя.
С++11 исправляет ситуацию, предоставляя шаблонные функции begin() и end(), которые 
принимают объект valarray в качестве аргумента. Поэтому вместо vad.begin() следует 
применять begin(vad). Эти функции возвращают значения, которые совместимы с требованиями 
диапазона STL: */
sort(begin(vad), end(vad));		// исправление С++11
// valvect.cpp -- сравнение vector и valarray
#include <iostream>
#include <valarray>
#include <vector>
#include <algorithm>
int main()
{
    using namespace std;
    vector<double> data;
    double temp;
    cout << "Enter numbers (<=0 to quit):\n";   // запрос на ввод положительных чисел
    while (cin >> temp && temp > 0)
        data.push_back(temp);
    sort(data.begin(), data.end());
    int size = data.size();
    valarray<double> numbers(size);
    int i;
    for (i = 0; i < size; i++)
        numbers[i] = data[i];
    valarray<double> sq_rts(size);    // создает массив значений типа double
    sq_rts = sqrt(numbers);           // вычисляет квадрат из значений numbers почленно, помещает их в sq_rts
    valarray<double> results(size);   // создает массив значений типа double
    results = numbers + 2.0 * sq_rts; // помещает в results суммы значений numbers и 2*sq_rts
    cout.setf(ios_base::fixed);
    cout.precision(4);
    for (i = 0; i < size; i++)
    {
        cout.width(8);
        cout << numbers[i] << ": ";
        cout.width(8);
        cout << results[i] << endl;
    }
    cout << "done\n";
    return 0;
}
/* Класс valarray имеет множество возможностей помимо тех, что уже были описаны. Например,
если 'numbers' — объект valarray<double>, то следующий оператор создает массив значений типа
bool, в котором vbool[i] устанавливается равным значению numbers[і] > 9, т.е. true или false:*/
valarray<bool> vbool = numbers > 9;
/* Объект класса 'slice' может использоваться в качестве индекса массива — в этом случае он
представляет не просто одно значение, а некоторый поднабор значений. Объект 'slice' 
инициализируется тремя целочисленными значениями: началом, количеством и шагом. Начало 
указывает индекс первого элемента, который должен быть выбран, количество задает число 
выбираемых элементов, а шаг представляет расстояние между соседними элементами. Например, объект, 
сконструированный как slice(1,4,3), означает выбор четырех элементов с индексами 1, 4, 7 и 10.
Другими словами, нужно начать со стартового элемента, добавить шаг для получения следующего 
элемента и т.д. до тех пор, пока не будет выбрано 4 элемента. Если, var — это объект valarray<int>,
то следующий оператор присвоит элементам 1, 4, 7 и 10 значение 10: */
var[slice(1,4,3)] = 10;	/* присваивание выбранным элементам значения '10'
Это специальное свойство индексации позволяет применять одномерный объект valarray для 
представления двумерных данных. Например, требуется представить массив из 4х строк и 3х столбцов.
Информацию можно сохранить в 12-элементном объекте valarray. Тогда объект slice(0,3,1), 
использованный в качестве индекса, представлял бы элементы  0, 1 и 2 — т.е. первую строку.
Аналогично индекс slice(0, 4, 3) представлял бы элементы 0, 3, 6 и 9 — т.е. первый столбец. */
// vslice.cpp -- использование срезов valarray
#include <iostream>
#include <valarray>
#include <cstdlib>
const int SIZE = 12;
using vint = std::valarray<int>;				// для упрощения объявлений
void show(const vint & v, int cols);
int main()
{
    using std::slice;						// из <valarray>
    using std::cout;
    vint valint(SIZE);						// представляет 4 строки по 3 элемента
    int i;
    for (i = 0; i < SIZE; ++i)
        valint[i] = std::rand() % 10;
    cout << "Original array:\n";				// исходный массив
    show(valint, 3);							// отображение в виде 3 столбцов
    vint vcol(valint[slice(1,4,3)]);			// извлечение 2-го столбца
    cout << "Second column:\n";
    show(vcol, 1);							// отображение в 1м столбце
    vint vrow(valint[slice(3,3,1)]);			// извлечение 2м строки
    cout << "Second row:\n";
    show(vrow, 3);
    valint[slice(2,4,3)]  = 10;				// присваивание 2-му столбцу
    cout << "Set last column to 10:\n";
    show(valint, 3);
    cout << "Set first column to sum of next two:\n";
    // Операция '+' не определена для sliсе, поэтому преобразуем в valarray<int>
    valint[slice(0,4,3)]  = vint(valint[slice(1,4,3)]) + vint(valint[slice(2,4,3)]);
    show(valint, 3);
    return 0;
}
void show(const vint & v, int cols)
{
    using std::cout;
    using std::endl;
    int lim = v.size();
    for (int i = 0; i < lim; ++i)
    {
        cout.width(3);
        cout << v[i];
        if (i % cols == cols - 1)
            cout << endl;
        else
            cout << ' ';
    }
    if (lim % cols != 0)
        cout << endl;
}
/* Класс 'gslice', предназначенный для представления многомерных массивов, но 
сказанного должно быть достаточно, чтобы дать представление о том, что собой 
представляет valarray.
  Шаблон initializer_list(C++11).
 Синтаксис списка инициализаторов можно использовать для инициализации
контейнера STL списком значений: */
std::vector<double> payments {45.99, 39.23, 19.95, 89.01};
/* Этот оператор создает контейнер для четырех элементов, инициализируя их четырьмя 
значениями из списка. Подобное возможно благодаря тому, что теперь классы контейнеров 
имеют конструкторы, которые принимают аргумент initializer_list<T>. Например, объект 
vector<double> имеет конструктор, который принимает аргумент initializer_list<double>,
и предыдущее объявление эквивалентно следующему: */
std::vector<double> payments ({45.99, 39.23, 19.95, 89.01});
/* В этом примере список явно записан в виде аргумента конструктора. Обычно с помощью
универсального синтаксиса инициализации С++11 класс конструктора можно вызвать, используя
нотацию {} вместо (): */
shared_ptr<double> pd { new double };	// можно использовать {} вместо ()
// Но это приводит к проблеме при наличии конструктора initializer_list:
std::vector<int> vi{10};		// Какой конструктор вызывает этот оператор?
std::vector<int> vi(10);		// случай А: 10 неинициализированных элементов
std::vector<int> vi({10});	// случай В: первый элемент установлен в '10'
/* Ответ следующий: если класс обладает конструктором, который принимает аргумент 
initializer_list, то применение синтаксиса {} ведет к вызову конкретного конструктора.
Поэтому к данному примеру применим случай В. Все элементы initializer_list должны быть 
одного типа. Однако компилятор будет выполнять приведения типа: */
std::vector<double> payments {45.99, 39.23, 19, 89}; // то же что и {45.99, 39.23, 19.0, 89.0};
// При этом применяются обычные ограничения списка, налагаемые на его сужение:
std::vector<int> values = {10, 8, 5.5};	// сужение, ошибка времени компиляции
/* В данном случае тип элемента — int, а неявное преобразование 5.5 к типу int не допускается.
Нет смысла указывать конструктор initializer_list, если только класс не предназначен для
работы со списками переменных размеров. Например, нежелательно использовать конструктор 
initializer_list для класса, который принимает фиксированное число значений. Приведенное 
ниже объявление не предоставляет конструктор initializer_list для трех членов данных: */
class Position
{
private:
	int x;
	int y;
	int z;
public:
Position(int xx = 0, int yy = 0, int zz = 0) : x(xx), у(yy), z(zz) {} // нет конструкторов initializer_list
};
// Это позволяет применять синтаксис {} с конструктором Position(int, int, int):
Position A = {20, -3};	// использует Position(20,-3, 0)
/*  Использование initializer_list.
 Объекты initializer_list можно применять в коде, подключая заголовочный файл 
<initializer_list>. Класс шаблона имеет члены begin() и end(), и их можно использовать
для получения доступа к элементам списка. Класс имеет также член size(), который 
возвращает количество элементов. */
#include <iostream>				// ilist.cpp -- использование initializer_list (средство С++11)
#include <initializer_list>
double sum(std::initializer_list<double> il);
double average(const std::initializer_list<double> & ril, const double & tot);
int main()
{
    using std::cout;
    double tot = sum({2,3,4});
    cout << "List 1: sum = " << tot			// список 1, его сумма и среднее
         << ", ave = " << average({2,3,4}, tot) << '\n';
    std::initializer_list<double> dl = {1.1, 2.2, 3.3, 4.4, 5.5};
    tot = sum(dl);
    cout << "List 2: sum = " << tot			// список 2, его сумма и среднее
         << ", ave = " << average(dl, tot) << '\n';
    dl = {16.0, 25.0, 36.0, 40.0, 64.0};		// переменную списка можно присоединить к другому списку
    tot = sum(dl);
    cout << "List 3: sum = " << tot			// список 3, его сумма и среднее
         << ", ave = " << average(dl, tot) << '\n';
    return 0;
}
double sum(std::initializer_list<double> il)	// объект initializer_list передан по значению
{
    double tot = 0;
    for (auto p = il.begin(); p != il.end(); p++)
        tot += *p;
    return tot;
}
// объект initializer_list передан по ссылке:
double average(const std::initializer_list<double> & ril, const double & tot)
{
    if (ril.size())
        return tot / ril.size();
    return 0.0;
}
/* Типом итераторов для initializer_list является const, поэтому изменение
значений в списке невозможно: */
*dl.begin() = 2011.6;	// не разрешено
/* Однако запланированное применение класса initializer_list — передача 
списка значений конструктору или другой функции.