enum // представляет собой альтернативный по отношению к const
// способ создания символических констант.
enum spectrum {red, orange, yellow, green, blue, violet, indigo, ultraviolet};
red == 0; ... ultraviolet == 7;
spectrum band;	// band — переменная типа spectrum
band = blue;	// blue - перечислитель == 4
/* Перечисления — целочисленные типы, и они могут быть представлены в виде
int, однако тип int не преобразуется автоматически в тип перечисления: */
++band; 			 // неправильно
int color = blue;	 // правильно, тип spectrum приводится к int
band = 3;			 // неправильно, int не преобразуется в spectrum
color = 3 + red;	 // правильно, red преобразуется в int
band = orange + red; // неправильно, операция '+' не определена для перечислителей.
band = spectrum(3);  // правильно, приведение 3 к типу spectrum
/* Конкретные значения элементов перечислений можно устанавливать явно 
посредством операция присваивания: */
enum bits {one = 1, two = 2, four = 4, eight = 8};
enum bigstep{first, second = 100, third};	// first == 0; third == 101;
enum {zero, null = 0, one, numero_uno = 1}; /* Здесь zero и null имеют значение 0, 
a one и numero_uno — значение 1.
В C++ элементам перечислений можно использовать значения типа int, long или long long.
Каждое перечисление имеет диапазон, и с помощью приведения к типу 
переменной перечисления можно присвоить любое целочисленное значение в пределах
этого диапазона, даже если данное значение не равно ни одному из перечислителей. */
enum bits {one = 1, two = 2, four = 4, eight = 8};
bits myflag;
myflag = bits(6); // правильно, потому что 6 находится в пределах диапазона
/* Для нахождения верхнего предела
выбирается перечислитель с максимальным значением. Затем ищется наименьшее
число, являющееся степенью двойки, которое больше этого максимального значения,
и из него вычитается единица. (Например, максимальное значение bigstep, как 
определено выше, равно 101. Минимальное число, представляющее степень двойки,
которое больше 101, равно 128, поэтому верхним пределом диапазона будет 127.)
Для нахождения минимального предела выбирается минимальное значение 
перечислителя. Если оно равно 0 или больше, то нижним пределом диапазона будет 0. 
Если же минимальное значение перечислителя отрицательное, используется такой же 
подход, как при вычислении верхнего предела, но со знаком минус. (Например, если
минимальный перечислитель равен -6, то следующей степенью двойки будет -8, и
нижний предел получается равным -7.)
 Входной поток cin не распознает перечислимые типы (он не может знать, как вы 
определите их), поэтому программа читает выбор как int. Когда оператор switch 
сравнивает значение int с перечислимой меткой case, он приводит перечисление к 
типу int. Точно также перечисления приводятся к int в проверочном условии цикла 
while. */
enum {red, orange, yellow, green, blue, violet, indigo};
int code;
cin >> code;
while (code >= red && code <= indigo)
{
	switch (code)
	{
		case red : cout << "Her lips were red.\n"; break;
		case orange : cout << "Her hair was orange.\n"; break;
		case yellow : cout << "Her shoes were yellow.\n"; break;
		case green : cout << "Her nails were green.\n"; break;
		case blue : cout << "Her sweatsuit was blue.\n"; break;
		case violet : cout << "Her eyes were violet.\n"; break;
		case indigo : cout << "Her mood was indigo.\n"; break;
		}
cout << "Enter color code (0-6): ";
cin >> code;
}
/*	Перечисления с областью видимости не поддерживают неявных преобразований 
в целочисленные типы: */
enum egg_old {Small, Medium, Large, Jumbo};			// без области видимости
enum class t_shirt {Small, Medium, Large, Xlarge};	// с областью видимости
egg_old one = Medium;			// без области видимости
t_shirt rolf = t_shirt::Large;  // с областью видимости
int king = one;		// неявное преобразование для перечисления без области видимости
int ring = rolf;	// не разрешено, неявное преобразование типа не поддерживается
if (king < Jumbo)	// разрешено
	std::cout << "Jumbo converted to int before comparison.\n";
if (king < t_shirt::Medium)		// не разрешено
	std::cout << "Not allowed: < not defined for scoped enum.\n";
// Однако при необходимости можно выполнять явное преобразование типа:
int Frodo = int(t_shirt::Small); // Frodo устанавливается в 0
/* По умолчанию лежащим в основе типом для перечислений с областью видимости C++11
является int. Более того, доступен синтаксис для указания другого лежащего в основе
типа. Лежащим в основе типом для pizza является short: */
enum class : short pizza {Small, Medium, Large, XLarge};
/* Лежащий в основе тип должен быть целочисленным.

	Assert — это специальная конструкция, позволяющая проверять предположения о 
значениях произвольных данных в произвольном месте программы. Эта конструкция 
может автоматически сигнализировать при обнаружении некорректных данных, что 
обычно приводит к аварийному завершению программы с указанием места обнаружения 
некорректных данных. Т.к. assert завершает программу сразу же после обнаружения 
некорректных данных, он позволяет быстро локализировать и исправить баги в 
программе, которые привели к некорректным данным. Это его основное назначение. 
Assert'ы позволяют отлавливать ошибки в программах на этапе компиляции либо во 
время исполнения. 
	Assert'ы можно разделить на следующие классы:
• Проверка входящих аргументов в начале функции. */
// Считает факториал числа n.
// Число n должно лежать в пределах от 0 до 10 включительно.
int factorial(int n)
{
  // Факториал отрицательного числа не считается
  assert(n >= 0);
  // Если n превысит 10, то это может привести либо к целочисленному
  // переполнению результата, либо к переполнению стэка.
  assert(n <= 10);
  if (n < 2)
  {
    return 1;
  }

  return factorial(n - 1) * n;
}
/* мы 'забыли' об ограничениях функции factorial() и пытаемся вычислить
// факториалы чисел от 0 до 99.
// проверка внутри factorial() любезно напомнит нам о своих ограничениях,
// так что мы сможем быстро выявить и исправить этот баг.
// если бы эта проверка отсутствовала, то баг мог бы долго оставаться
// незамеченным, периодически давая о себе знать переполнениями стэка и
// некорректным поведением программы.*/
for (int i = 0; i < 100; ++i)
{
  a[i] = factorial(i);
}
/* Важно понимать, что входящие аргументы функции могут быть неявными. Например, 
при вызове метода класса в функцию неявно передается указатель на объект данного 
класса (aka this и self). Также функция может обращаться к данным, объявленным в 
глобальной области видимости, либо к данным из области видимости лексического 
замыкания. Эти аргументы тоже желательно проверять с помощью assert'ов при входе 
в функцию. Если некорректные данные обнаружены на этом этапе, то код данной 
функции может содержать баги. */
int factorial(int n)
{
  int result = 1;
  for (int i = 2; i <= n; ++i)
  {
    result *= i;
  }
  /* С первого взгляда эта проверка никогда не сработает - факториал должен
  // быть всегда положительным числом. Но как только n превысит допустимый
  // предел, произойдет целочисленное переполнение. В этом случае
  // a[i] может принять отрицательное либо нулевое значение.
  // После срабатывания этой проверки мы быстро локализуем баг и поймем,
  // что либо нужно ограничивать значение n, либо использовать целочисленную
  // арифметику с бесконечной точностью. */
  assert(result > 0);
  return result;
}
/* Результат функции может быть неявным. Например, функция может модифицировать 
данные, на которые ссылаются (напрямую или косвенно) аргументы функции. Также 
функция может модифицировать данные из глобальной области видимости или из 
области видимости лексического замыкания. Корректность этих данных желательно 
проверять перед выходом из функции.
Проверка данных, с которыми работает функция, внутри кода функции.
• Если в середине функции обнаруживаются некорректные данные, то баги могут быть 
где-то в районе этой проверки. */
int factorial(int n)
{
  int result = 1;
  while (n > 1) 
  {
    // Знакомая нам проверка на целочисленное переполнение.
    // При ее срабатывании мы быстро определим, что эта функция должна уметь
    // корректно обрабатывать слишком большие n, ведущие к переполнению.
    // Эта проверка лучше, чем проверка из предыдущего пункта (перед выходом
    // из функции), т.к. она срабатывает перед первым переполнением result,
    // тогда как проверка из предыдущего пункта может пропустить случай, когда
    // в результате переполнения (или серии переполнений) итоговое значение
    // result остается положительным.
    assert(result <= INT_MAX / n);
    result *= n;
    --n;
  }
  return result;
}
/* Внутри assert'а нельзя вызывать функции, изменяющие состояние программы либо 
внешнего окружения программы. Например, следующий код неправильно использует 
assert'ы: */
// Захватывает данный мютекс.
// Возвращает 0, если невозможно захватить данный мютекс из-за следующих причин:
// - мютекс уже был захвачен.
// - mtx указывает на некорректный объект мютекса.
// Возвращает 1, если мютекс успешно захвачен.
int acquire_mutex(mutex *mtx);
// Освобождает данный мютекс.
// Возвращает 0, если невозможно освободить данный мютекс из-за следующих
// причин:
// - мютекс не был захвачен.
// - mtx указывает на некорректный объект мютекса.
// Возвращает 1, если мютекс успешно захвачен.
int release_mutes(mutex *mtx);
// Убеждаемся, что мютекс захвачен.
assert(acquire_mutex(mtx));
// Работаем с данными, "защищенными" мютексом.
process_data(data_protected_by_mtx);
// Убеждаемся, что мютекс освобожден.
assert(release_mutes(mtx));
/* Очевидно, что данные могут оказаться незащищенными при отключенных 
assert'ах. Чтобы исправить эту ошибку, нужно сохранять результат выполнения 
функции во временной переменной, после чего использовать эту переменную внутри 
assert'а: */
int is_success;
is_success = acquire_mutex(mtx);
assert(is_success);
// Теперь данные защищены мютексом даже при отключенных assert'ах.
process_data(data_protected_by_mtx);
is_success = release_mutex(mtx);
assert(is_success);
/* Т.к. основное назначение assert'ов — отлов багов (aka ошибки программирования), 
то они не могут заменить обработку ожидаемых ошибок, которые не являются ошибками 
программирования. Например: */
// Пытается записать buf_size байт данных, на которые указывает buf,
// в указанное сетевое соединение connection.
// Возвращает 0 в случае ошибки записи, возникшей не по нашей вине. Например,
// произошел разрыв сетевого соединения во время записи.
// Возвращает 1 в случае успешной записи данных.
int write(connection *connection, const void *buf, size_t buf_size);
int is_success = write(connection, buf, buf_size);
// "Убеждаемся", что данные корректно записаны.
assert(is_success);
/* Если write() возвращает 0, то это вовсе не означает, что в нашей программе есть 
баг. Если assert'ы в программе будут отключены, то ошибка записи может остаться 
незамеченной, что впоследствие может привести к печальным результатам. Поэтому 
assert() тут не подходит. Тут лучше подходит обычная обработка ошибки. Например: */
while (!write(connection, buf, buf_size))
{
  // Пытаемся создать новое соединение и записать данные туда еще раз.
  close_connection(connection);
  connection = create_connection();
}

/* 
• vector - коллекция элементов Т, сохраненных в массиве, увеличиваемом по мере необходимости. 
Для того, чтобы начать использование данной коллекции, включите #include <vector>.
• list - коллекция элементов Т, сохраненных, как двунаправленный связанный список. Для того, 
чтобы начать использование данной коллекции, включите #include <list>.
• map - это коллекция, сохраняющая пары значений pair<const Key, T>. Эта коллекция предназначена 
для быстрого поиска значения T по ключу const Key. В качестве ключа может быть использовано все, 
что угодно, например, строка или int но при этом необходимо помнить, что главной особенностью 
ключа является возможность применить к нему операцию сравнения. Быстрый поиск значения по ключу 
осуществляется благодаря тому, что пары хранятся в отсортированном виде. Эта коллекция имеет 
соответственно и недостаток - скорость вставки новой пары обратно пропорциональна количеству 
элементов, сохраненных в коллекции, поскольку просто добавить новое значение в конец коллекции 
не получится. Еще одна важная вещь, которую необходимо помнить при использовании данной коллекции - 
ключ должен быть уникальным. Для того, чтобы начать использование данной коллекции, включите
#include <map>. Если вы хотите использовать данную коллекцию, чтобы избежать дубликатов, то вы 
избежите их только по ключу.
• set - это коллекция уникальных значений const Key - каждое из которых является также и ключом - 
то есть, проще говоря, это отсортированная коллекция, предназначенная для быстрого поиска 
необходимого значения. К ключу предъявляются те же требования, что и в случае ключа для map. 
Естественно, использовать ее для этой цели нет смысла, если вы хотите сохранить в ней простые 
типы данных, по меньшей мере вам необходимо определить свой класс, хранящий пару ключ - значение 
и определяющий операцию сравнения по ключу. Очень удобно использовать данную коллекцию, если вы 
хотите избежать повторного сохранения одного и того же значения. Для того, чтобы начать использование 
данной коллекции, включите #include <set>.
• multimap - это модифицированный map, в котором отсутствует требования уникальности ключа - то есть, 
если вы произведете поиск по ключу, то вам вернется не одно значение, а набор значений, сохраненных с 
данным ключом. Для того, чтобы начать использование данной коллекции включите #include <map>.
• multiset - то же самое относится и к этой коллекции, требования уникальности ключа в ней не 
существует, что приводит к возможности хранения дубликатов значений. Тем не менее, существует 
возможность быстрого нахождения значений по ключу в случае, если вы определили свой класс. Поскольку 
все значения в map и set хранятся в отсортированном виде, то получается, что в этих коллекциях мы 
можем очень быстро отыскать необходимое нам значение по ключу, но при этом операция вставки нового 
элемента T будет стоить нам несколько дороже, чем например в vector. Для того, чтобы начать 
использование данной коллекции, включите #include <set>.
• string - представляет из себя коллекцию, хранящую символы char в формате ASCII. Для того, чтобы 
использовать данную коллекцию, вам необходимо включить #include <string>.
• wstring - это коллекция для хранения двухбайтных символов wchar_t, которые используются для 
представления всего набора символов в формате Unicode. Для того, чтобы использовать данную коллекцию, 
вам необходимо включить #include <xstring>.
	Строковые потоки.
Используются для организации сохранения простых типов данных в STL строки в стиле C++. 
Возможности использования строковых потоков: */
#include <tchar.h> // для ms visual "stdafx.h", для g++ #include <tchar.h>
#include <iostream>
#include <strstream>
#include <string>
using namespace std;
int _tmain (int argc, _TCHAR* argv [])
{
    std::strstream xstr;
    for (int i = 0; i < 10; i++)
        xstr << "Demo " << i << std::endl;
    std::cout << xstr.str();
    std::string str;
    str.assign (xstr.str(), xstr.pcount());
    std::cout << str.c_str();
    return 0;
}
/* Строковый поток - это просто буфер, в конце которого установлен нуль терминатор, поэтому мы 
наблюдаем в конце строки мусор при первой распечатке, то есть реальный конец строки определен не 
посредством нуль терминатора, а с помощью счетчика, и его размер мы можем получить с помощью 
метода: pcount(). Далее мы производим копирование содержимого буфера в строку и печатаем строку 
второй раз. На этот раз она печатается без мусора. Основные методы, которые присутствуют почти во 
всех STL коллекциях, приведены ниже:
• empty - определяет, является ли коллекция пустой.
• pcount - счетчик, определяет размер буфера потока.
• size - определяет размер коллекции.
• begin - возвращает прямой итератор, указывающий на начало коллекции.
• end - возвращает прямой итератор, указывающий на конец коллекции. При этом надо учесть, что 
реально он не указывает на ее последний элемент, а указывает на воображаемый несуществующий элемент, 
следующий за последним.
• rbegin - возвращает обратный итератор, указывающий на начало коллекции.
• rend - возвращает обратный итератор, указывающий на конец коллекции. При этом надо учесть, что 
реально он не указывает на ее последний элемент, а указывает на воображаемый несуществующий элемент, 
следующий за последним.
• clear - удаляет все элементы коллекции, при этом, если в вашей коллекции сохранены указатели, то 
вы должны не забыть удалить все элементы вручную посредством вызова delete для каждого указателя.
• erase - удаляет элемент или несколько элементов из коллекции.
• capacity - вместимость коллекции определяет реальный размер - то есть размер буфера коллекции, а 
не то, сколько в нем хранится элементов. Когда вы создаете коллекцию, то выделяется некоторое 
количество памяти. Как только размер буфера оказывается меньшим, чем размер, необходимый для хранения 
всех элементов коллекции, происходит выделение памяти для нового буфера, а все элементы старого 
копируются в новый буфер. При этом размер нового буфера будет в два раза большим, чем размер буфера, 
выделенного перед этим - такая стратегия позволяет уменьшить количество операций перераспределения 
памяти, но при этом очень расточительно расходуется память. Причем в некоторых реализациях STL первое 
выделение памяти происходит не в конструкторе, а как ни странно, при добавлении первого элемента 
коллекции.
	Наиболее часто используемая коллекция - это вектор. Как уже было отмечено выше, внутренняя 
реализация этой коллекции представляет из себя массив и счетчик элементов, сохраненных в нем. 
Фрагмент программы ниже демонстрирует, что размер и вместимость коллекции - две разные сущности: */
#include <iostream>
#include <vector>
int main()
{
	std::vector<int> vec;
	std::cout << "Real size of array in vector: "
			  << vec.capacity() << std::endl;
	for (int j = 0; j < 10; j++)
		vec.push_back (10);
	std::cout << "Real size of array in vector: "
			  << vec.capacity() << std::endl;
	return 0;
}

/* Предположим, нам необходимо написать логику клиент - серверного приложения. Администратор 
сети посылает сообщения на сервер с определенным интервалом, где они сохраняются в одном общем 
массиве common, при этом каждое сообщение имеет поле To, однозначно идентифицирующее каждого клиента.
	Каждый клиент также подключается к серверу, но с гораздо большим интервалом, чем приход сообщений 
от администратора, чтобы просмотреть сообщения, адресованные ему. При этом нам также необходимо знать 
хронологию прихода сообщений, адресованных разным пользователям (какое сообщение пришло раньше, а 
какое позже в любой момент времени). Для того, чтобы получить сообщения, клиент должен подключиться 
к серверу, просмотреть массив common для того, чтобы выбрать сообщения, адресованные ему, и после 
отключиться.
Три клиента подключаются к серверу и каждый просматривает общий массив сообщений, при 
этом мы должны сделать наше приложение поточно - безопасным, поэтому должны использовать 
код внутри критической секции. Все это рано или поздно приведет к тому, что с увеличением 
числа клиентов приложение станет очень медленным.
	Для того, чтобы избежать этой ситуации, мы заведем массив сообщений для каждого клиента 
и вместо того, чтобы просматривать общий массив сообщений три раза, мы будем просматривать 
его всего лишь один раз с интервалом времени, адекватным периоду подключения одного клиента. 
При этом скопируем все сообщения в соответствующие массивы. Клиенты же будут просто 
забирать данные из своих массивов при подключении.
	На самом деле это немного неправильный подход для решения этой задачи. Скорее всего, 
нам надо было бы сохранять сообщения в момент их прихода в оба массива, но наша цель - 
посмотреть возможности использования коллекции vector, поэтому воспользуемся этим подходом и 
представим упрощенную логику такого приложения: */
#include <tchar.h> // для ms visual "stdafx.h", для g++ #include <tchar.h>
#include <iostream>
#include <strstream>
#include <string>
#include <vector>
#include <algorithm>
using namespace std;

class MyMessage
{
private:
    string from;
    string to;
    string message;
    int id;
public:
    MyMessage(string from, string to, string message)
    {
        this->from = from;
        this->to = to;
        this->message = message;
    }
    int GetId()
    {
        return this->id;
    }
    void SetId(int id)
    {
        this->id = id;
    }
    string GetMessage()
    {
        return this->message;
    }
    string GetFrom()
    {
        return this->from;
    }
    string GetTo()
    {
        return this->to;
    }
};

int _tmain (int argc, _TCHAR* argv [])
{
    vector<MyMessage> common;
    // create pool of messages for 3 users:
    for (int user = 0; user < 3; user++)
        for (int i = 0; i < 10; i++)
        {
            strstream messagex;
            messagex << "Message " << i;
            string smessage;
            smessage.assign (messagex.str(), messagex.pcount());
            strstream userx;
            userx << "User " << user;
            string suser;
            suser.assign (userx.str(), userx.pcount());
            MyMessage message ("Administrator", suser, smessage);
            message.SetId (user*10 + i);
            common.push_back (message);
        }
    // create vector for each user:
    vector<MyMessage> user0;
    vector<MyMessage> user1;
    vector<MyMessage> user2;
    for (int x = 0; x < (int)common.size(); x++)
    {
        MyMessage message = common[x];
        if (message.GetTo() == "User 0")
            user0.push_back(message);
        else
            if (message.GetTo() == "User 1")
                user1.push_back (message);
            else
                if (message.GetTo() == "User 2")
                    user2.push_back(message);
    }
    cout << "Messages for user 2: " << endl;
    for (int i = 0; i < (int)user2.size(); i++)
    {
        MyMessage message = user2[i];
        cout << message.GetMessage() << endl;
    }
    cout << "Messages for user 1: " << endl;
    for (int i = 0; i < (int)user1.size(); i++)
    {
        MyMessage message = user1[i];
        cout << message.GetMessage() << endl;
    }
    cout << "Messages for user 0: " << endl;
    for (int i = 0; i < (int)user0.size(); i++)
    {
    MyMessage message = user0[i];
    cout << message.GetMessage() << endl;
    }
	cout << "Size of common vector: " << (int)common.size() << endl;
	return 0;
}
/* Теперь у вас есть некоторое представление о том, каким образом писать бизнес - логику 
приложений с использованием STL. Из этого приложения видно, что кроме перечисленных выше методов, 
у вектора есть оператор operator [], который позволяет нам пользоваться вектором так же, как 
обычным массивом. Этот оператор используется также в map, deque, string и wstring.

	Итератор - это абстракция, которая ведет себя, как указатель с некоторыми ограничениями 
или без них, то есть, сохраняет все свойства своего прародителя. Указатель - это тоже итератор. 
В действительности, итераторы, в большинстве случаев, это объектные обертки указателей. Вот 
как примерно может выглядеть внутреннее устройство итератора: */
class Iterator
{
	T* pointer;
public:
	T* GetPointer()
	{
		return this->pointer;
	}
	void SetPointer (T* pointer)
	{
		this->pointer = pointer;
	}
};
/* Но итератор представляет собой более высокий уровень абстракции, чем указатель, поэтому 
утверждение, что итератор - это указатель в некоторых случаях может быть неверно. А вот обратное 
будет верно всегда. Вот несколько формализованных определений для итератора:
Итераторы обеспечивают доступ к элементам в коллекции. Итераторы для конкретного класса коллекции 
определяются внутри класса этой коллекции. В STL существует три типа итераторов: iterator, 
reverse_iterator, и random access iterator. Для обхода коллекции от меньшего индекса к большему, 
используются обычные или forward итераторы. Для обхода коллекции в обратном направлении 
используются reverse итераторы. Random access iterator являются итераторами, которые могут 
обходить коллекцию как вперед, так и назад. Ниже приведен пример использования итераторов для 
удаления половины элементов вектора: */
#include <tchar.h> // для ms visual "stdafx.h", для g++ #include <tchar.h>
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
void printInt (int number);
int _tmain (int argc, _TCHAR* argv [])
{
	vector<int> myVec;
	vector<int>::iterator first, last;
	for (long i = 0; i < 10; i++)
		myVec.push_back(i);
	first = myVec.begin();
	last = myVec.begin() + 5;
	if (last >= myVec.end())
		return - 1;
	myVec.erase(first, last);
	for_each(myVec.begin(), myVec.end(), printInt);
	return 0;
}

void printInt (int number)
{
	cout << number << endl;
}
/* Важно помнить, что когда вы получаете итератор к коллекции, а после этого модифицируете 
коллекцию, то этот итератор становится уже непригодным к использованию. Естественно, не все 
изменения приводят к непригодности итератора для дальнейшего использования, а только изменения 
структуры коллекции. В случае же, если вы просто измените значения, сохраненные в коллекции, 
то ничего страшного не произойдет и итератор не испортится.
Итерация по коллекции вперед происходит так: */
for (iterator element = begin(); element < end(); element++)
	t = (*element);
// Итерация по коллекции назад происходит так:
for (reverse_iterator element = rbegin(); element < rend(); element++)
	t = (*element);
/* Если вы работаете и с random access iterator итератором, то синтаксис конструкции может 
быть, например, таким: */
for (iterator element = begin(); element < end(); element += 2)
	t = (*element);
/* Для более эффективного использования контейнеров используйте typedef или наследуйте свой 
класс от класса коллекции.
Сделать это можно так: */
typedef vector<int> myVector
typedef map<string, int> myMap
typedef deque<string> myQue
// Или вот такая техника в случае наследования:
class myVector : public vector<int> {};
// В случае с итератором применима предыдущая техника:
typedef myVector::iterator vectorIterator
typedef myVector::reverse_iterator revVectorIterator

/* Алгоритмы
До этого мы посмотрели основные приемы использования STL коллекций на примере использования вектора. 
Это основа STL, но для того, чтобы по - настоящему использовать всю мощь этой библиотеки, придется 
расширить наши знания. С использованием алгоритмов возможно создание очень мощных и эффективных 
программ. По компактности такой код превосходит код, написанный на таких современных языках, 
как Java и С#, и в значительной степени эффективнее последнего.
STL - алгоритмы представляют набор готовых функций, которые могут быть применены к STL коллекциям 
и могут быть подразделены на три основных группы: */
// • Функции для перебора всех членов коллекции и выполнения определенных действий над каждым из них:
count, count_if, find, find_if, adjacent_find, for_each, mismatch, equal, search copy, 
copy_backward, swap, iter_swap, swap_ranges, fill, fill_n, generate, generate_n, replace, 
replace_if, transform, remove, remove_if, remove_copy, remove_copy_if, unique, unique_copy, 
reverse, reverse_copy, rotate, rotate_copy, random_shuffle, partition, stable_partition
// • Функции для сортировки членов коллекции:
Sort, stable_sort, partial_sort, partial_sort_copy, nth_element, binary_search, lower_bound, 
upper_bound, equal_range, merge, inplace_merge, includes, set_union, set_intersection, 
set_difference, set_symmetric_difference, make_heap, push_heap, pop_heap, sort_heap, min, 
max, min_element, max_element, lexographical_compare, next_permutation, prev_permutation
// • Функции для выполнения определенных арифметических действий над членами коллекции:
Accumulate, inner_product, partial_sum, adjacent_difference
/* Для того, чтобы использовать все это разнообразие, у вас под рукой должна быть соответствующая 
документация. Microsoft предлагает достаточно подробную документацию, как часть MSDN для своей 
реализации STL. Достаточно подробную и обстоятельную документацию предлагает так же SGI. Для того, 
чтобы использовать ее, вам придется загрузить STLPort библиотеку, представляющую из себя набор из 
документации и хедер - файлов. Эта библиотека заслуженно считается одной из лучших, Borland уже 
включил ее как часть своего продукта, так что если вы используете C++ Builder 6.0, то делать 
это необязательно. При этом вы можете использовать эту библиотеку практически с любыми 
компиляторами, так что, если вы действительно стремитесь к переносимости своего кода, то это 
хороший выбор.
Ранее мы уже использовали один из алгоритмов: for_each() для того, чтобы распечатать все значения 
из вектора. Я думаю, не требует дополнительных объяснений то, что произошло при этом. Единственное, 
что бы хотелось отметить, что, кроме указателя на функцию в этом случае мы могли бы передать 
функтор - специальный класс с перегруженным оператором operator(). Для того, чтобы показать, 
как это делается, ниже приведена простая программа. */
#include <tchar.h> // для ms visual "stdafx.h", для g++ #include <tchar.h>
#include <iostream>
#include <strstream>
#include <string>
#include <vector>
#include <algorithm>
using namespace std;

class MyFunctor
{
private:
	string comment;
public:
	MyFunctor()
	{
		comment = "My comment";
	};
	MyFunctor(string comment)
	{
		this -> comment = comment;
	}
	void operator()(int test)
	{
		cout << test << comment << endl;
	};
};
int _tmain(int argc, _TCHAR* argv[])
{
	vector<int> test;
// fill vector:
	for (int i = 0; i < 5; i++)
		test.push_back(i);
// now use our functor:
	MyFunctor functor(" Test comment");
	for_each (test.begin(), test.end(), functor);
	return 0;
}
/* Преимущество такого подхода заключается в том, что если нам необходимо передать какие - либо параметры 
для того, чтобы произвести обработку каждого члена коллекции, то мы имеем возможность сделать это в 
конструкторе функтора или определить дополнительные функции в классе - функторе. Это позволит нам 
сократить количество переменных в области видимости функции - обработчика членов коллекции для хранения 
значений, которые впоследствии будут использованы внутри тела этой функции. Если же для работы над членами 
коллекции нам не нужно передавать параметры, то целесообразнее определить просто функцию.
	Еще один небольшой пример использования алгоритмов приведен ниже, мы создаем две коллекции: женскую 
и мужскую, после чего заполняем каждую из них соответствующими именами мужчин и женщин. Если мы 
захотим поменять местонахождение членов обоих коллекций - то есть, женщин поместить в мужскую коллекцию 
и наоборот, то сделать это с использованием алгоритмов очень просто: */
#include <tchar.h> // для ms visual "stdafx.h", для g++ #include <tchar.h>
#include <iostream>
#include <strstream>
#include <string>
#include <vector>
#include <algorithm>
using namespace std;

void printMan (string user);
int _tmain (int argc, _TCHAR* argv [])
{
	vector<string> maleRoom;
	vector<string> fimaleRoom;
	maleRoom.push_back ("Vasya");
	maleRoom.push_back ("Petya");
	maleRoom.push_back ("Sasha");

	fimaleRoom.push_back ("Nastya");
	fimaleRoom.push_back ("Alena");
	fimaleRoom.push_back ("Sveta");

	for_each (maleRoom.begin (), maleRoom.end (), printMan);
	reverse (maleRoom.begin (), maleRoom.end ());
	cout << "Males in reverse order " << endl;
	for_each (maleRoom.begin (), maleRoom.end (), printMan);
	maleRoom.swap (fimaleRoom);
	cout << "Now in male room are fimales: " << endl;
	for_each (maleRoom.begin (), maleRoom.end (), printMan);
	return 0;
}
void printMan (string man)
{
	cout << man << endl;
}






